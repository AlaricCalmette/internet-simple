_N_E =
(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([["pages/_app"],{

/***/ "./.yarn/__virtual__/css-loader-virtual-c914f70651/0/cache/css-loader-npm-4.3.0-33464197c9-697a8838f0.zip/node_modules/css-loader/dist/cjs.js?!./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/compiled/postcss-loader/cjs.js?!./lib/styles/styles.css":
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/css-loader-virtual-c914f70651/0/cache/css-loader-npm-4.3.0-33464197c9-697a8838f0.zip/node_modules/css-loader/dist/cjs.js??ref--5-oneOf-6-1!./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-6-2!./lib/styles/styles.css ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _yarn_virtual_css_loader_virtual_c914f70651_0_cache_css_loader_npm_4_3_0_33464197c9_697a8838f0_zip_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../.yarn/__virtual__/css-loader-virtual-c914f70651/0/cache/css-loader-npm-4.3.0-33464197c9-697a8838f0.zip/node_modules/css-loader/dist/runtime/api.js */ "./.yarn/__virtual__/css-loader-virtual-c914f70651/0/cache/css-loader-npm-4.3.0-33464197c9-697a8838f0.zip/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _yarn_virtual_css_loader_virtual_c914f70651_0_cache_css_loader_npm_4_3_0_33464197c9_697a8838f0_zip_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_yarn_virtual_css_loader_virtual_c914f70651_0_cache_css_loader_npm_4_3_0_33464197c9_697a8838f0_zip_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _yarn_virtual_css_loader_virtual_c914f70651_0_cache_css_loader_npm_4_3_0_33464197c9_697a8838f0_zip_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, "body {\n  margin: 0;\n  background-color: #ffcdb2;\n}\n\n#__next {\n  height: 100vh;\n}\n", "",{"version":3,"sources":["webpack://lib/styles/styles.css"],"names":[],"mappings":"AAAA;EACE,SAAS;EACT,yBAAyB;AAC3B;;AAEA;EACE,aAAa;AACf","sourcesContent":["body {\n  margin: 0;\n  background-color: #ffcdb2;\n}\n\n#__next {\n  height: 100vh;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ __webpack_exports__["default"] = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./.yarn/__virtual__/css-loader-virtual-c914f70651/0/cache/css-loader-npm-4.3.0-33464197c9-697a8838f0.zip/node_modules/css-loader/dist/runtime/api.js":
/*!************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/css-loader-virtual-c914f70651/0/cache/css-loader-npm-4.3.0-33464197c9-697a8838f0.zip/node_modules/css-loader/dist/runtime/api.js ***!
  \************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/build/polyfills/object-assign.js":
/*!*************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/build/polyfills/object-assign.js ***!
  \*************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var assign=Object.assign.bind(Object);module.exports=assign;module.exports.default=module.exports;
//# sourceMappingURL=object-assign.js.map

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F_app&absolutePagePath=private-next-pages%2F_app.tsx!./":
/*!******************************************************************************************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F_app&absolutePagePath=private-next-pages%2F_app.tsx ***!
  \******************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


    (window.__NEXT_P = window.__NEXT_P || []).push([
      "/_app",
      function () {
        return __webpack_require__(/*! private-next-pages/_app.tsx */ "./pages/_app.tsx");
      }
    ]);
  

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/client/normalize-trailing-slash.js":
/*!***************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/client/normalize-trailing-slash.js ***!
  \***************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.removePathTrailingSlash = removePathTrailingSlash;
exports.normalizePathTrailingSlash = void 0;
/**
* Removes the trailing slash of a path if there is one. Preserves the root path `/`.
*/

function removePathTrailingSlash(path) {
  return path.endsWith('/') && path !== '/' ? path.slice(0, -1) : path;
}
/**
* Normalizes the trailing slash of a path according to the `trailingSlash` option
* in `next.config.js`.
*/


var normalizePathTrailingSlash =  false ? undefined : removePathTrailingSlash;
exports.normalizePathTrailingSlash = normalizePathTrailingSlash;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js */ "./.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/client/request-idle-callback.js":
/*!************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/client/request-idle-callback.js ***!
  \************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = void 0;

var requestIdleCallback = typeof self !== 'undefined' && self.requestIdleCallback || function (cb) {
  var start = Date.now();
  return setTimeout(function () {
    cb({
      didTimeout: false,
      timeRemaining: function timeRemaining() {
        return Math.max(0, 50 - (Date.now() - start));
      }
    });
  }, 1);
};

var _default = requestIdleCallback;
exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js */ "./.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/client/route-loader.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/client/route-loader.js ***!
  \***************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/regenerator */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/regenerator/index.js");

var _slicedToArray = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/slicedToArray */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/slicedToArray.js");

var _asyncToGenerator = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/asyncToGenerator */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.markAssetError = markAssetError;
exports.isAssetError = isAssetError;
exports.getClientBuildManifest = getClientBuildManifest;
exports["default"] = void 0;

var _getAssetPathFromRoute = _interopRequireDefault(__webpack_require__(/*! ../next-server/lib/router/utils/get-asset-path-from-route */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js"));

var _requestIdleCallback = _interopRequireDefault(__webpack_require__(/*! ./request-idle-callback */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/client/request-idle-callback.js")); // 3.8s was arbitrarily chosen as it's what https://web.dev/interactive
// considers as "Good" time-to-interactive. We must assume something went
// wrong beyond this point, and then fall-back to a full page transition to
// show the user something of value.


var MS_MAX_IDLE_DELAY = 3800;

function withFuture(key, map, generator) {
  var entry = map.get(key);

  if (entry) {
    if ('future' in entry) {
      return entry.future;
    }

    return Promise.resolve(entry);
  }

  var resolver;
  var prom = new Promise(function (resolve) {
    resolver = resolve;
  });
  map.set(key, entry = {
    resolve: resolver,
    future: prom
  });
  return generator ? // eslint-disable-next-line no-sequences
  generator().then(function (value) {
    return resolver(value), value;
  }) : prom;
}

function hasPrefetch(link) {
  try {
    link = document.createElement('link');
    return (// detect IE11 since it supports prefetch but isn't detected
      // with relList.support
      !!window.MSInputMethodContext && !!document.documentMode || link.relList.supports('prefetch')
    );
  } catch (_unused) {
    return false;
  }
}

var canPrefetch = hasPrefetch();

function prefetchViaDom(href, as, link) {
  return new Promise(function (res, rej) {
    if (document.querySelector("link[rel=\"prefetch\"][href^=\"".concat(href, "\"]"))) {
      return res();
    }

    link = document.createElement('link'); // The order of property assignment here is intentional:

    if (as) link.as = as;
    link.rel = "prefetch";
    link.crossOrigin = undefined;
    link.onload = res;
    link.onerror = rej; // `href` should always be last:

    link.href = href;
    document.head.appendChild(link);
  });
}

var ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR'); // TODO: unexport

function markAssetError(err) {
  return Object.defineProperty(err, ASSET_LOAD_ERROR, {});
}

function isAssetError(err) {
  return err && ASSET_LOAD_ERROR in err;
}

function appendScript(src, script) {
  return new Promise(function (resolve, reject) {
    script = document.createElement('script'); // The order of property assignment here is intentional.
    // 1. Setup success/failure hooks in case the browser synchronously
    //    executes when `src` is set.

    script.onload = resolve;

    script.onerror = function () {
      return reject(markAssetError(new Error("Failed to load script: ".concat(src))));
    }; // 2. Configure the cross-origin attribute before setting `src` in case the
    //    browser begins to fetch.


    script.crossOrigin = undefined; // 3. Finally, set the source and inject into the DOM in case the child
    //    must be appended for fetching to start.

    script.src = src;
    document.body.appendChild(script);
  });
}

function idleTimeout(ms, err) {
  return new Promise(function (_resolve, reject) {
    return (0, _requestIdleCallback["default"])(function () {
      return setTimeout(function () {
        return reject(err);
      }, ms);
    });
  });
} // TODO: stop exporting or cache the failure
// It'd be best to stop exporting this. It's an implementation detail. We're
// only exporting it for backwards compatibilty with the `page-loader`.
// Only cache this response as a last resort if we cannot eliminate all other
// code branches that use the Build Manifest Callback and push them through
// the Route Loader interface.


function getClientBuildManifest() {
  if (self.__BUILD_MANIFEST) {
    return Promise.resolve(self.__BUILD_MANIFEST);
  }

  var onBuildManifest = new Promise(function (resolve) {
    // Mandatory because this is not concurrent safe:
    var cb = self.__BUILD_MANIFEST_CB;

    self.__BUILD_MANIFEST_CB = function () {
      resolve(self.__BUILD_MANIFEST);
      cb && cb();
    };
  });
  return Promise.race([onBuildManifest, idleTimeout(MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')))]);
}

function getFilesForRoute(assetPrefix, route) {
  if (true) {
    return Promise.resolve({
      scripts: [assetPrefix + '/_next/static/chunks/pages' + encodeURI((0, _getAssetPathFromRoute["default"])(route, '.js'))],
      // Styles are handled by `style-loader` in development:
      css: []
    });
  }

  return getClientBuildManifest().then(function (manifest) {
    if (!(route in manifest)) {
      throw markAssetError(new Error("Failed to lookup route: ".concat(route)));
    }

    var allFiles = manifest[route].map(function (entry) {
      return assetPrefix + '/_next/' + encodeURI(entry);
    });
    return {
      scripts: allFiles.filter(function (v) {
        return v.endsWith('.js');
      }),
      css: allFiles.filter(function (v) {
        return v.endsWith('.css');
      })
    };
  });
}

function createRouteLoader(assetPrefix) {
  var entrypoints = new Map();
  var loadedScripts = new Map();
  var styleSheets = new Map();
  var routes = new Map();

  function maybeExecuteScript(src) {
    var prom = loadedScripts.get(src);

    if (prom) {
      return prom;
    } // Skip executing script if it's already in the DOM:


    if (document.querySelector("script[src^=\"".concat(src, "\"]"))) {
      return Promise.resolve();
    }

    loadedScripts.set(src, prom = appendScript(src));
    return prom;
  }

  function fetchStyleSheet(href) {
    var prom = styleSheets.get(href);

    if (prom) {
      return prom;
    }

    styleSheets.set(href, prom = fetch(href).then(function (res) {
      if (!res.ok) {
        throw new Error("Failed to load stylesheet: ".concat(href));
      }

      return res.text().then(function (text) {
        return {
          href: href,
          content: text
        };
      });
    })["catch"](function (err) {
      throw markAssetError(err);
    }));
    return prom;
  }

  return {
    whenEntrypoint: function whenEntrypoint(route) {
      return withFuture(route, entrypoints);
    },
    onEntrypoint: function onEntrypoint(route, execute) {
      Promise.resolve(execute).then(function (fn) {
        return fn();
      }).then(function (exports) {
        return {
          component: exports && exports["default"] || exports,
          exports: exports
        };
      }, function (err) {
        return {
          error: err
        };
      }).then(function (input) {
        var old = entrypoints.get(route);
        entrypoints.set(route, input);
        if (old && 'resolve' in old) old.resolve(input);
      });
    },
    loadRoute: function loadRoute(route) {
      var _this = this;

      return withFuture(route, routes, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var _yield$getFilesForRou, scripts, css, _yield$Promise$all, _yield$Promise$all2, styles, entrypoint, res;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return getFilesForRoute(assetPrefix, route);

              case 3:
                _yield$getFilesForRou = _context.sent;
                scripts = _yield$getFilesForRou.scripts;
                css = _yield$getFilesForRou.css;
                _context.next = 8;
                return Promise.all([entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)), Promise.all(css.map(fetchStyleSheet))]);

              case 8:
                _yield$Promise$all = _context.sent;
                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
                styles = _yield$Promise$all2[1];
                _context.next = 13;
                return Promise.race([_this.whenEntrypoint(route), idleTimeout(MS_MAX_IDLE_DELAY, markAssetError(new Error("Route did not complete loading: ".concat(route))))]);

              case 13:
                entrypoint = _context.sent;
                res = Object.assign({
                  styles: styles
                }, entrypoint);
                return _context.abrupt("return", 'error' in entrypoint ? entrypoint : res);

              case 18:
                _context.prev = 18;
                _context.t0 = _context["catch"](0);
                return _context.abrupt("return", {
                  error: _context.t0
                });

              case 21:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[0, 18]]);
      })));
    },
    prefetch: function prefetch(route) {
      var _this2 = this;

      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118
      // License: Apache 2.0
      var cn;

      if (cn = navigator.connection) {
        // Don't prefetch if using 2G or if Save-Data is enabled.
        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();
      }

      return getFilesForRoute(assetPrefix, route).then(function (output) {
        return Promise.all(canPrefetch ? output.scripts.map(function (script) {
          return prefetchViaDom(script, 'script');
        }) : []);
      }).then(function () {
        (0, _requestIdleCallback["default"])(function () {
          return _this2.loadRoute(route);
        });
      })["catch"]( // swallow prefetch errors
      function () {});
    }
  };
}

var _default = createRouteLoader;
exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js */ "./.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/client/router.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/client/router.js ***!
  \*********************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _construct = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/construct */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/construct.js");

var _s = $RefreshSig$();

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.useRouter = useRouter;
exports.makePublicRouterInstance = makePublicRouterInstance;
exports.createRouter = exports.withRouter = exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.1-98658812fc-83b9df9529.zip/node_modules/react/index.js"));

var _router2 = _interopRequireWildcard(__webpack_require__(/*! ../next-server/lib/router/router */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/router.js"));

exports.Router = _router2["default"];
exports.NextRouter = _router2.NextRouter;

var _routerContext = __webpack_require__(/*! ../next-server/lib/router-context */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router-context.js");

var _withRouter = _interopRequireDefault(__webpack_require__(/*! ./with-router */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/client/with-router.js"));

exports.withRouter = _withRouter["default"];
/* global window */

var singletonRouter = {
  router: null,
  // holds the actual router instance
  readyCallbacks: [],
  ready: function ready(cb) {
    if (this.router) return cb();

    if (true) {
      this.readyCallbacks.push(cb);
    }
  }
}; // Create public properties and methods of the router in the singletonRouter

var urlPropertyFields = ['pathname', 'route', 'query', 'asPath', 'components', 'isFallback', 'basePath', 'locale', 'locales', 'defaultLocale'];
var routerEvents = ['routeChangeStart', 'beforeHistoryChange', 'routeChangeComplete', 'routeChangeError', 'hashChangeStart', 'hashChangeComplete'];
var coreMethodFields = ['push', 'replace', 'reload', 'back', 'prefetch', 'beforePopState']; // Events is a static property on the router, the router doesn't have to be initialized to use it

Object.defineProperty(singletonRouter, 'events', {
  get: function get() {
    return _router2["default"].events;
  }
});
urlPropertyFields.forEach(function (field) {
  // Here we need to use Object.defineProperty because, we need to return
  // the property assigned to the actual router
  // The value might get changed as we change routes and this is the
  // proper way to access it
  Object.defineProperty(singletonRouter, field, {
    get: function get() {
      var router = getRouter();
      return router[field];
    }
  });
});
coreMethodFields.forEach(function (field) {
  // We don't really know the types here, so we add them later instead
  ;

  singletonRouter[field] = function () {
    var router = getRouter();
    return router[field].apply(router, arguments);
  };
});
routerEvents.forEach(function (event) {
  singletonRouter.ready(function () {
    _router2["default"].events.on(event, function () {
      var eventField = "on".concat(event.charAt(0).toUpperCase()).concat(event.substring(1));
      var _singletonRouter = singletonRouter;

      if (_singletonRouter[eventField]) {
        try {
          _singletonRouter[eventField].apply(_singletonRouter, arguments);
        } catch (err) {
          console.error("Error when running the Router event: ".concat(eventField));
          console.error("".concat(err.message, "\n").concat(err.stack));
        }
      }
    });
  });
});

function getRouter() {
  if (!singletonRouter.router) {
    var message = 'No router instance found.\n' + 'You should only use "next/router" inside the client side of your app.\n';
    throw new Error(message);
  }

  return singletonRouter.router;
} // Export the singletonRouter and this is the public API.


var _default = singletonRouter; // Reexport the withRoute HOC

exports["default"] = _default;

function useRouter() {
  _s();

  return _react["default"].useContext(_routerContext.RouterContext);
} // INTERNAL APIS
// -------------
// (do not use following exports inside the app)
// Create a router and assign it as the singleton instance.
// This is used in client side when we are initilizing the app.
// This should **not** use inside the server.


_s(useRouter, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

var createRouter = function createRouter() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  singletonRouter.router = _construct(_router2["default"], args);
  singletonRouter.readyCallbacks.forEach(function (cb) {
    return cb();
  });
  singletonRouter.readyCallbacks = [];
  return singletonRouter.router;
}; // This function is used to create the `withRouter` router instance


exports.createRouter = createRouter;

function makePublicRouterInstance(router) {
  var _router = router;
  var instance = {};

  var _iterator = _createForOfIteratorHelper(urlPropertyFields),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var property = _step.value;

      if (typeof _router[property] === 'object') {
        instance[property] = Object.assign(Array.isArray(_router[property]) ? [] : {}, _router[property]); // makes sure query is not stateful

        continue;
      }

      instance[property] = _router[property];
    } // Events is a static property on the router, the router doesn't have to be initialized to use it

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  instance.events = _router2["default"].events;
  coreMethodFields.forEach(function (field) {
    instance[field] = function () {
      return _router[field].apply(_router, arguments);
    };
  });
  return instance;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js */ "./.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/client/with-router.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/client/with-router.js ***!
  \**************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = withRouter;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.1-98658812fc-83b9df9529.zip/node_modules/react/index.js"));

var _router = __webpack_require__(/*! ./router */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/client/router.js");

function withRouter(ComposedComponent) {
  function WithRouterWrapper(props) {
    return /*#__PURE__*/_react["default"].createElement(ComposedComponent, Object.assign({
      router: (0, _router.useRouter)()
    }, props));
  }

  WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps // This is needed to allow checking for custom getInitialProps in _app
  ;
  WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;

  if (true) {
    var name = ComposedComponent.displayName || ComposedComponent.name || 'Unknown';
    WithRouterWrapper.displayName = "withRouter(".concat(name, ")");
  }

  return WithRouterWrapper;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js */ "./.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/compiled/path-to-regexp/index.js":
/*!*************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/compiled/path-to-regexp/index.js ***!
  \*************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Tokenize input string.
 */
function lexer(str) {
    var tokens = [];
    var i = 0;
    while (i < str.length) {
        var char = str[i];
        if (char === "*" || char === "+" || char === "?") {
            tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
            continue;
        }
        if (char === "\\") {
            tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
            continue;
        }
        if (char === "{") {
            tokens.push({ type: "OPEN", index: i, value: str[i++] });
            continue;
        }
        if (char === "}") {
            tokens.push({ type: "CLOSE", index: i, value: str[i++] });
            continue;
        }
        if (char === ":") {
            var name = "";
            var j = i + 1;
            while (j < str.length) {
                var code = str.charCodeAt(j);
                if (
                // `0-9`
                (code >= 48 && code <= 57) ||
                    // `A-Z`
                    (code >= 65 && code <= 90) ||
                    // `a-z`
                    (code >= 97 && code <= 122) ||
                    // `_`
                    code === 95) {
                    name += str[j++];
                    continue;
                }
                break;
            }
            if (!name)
                throw new TypeError("Missing parameter name at " + i);
            tokens.push({ type: "NAME", index: i, value: name });
            i = j;
            continue;
        }
        if (char === "(") {
            var count = 1;
            var pattern = "";
            var j = i + 1;
            if (str[j] === "?") {
                throw new TypeError("Pattern cannot start with \"?\" at " + j);
            }
            while (j < str.length) {
                if (str[j] === "\\") {
                    pattern += str[j++] + str[j++];
                    continue;
                }
                if (str[j] === ")") {
                    count--;
                    if (count === 0) {
                        j++;
                        break;
                    }
                }
                else if (str[j] === "(") {
                    count++;
                    if (str[j + 1] !== "?") {
                        throw new TypeError("Capturing groups are not allowed at " + j);
                    }
                }
                pattern += str[j++];
            }
            if (count)
                throw new TypeError("Unbalanced pattern at " + i);
            if (!pattern)
                throw new TypeError("Missing pattern at " + i);
            tokens.push({ type: "PATTERN", index: i, value: pattern });
            i = j;
            continue;
        }
        tokens.push({ type: "CHAR", index: i, value: str[i++] });
    }
    tokens.push({ type: "END", index: i, value: "" });
    return tokens;
}
/**
 * Parse a string for the raw tokens.
 */
function parse(str, options) {
    if (options === void 0) { options = {}; }
    var tokens = lexer(str);
    var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
    var defaultPattern = "[^" + escapeString(options.delimiter || "/#?") + "]+?";
    var result = [];
    var key = 0;
    var i = 0;
    var path = "";
    var tryConsume = function (type) {
        if (i < tokens.length && tokens[i].type === type)
            return tokens[i++].value;
    };
    var mustConsume = function (type) {
        var value = tryConsume(type);
        if (value !== undefined)
            return value;
        var _a = tokens[i], nextType = _a.type, index = _a.index;
        throw new TypeError("Unexpected " + nextType + " at " + index + ", expected " + type);
    };
    var consumeText = function () {
        var result = "";
        var value;
        // tslint:disable-next-line
        while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {
            result += value;
        }
        return result;
    };
    while (i < tokens.length) {
        var char = tryConsume("CHAR");
        var name = tryConsume("NAME");
        var pattern = tryConsume("PATTERN");
        if (name || pattern) {
            var prefix = char || "";
            if (prefixes.indexOf(prefix) === -1) {
                path += prefix;
                prefix = "";
            }
            if (path) {
                result.push(path);
                path = "";
            }
            result.push({
                name: name || key++,
                prefix: prefix,
                suffix: "",
                pattern: pattern || defaultPattern,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        var value = char || tryConsume("ESCAPED_CHAR");
        if (value) {
            path += value;
            continue;
        }
        if (path) {
            result.push(path);
            path = "";
        }
        var open = tryConsume("OPEN");
        if (open) {
            var prefix = consumeText();
            var name_1 = tryConsume("NAME") || "";
            var pattern_1 = tryConsume("PATTERN") || "";
            var suffix = consumeText();
            mustConsume("CLOSE");
            result.push({
                name: name_1 || (pattern_1 ? key++ : ""),
                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
                prefix: prefix,
                suffix: suffix,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        mustConsume("END");
    }
    return result;
}
exports.parse = parse;
/**
 * Compile a string to a template function for the path.
 */
function compile(str, options) {
    return tokensToFunction(parse(str, options), options);
}
exports.compile = compile;
/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens, options) {
    if (options === void 0) { options = {}; }
    var reFlags = flags(options);
    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
    // Compile all the tokens into regexps.
    var matches = tokens.map(function (token) {
        if (typeof token === "object") {
            return new RegExp("^(?:" + token.pattern + ")$", reFlags);
        }
    });
    return function (data) {
        var path = "";
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if (typeof token === "string") {
                path += token;
                continue;
            }
            var value = data ? data[token.name] : undefined;
            var optional = token.modifier === "?" || token.modifier === "*";
            var repeat = token.modifier === "*" || token.modifier === "+";
            if (Array.isArray(value)) {
                if (!repeat) {
                    throw new TypeError("Expected \"" + token.name + "\" to not repeat, but got an array");
                }
                if (value.length === 0) {
                    if (optional)
                        continue;
                    throw new TypeError("Expected \"" + token.name + "\" to not be empty");
                }
                for (var j = 0; j < value.length; j++) {
                    var segment = encode(value[j], token);
                    if (validate && !matches[i].test(segment)) {
                        throw new TypeError("Expected all \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                    }
                    path += token.prefix + segment + token.suffix;
                }
                continue;
            }
            if (typeof value === "string" || typeof value === "number") {
                var segment = encode(String(value), token);
                if (validate && !matches[i].test(segment)) {
                    throw new TypeError("Expected \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                }
                path += token.prefix + segment + token.suffix;
                continue;
            }
            if (optional)
                continue;
            var typeOfMessage = repeat ? "an array" : "a string";
            throw new TypeError("Expected \"" + token.name + "\" to be " + typeOfMessage);
        }
        return path;
    };
}
exports.tokensToFunction = tokensToFunction;
/**
 * Create path match function from `path-to-regexp` spec.
 */
function match(str, options) {
    var keys = [];
    var re = pathToRegexp(str, keys, options);
    return regexpToFunction(re, keys, options);
}
exports.match = match;
/**
 * Create a path match function from `path-to-regexp` output.
 */
function regexpToFunction(re, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;
    return function (pathname) {
        var m = re.exec(pathname);
        if (!m)
            return false;
        var path = m[0], index = m.index;
        var params = Object.create(null);
        var _loop_1 = function (i) {
            // tslint:disable-next-line
            if (m[i] === undefined)
                return "continue";
            var key = keys[i - 1];
            if (key.modifier === "*" || key.modifier === "+") {
                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {
                    return decode(value, key);
                });
            }
            else {
                params[key.name] = decode(m[i], key);
            }
        };
        for (var i = 1; i < m.length; i++) {
            _loop_1(i);
        }
        return { path: path, index: index, params: params };
    };
}
exports.regexpToFunction = regexpToFunction;
/**
 * Escape a regular expression string.
 */
function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
/**
 * Get the flags for a regexp from the options.
 */
function flags(options) {
    return options && options.sensitive ? "" : "i";
}
/**
 * Pull out keys from a regexp.
 */
function regexpToRegexp(path, keys) {
    if (!keys)
        return path;
    // Use a negative lookahead to match only capturing groups.
    var groups = path.source.match(/\((?!\?)/g);
    if (groups) {
        for (var i = 0; i < groups.length; i++) {
            keys.push({
                name: i,
                prefix: "",
                suffix: "",
                modifier: "",
                pattern: ""
            });
        }
    }
    return path;
}
/**
 * Transform an array into a regexp.
 */
function arrayToRegexp(paths, keys, options) {
    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });
    return new RegExp("(?:" + parts.join("|") + ")", flags(options));
}
/**
 * Create a path regexp from string input.
 */
function stringToRegexp(path, keys, options) {
    return tokensToRegexp(parse(path, options), keys, options);
}
/**
 * Expose a function for taking tokens and returning a RegExp.
 */
function tokensToRegexp(tokens, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;
    var endsWith = "[" + escapeString(options.endsWith || "") + "]|$";
    var delimiter = "[" + escapeString(options.delimiter || "/#?") + "]";
    var route = start ? "^" : "";
    // Iterate over the tokens and create our regexp string.
    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
        var token = tokens_1[_i];
        if (typeof token === "string") {
            route += escapeString(encode(token));
        }
        else {
            var prefix = escapeString(encode(token.prefix));
            var suffix = escapeString(encode(token.suffix));
            if (token.pattern) {
                if (keys)
                    keys.push(token);
                if (prefix || suffix) {
                    if (token.modifier === "+" || token.modifier === "*") {
                        var mod = token.modifier === "*" ? "?" : "";
                        route += "(?:" + prefix + "((?:" + token.pattern + ")(?:" + suffix + prefix + "(?:" + token.pattern + "))*)" + suffix + ")" + mod;
                    }
                    else {
                        route += "(?:" + prefix + "(" + token.pattern + ")" + suffix + ")" + token.modifier;
                    }
                }
                else {
                    route += "(" + token.pattern + ")" + token.modifier;
                }
            }
            else {
                route += "(?:" + prefix + suffix + ")" + token.modifier;
            }
        }
    }
    if (end) {
        if (!strict)
            route += delimiter + "?";
        route += !options.endsWith ? "$" : "(?=" + endsWith + ")";
    }
    else {
        var endToken = tokens[tokens.length - 1];
        var isEndDelimited = typeof endToken === "string"
            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1
            : // tslint:disable-next-line
                endToken === undefined;
        if (!strict) {
            route += "(?:" + delimiter + "(?=" + endsWith + "))?";
        }
        if (!isEndDelimited) {
            route += "(?=" + delimiter + "|" + endsWith + ")";
        }
    }
    return new RegExp(route, flags(options));
}
exports.tokensToRegexp = tokensToRegexp;
/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 */
function pathToRegexp(path, keys, options) {
    if (path instanceof RegExp)
        return regexpToRegexp(path, keys);
    if (Array.isArray(path))
        return arrayToRegexp(path, keys, options);
    return stringToRegexp(path, keys, options);
}
exports.pathToRegexp = pathToRegexp;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js":
/*!**************************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js ***!
  \**************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.normalizeLocalePath = normalizeLocalePath;

function normalizeLocalePath(pathname, locales) {
  var detectedLocale; // first item will be empty string from splitting at first char

  var pathnameParts = pathname.split('/');
  (locales || []).some(function (locale) {
    if (pathnameParts[1].toLowerCase() === locale.toLowerCase()) {
      detectedLocale = locale;
      pathnameParts.splice(1, 1);
      pathname = pathnameParts.join('/') || '/';
      return true;
    }

    return false;
  });
  return {
    pathname: pathname,
    detectedLocale: detectedLocale
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../../../webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js */ "./.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/mitt.js":
/*!****************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/mitt.js ***!
  \****************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = mitt;
/*
MIT License
Copyright (c) Jason Miller (https://jasonformat.com/)
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
// This file is based on https://github.com/developit/mitt/blob/v1.1.3/src/index.js
// It's been edited for the needs of this script
// See the LICENSE at the top of the file

function mitt() {
  var all = Object.create(null);
  return {
    on: function on(type, handler) {
      ;
      (all[type] || (all[type] = [])).push(handler);
    },
    off: function off(type, handler) {
      if (all[type]) {
        all[type].splice(all[type].indexOf(handler) >>> 0, 1);
      }
    },
    emit: function emit(type) {
      for (var _len = arguments.length, evts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        evts[_key - 1] = arguments[_key];
      }

      // eslint-disable-next-line array-callback-return
      ;
      (all[type] || []).slice().map(function (handler) {
        handler.apply(void 0, evts);
      });
    }
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../../webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js */ "./.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router-context.js":
/*!**************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router-context.js ***!
  \**************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.RouterContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.1-98658812fc-83b9df9529.zip/node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var RouterContext = /*#__PURE__*/_react["default"].createContext(null);

exports.RouterContext = RouterContext;

if (true) {
  RouterContext.displayName = 'RouterContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../../webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js */ "./.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/router.js":
/*!*************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/router.js ***!
  \*************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/slicedToArray */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/slicedToArray.js");

var _regeneratorRuntime = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/regenerator */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/asyncToGenerator */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _classCallCheck = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/classCallCheck */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/createClass */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/createClass.js");

exports.__esModule = true;
exports.addLocale = addLocale;
exports.delLocale = delLocale;
exports.hasBasePath = hasBasePath;
exports.addBasePath = addBasePath;
exports.delBasePath = delBasePath;
exports.isLocalURL = isLocalURL;
exports.interpolateAs = interpolateAs;
exports.resolveHref = resolveHref;
exports["default"] = void 0;

var _normalizeTrailingSlash = __webpack_require__(/*! ../../../client/normalize-trailing-slash */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/client/normalize-trailing-slash.js");

var _routeLoader = __webpack_require__(/*! ../../../client/route-loader */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/client/route-loader.js");

var _denormalizePagePath = __webpack_require__(/*! ../../server/denormalize-page-path */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/server/denormalize-page-path.js");

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../mitt */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/mitt.js"));

var _utils = __webpack_require__(/*! ../utils */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/utils.js");

var _escapePathDelimiters = _interopRequireDefault(__webpack_require__(/*! ./utils/escape-path-delimiters */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/escape-path-delimiters.js"));

var _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js");

var _querystring = __webpack_require__(/*! ./utils/querystring */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/querystring.js");

var _resolveRewrites = _interopRequireDefault(__webpack_require__(/*! ./utils/resolve-rewrites */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js"));

var _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/route-matcher.js");

var _routeRegex = __webpack_require__(/*! ./utils/route-regex */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/route-regex.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/* global __NEXT_DATA__ */
// tslint:disable:no-console


var basePath =  false || '';

function buildCancellationError() {
  return Object.assign(new Error('Route Cancelled'), {
    cancelled: true
  });
}

function addPathPrefix(path, prefix) {
  return prefix && path.startsWith('/') ? path === '/' ? (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(prefix) : "".concat(prefix).concat(path) : path;
}

function addLocale(path, locale, defaultLocale) {
  if (false) {}

  return path;
}

function delLocale(path, locale) {
  if (false) {}

  return path;
}

function hasBasePath(path) {
  return path === basePath || path.startsWith(basePath + '/');
}

function addBasePath(path) {
  // we only add the basepath on relative urls
  return addPathPrefix(path, basePath);
}

function delBasePath(path) {
  return path.slice(basePath.length) || '/';
}
/**
* Detects whether a given url is routable by the Next.js router (browser only).
*/


function isLocalURL(url) {
  if (url.startsWith('/')) return true;

  try {
    // absolute urls can be local if they are on the same origin
    var locationOrigin = (0, _utils.getLocationOrigin)();
    var resolved = new URL(url, locationOrigin);
    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);
  } catch (_) {
    return false;
  }
}

function interpolateAs(route, asPathname, query) {
  var interpolatedRoute = '';
  var dynamicRegex = (0, _routeRegex.getRouteRegex)(route);
  var dynamicGroups = dynamicRegex.groups;
  var dynamicMatches = // Try to match the dynamic route against the asPath
  (asPathname !== route ? (0, _routeMatcher.getRouteMatcher)(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href
  // TODO: should this take priority; also need to change in the router.
  query;
  interpolatedRoute = route;
  var params = Object.keys(dynamicGroups);

  if (!params.every(function (param) {
    var value = dynamicMatches[param] || '';
    var _dynamicGroups$param = dynamicGroups[param],
        repeat = _dynamicGroups$param.repeat,
        optional = _dynamicGroups$param.optional; // support single-level catch-all
    // TODO: more robust handling for user-error (passing `/`)

    var replaced = "[".concat(repeat ? '...' : '').concat(param, "]");

    if (optional) {
      replaced = "".concat(!value ? '/' : '', "[").concat(replaced, "]");
    }

    if (repeat && !Array.isArray(value)) value = [value];
    return (optional || param in dynamicMatches) && ( // Interpolate group into data URL if present
    interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(_escapePathDelimiters["default"]).join('/') : (0, _escapePathDelimiters["default"])(value)) || '/');
  })) {
    interpolatedRoute = ''; // did not satisfy all requirements
    // n.b. We ignore this error because we handle warning for this case in
    // development in the `<Link>` component directly.
  }

  return {
    params: params,
    result: interpolatedRoute
  };
}

function omitParmsFromQuery(query, params) {
  var filteredQuery = {};
  Object.keys(query).forEach(function (key) {
    if (!params.includes(key)) {
      filteredQuery[key] = query[key];
    }
  });
  return filteredQuery;
}
/**
* Resolves a given hyperlink with a certain router state (basePath not included).
* Preserves absolute urls.
*/


function resolveHref(currentPath, href, resolveAs) {
  // we use a dummy base url for relative urls
  var base = new URL(currentPath, 'http://n');
  var urlAsString = typeof href === 'string' ? href : (0, _utils.formatWithValidation)(href); // Return because it cannot be routed by the Next.js router

  if (!isLocalURL(urlAsString)) {
    return resolveAs ? [urlAsString] : urlAsString;
  }

  try {
    var finalUrl = new URL(urlAsString, base);
    finalUrl.pathname = (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(finalUrl.pathname);
    var interpolatedAs = '';

    if ((0, _isDynamic.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {
      var query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);

      var _interpolateAs = interpolateAs(finalUrl.pathname, finalUrl.pathname, query),
          result = _interpolateAs.result,
          params = _interpolateAs.params;

      if (result) {
        interpolatedAs = (0, _utils.formatWithValidation)({
          pathname: result,
          hash: finalUrl.hash,
          query: omitParmsFromQuery(query, params)
        });
      }
    } // if the origin didn't change, it means we received a relative href


    var resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;
    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;
  } catch (_) {
    return resolveAs ? [urlAsString] : urlAsString;
  }
}

function prepareUrlAs(router, url, as) {
  // If url and as provided as an object representation,
  // we'll format them into the string version here.
  return {
    url: addBasePath(resolveHref(router.pathname, url)),
    as: as ? addBasePath(resolveHref(router.pathname, as)) : as
  };
}

var manualScrollRestoration =  false && false;
var SSG_DATA_NOT_FOUND_ERROR = 'SSG Data NOT_FOUND';

function fetchRetry(url, attempts) {
  return fetch(url, {
    // Cookies are required to be present for Next.js' SSG "Preview Mode".
    // Cookies may also be required for `getServerSideProps`.
    //
    // > `fetch` won’t send cookies, unless you set the credentials init
    // > option.
    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
    //
    // > For maximum browser compatibility when it comes to sending &
    // > receiving cookies, always supply the `credentials: 'same-origin'`
    // > option instead of relying on the default.
    // https://github.com/github/fetch#caveats
    credentials: 'same-origin'
  }).then(function (res) {
    if (!res.ok) {
      if (attempts > 1 && res.status >= 500) {
        return fetchRetry(url, attempts - 1);
      }

      if (res.status === 404) {
        // TODO: handle reloading in development from fallback returning 200
        // to on-demand-entry-handler causing it to reload periodically
        throw new Error(SSG_DATA_NOT_FOUND_ERROR);
      }

      throw new Error("Failed to load static props");
    }

    return res.json();
  });
}

function fetchNextData(dataHref, isServerRender) {
  return fetchRetry(dataHref, isServerRender ? 3 : 1)["catch"](function (err) {
    // We should only trigger a server-side transition if this was caused
    // on a client-side transition. Otherwise, we'd get into an infinite
    // loop.
    if (!isServerRender) {
      (0, _routeLoader.markAssetError)(err);
    }

    throw err;
  });
}

var Router = /*#__PURE__*/function () {
  /**
  * Map of all components loaded in `Router`
  */
  // Static Data Cache
  function Router(_pathname, _query, _as, _ref) {
    var _this = this;

    var initialProps = _ref.initialProps,
        pageLoader = _ref.pageLoader,
        App = _ref.App,
        wrapApp = _ref.wrapApp,
        Component = _ref.Component,
        err = _ref.err,
        subscription = _ref.subscription,
        isFallback = _ref.isFallback,
        locale = _ref.locale,
        locales = _ref.locales,
        defaultLocale = _ref.defaultLocale;

    _classCallCheck(this, Router);

    this.route = void 0;
    this.pathname = void 0;
    this.query = void 0;
    this.asPath = void 0;
    this.basePath = void 0;
    this.components = void 0;
    this.sdc = {};
    this.sub = void 0;
    this.clc = void 0;
    this.pageLoader = void 0;
    this._bps = void 0;
    this.events = void 0;
    this._wrapApp = void 0;
    this.isSsr = void 0;
    this.isFallback = void 0;
    this._inFlightRoute = void 0;
    this._shallow = void 0;
    this.locale = void 0;
    this.locales = void 0;
    this.defaultLocale = void 0;

    this.onPopState = function (e) {
      var state = e.state;

      if (!state) {
        // We get state as undefined for two reasons.
        //  1. With older safari (< 8) and older chrome (< 34)
        //  2. When the URL changed with #
        //
        // In the both cases, we don't need to proceed and change the route.
        // (as it's already changed)
        // But we can simply replace the state with the new changes.
        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.
        // So, doing the following for (1) does no harm.
        var _pathname2 = _this.pathname,
            query = _this.query;

        _this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: addBasePath(_pathname2),
          query: query
        }), (0, _utils.getURL)());

        return;
      }

      if (!state.__N) {
        return;
      }

      var url = state.url,
          as = state.as,
          options = state.options;

      var _ref2 = (0, _parseRelativeUrl.parseRelativeUrl)(url),
          pathname = _ref2.pathname; // Make sure we don't re-render on initial load,
      // can be caused by navigating back from an external site


      if (_this.isSsr && as === _this.asPath && pathname === _this.pathname) {
        return;
      } // If the downstream application returns falsy, return.
      // They will then be responsible for handling the event.


      if (_this._bps && !_this._bps(state)) {
        return;
      }

      _this.change('replaceState', url, as, Object.assign({}, options, {
        shallow: options.shallow && _this._shallow,
        locale: options.locale || _this.defaultLocale
      }));
    }; // represents the current component key


    this.route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(_pathname); // set up the component cache (by route keys)

    this.components = {}; // We should not keep the cache, if there's an error
    // Otherwise, this cause issues when when going back and
    // come again to the errored page.

    if (_pathname !== '/_error') {
      this.components[this.route] = {
        Component: Component,
        initial: true,
        props: initialProps,
        err: err,
        __N_SSG: initialProps && initialProps.__N_SSG,
        __N_SSP: initialProps && initialProps.__N_SSP
      };
    }

    this.components['/_app'] = {
      Component: App,
      styleSheets: [
        /* /_app does not need its stylesheets managed */
      ]
    }; // Backwards compat for Router.router.events
    // TODO: Should be remove the following major version as it was never documented

    this.events = Router.events;
    this.pageLoader = pageLoader;
    this.pathname = _pathname;
    this.query = _query; // if auto prerendered and dynamic route wait to update asPath
    // until after mount to prevent hydration mismatch

    this.asPath = // @ts-ignore this is temporarily global (attached to window)
    (0, _isDynamic.isDynamicRoute)(_pathname) && __NEXT_DATA__.autoExport ? _pathname : _as;
    this.basePath = basePath;
    this.sub = subscription;
    this.clc = null;
    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating
    // back from external site

    this.isSsr = true;
    this.isFallback = isFallback;

    if (false) {}

    if (true) {
      // make sure "as" doesn't start with double slashes or else it can
      // throw an error as it's considered invalid
      if (_as.substr(0, 2) !== '//') {
        // in order for `e.state` to work on the `onpopstate` event
        // we have to register the initial route upon initialization
        this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: addBasePath(_pathname),
          query: _query
        }), (0, _utils.getURL)(), {
          locale: locale
        });
      }

      window.addEventListener('popstate', this.onPopState); // enable custom scroll restoration handling when available
      // otherwise fallback to browser's default handling

      if (false) { var debouncedScrollSave, scrollDebounceTimeout; }
    }
  }

  _createClass(Router, [{
    key: "reload",
    value: function reload() {
      window.location.reload();
    }
    /**
    * Go back in history
    */

  }, {
    key: "back",
    value: function back() {
      window.history.back();
    }
    /**
    * Performs a `pushState` with arguments
    * @param url of the route
    * @param as masks `url` for the browser
    * @param options object you can define `shallow` and other options
    */

  }, {
    key: "push",
    value: function push(url) {
      var as = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      ;

      var _prepareUrlAs = prepareUrlAs(this, url, as);

      url = _prepareUrlAs.url;
      as = _prepareUrlAs.as;
      return this.change('pushState', url, as, options);
    }
    /**
    * Performs a `replaceState` with arguments
    * @param url of the route
    * @param as masks `url` for the browser
    * @param options object you can define `shallow` and other options
    */

  }, {
    key: "replace",
    value: function replace(url) {
      var as = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      ;

      var _prepareUrlAs2 = prepareUrlAs(this, url, as);

      url = _prepareUrlAs2.url;
      as = _prepareUrlAs2.as;
      return this.change('replaceState', url, as, options);
    }
  }, {
    key: "change",
    value: function () {
      var _change = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(method, url, as, options) {
        var _this2 = this;

        var localeChange, _this$locales, _require, normalizeLocalePath, parsedAs, localePathResult, cleanedAs, parsed, _parsed, pathname, query, pages, rewrites, _yield, route, _options$shallow, shallow, resolvedAs, potentialHref, _parsedAs, asPathname, routeRegex, routeMatch, shouldInterpolate, interpolatedAs, missingParams, routeInfo, error, props, __N_SSG, __N_SSP, destination, parsedHref, _prepareUrlAs3, newUrl, newAs, appComp;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (isLocalURL(url)) {
                  _context.next = 3;
                  break;
                }

                window.location.href = url;
                return _context.abrupt("return", false);

              case 3:
                localeChange = options.locale !== this.locale;

                if (true) {
                  _context.next = 15;
                  break;
                }

                this.locale = options.locale === false ? this.defaultLocale : options.locale || this.locale;

                if (typeof options.locale === 'undefined') {
                  options.locale = this.locale;
                }

                _require = __webpack_require__(/*! ../i18n/normalize-locale-path */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js"), normalizeLocalePath = _require.normalizeLocalePath;
                parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(hasBasePath(as) ? delBasePath(as) : as);
                localePathResult = normalizeLocalePath(parsedAs.pathname, this.locales);

                if (localePathResult.detectedLocale) {
                  this.locale = localePathResult.detectedLocale;
                  url = addBasePath(localePathResult.pathname);
                } // if the locale isn't configured hard navigate to show 404 page


                if ((_this$locales = this.locales) == null ? void 0 : _this$locales.includes(this.locale)) {
                  _context.next = 15;
                  break;
                }

                parsedAs.pathname = addLocale(parsedAs.pathname, this.locale);
                window.location.href = (0, _utils.formatWithValidation)(parsedAs);
                return _context.abrupt("return", new Promise(function () {}));

              case 15:
                if (!options._h) {
                  this.isSsr = false;
                } // marking route changes as a navigation start entry


                if (_utils.ST) {
                  performance.mark('routeChange');
                }

                if (this._inFlightRoute) {
                  this.abortComponentLoad(this._inFlightRoute);
                }

                as = addBasePath(addLocale(hasBasePath(as) ? delBasePath(as) : as, options.locale, this.defaultLocale));
                cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, this.locale);
                this._inFlightRoute = as; // If the url change is only related to a hash change
                // We should not proceed. We should only change the state.
                // WARNING: `_h` is an internal option for handing Next.js client-side
                // hydration. Your app should _never_ use this property. It may change at
                // any time without notice.

                if (!(!options._h && this.onlyAHashChange(cleanedAs))) {
                  _context.next = 29;
                  break;
                }

                this.asPath = cleanedAs;
                Router.events.emit('hashChangeStart', as); // TODO: do we need the resolved href when only a hash change?

                this.changeState(method, url, as, options);
                this.scrollToHash(cleanedAs);
                this.notify(this.components[this.route]);
                Router.events.emit('hashChangeComplete', as);
                return _context.abrupt("return", true);

              case 29:
                parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);
                _parsed = parsed, pathname = _parsed.pathname, query = _parsed.query; // The build manifest needs to be loaded before auto-static dynamic pages
                // get their query parameters to allow ensuring they can be parsed properly
                // when rewritten to

                _context.prev = 31;
                _context.next = 34;
                return this.pageLoader.getPageList();

              case 34:
                pages = _context.sent;
                _context.next = 37;
                return (0, _routeLoader.getClientBuildManifest)();

              case 37:
                _yield = _context.sent;
                rewrites = _yield.__rewrites;
                _context.next = 45;
                break;

              case 41:
                _context.prev = 41;
                _context.t0 = _context["catch"](31);
                // If we fail to resolve the page list or client-build manifest, we must
                // do a server-side transition:
                window.location.href = as;
                return _context.abrupt("return", false);

              case 45:
                parsed = this._resolveHref(parsed, pages);

                if (parsed.pathname !== pathname) {
                  pathname = parsed.pathname;
                  url = (0, _utils.formatWithValidation)(parsed);
                } // url and as should always be prefixed with basePath by this
                // point by either next/link or router.push/replace so strip the
                // basePath from the pathname to match the pages dir 1-to-1


                pathname = pathname ? (0, _normalizeTrailingSlash.removePathTrailingSlash)(delBasePath(pathname)) : pathname; // If asked to change the current URL we should reload the current page
                // (not location.reload() but reload getInitialProps and other Next.js stuffs)
                // We also need to set the method = replaceState always
                // as this should not go into the history (That's how browsers work)
                // We should compare the new asPath to the current asPath, not the url

                if (!this.urlIsNew(cleanedAs) && !localeChange) {
                  method = 'replaceState';
                }

                route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);
                _options$shallow = options.shallow, shallow = _options$shallow === void 0 ? false : _options$shallow; // we need to resolve the as value using rewrites for dynamic SSG
                // pages to allow building the data URL correctly

                resolvedAs = as;

                if (true) {
                  resolvedAs = (0, _resolveRewrites["default"])((0, _parseRelativeUrl.parseRelativeUrl)(as).pathname, pages, basePath, rewrites, query, function (p) {
                    return _this2._resolveHref({
                      pathname: p
                    }, pages).pathname;
                  });

                  if (resolvedAs !== as) {
                    potentialHref = (0, _normalizeTrailingSlash.removePathTrailingSlash)(this._resolveHref(Object.assign({}, parsed, {
                      pathname: resolvedAs
                    }), pages, false).pathname); // if this directly matches a page we need to update the href to
                    // allow the correct page chunk to be loaded

                    if (pages.includes(potentialHref)) {
                      route = potentialHref;
                      pathname = potentialHref;
                      parsed.pathname = pathname;
                      url = (0, _utils.formatWithValidation)(parsed);
                    }
                  }
                }

                resolvedAs = delLocale(delBasePath(resolvedAs), this.locale);

                if (!(0, _isDynamic.isDynamicRoute)(route)) {
                  _context.next = 69;
                  break;
                }

                _parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(resolvedAs);
                asPathname = _parsedAs.pathname;
                routeRegex = (0, _routeRegex.getRouteRegex)(route);
                routeMatch = (0, _routeMatcher.getRouteMatcher)(routeRegex)(asPathname);
                shouldInterpolate = route === asPathname;
                interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};

                if (!(!routeMatch || shouldInterpolate && !interpolatedAs.result)) {
                  _context.next = 68;
                  break;
                }

                missingParams = Object.keys(routeRegex.groups).filter(function (param) {
                  return !query[param];
                });

                if (!(missingParams.length > 0)) {
                  _context.next = 66;
                  break;
                }

                if (true) {
                  console.warn("".concat(shouldInterpolate ? "Interpolating href" : "Mismatching `as` and `href`", " failed to manually provide ") + "the params: ".concat(missingParams.join(', '), " in the `href`'s `query`"));
                }

                throw new Error((shouldInterpolate ? "The provided `href` (".concat(url, ") value is missing query values (").concat(missingParams.join(', '), ") to be interpolated properly. ") : "The provided `as` value (".concat(asPathname, ") is incompatible with the `href` value (").concat(route, "). ")) + "Read more: https://err.sh/vercel/next.js/".concat(shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'));

              case 66:
                _context.next = 69;
                break;

              case 68:
                if (shouldInterpolate) {
                  as = (0, _utils.formatWithValidation)(Object.assign({}, _parsedAs, {
                    pathname: interpolatedAs.result,
                    query: omitParmsFromQuery(query, interpolatedAs.params)
                  }));
                } else {
                  // Merge params into `query`, overwriting any specified in search
                  Object.assign(query, routeMatch);
                }

              case 69:
                Router.events.emit('routeChangeStart', as);
                _context.prev = 70;
                _context.next = 73;
                return this.getRouteInfo(route, pathname, query, as, shallow);

              case 73:
                routeInfo = _context.sent;
                error = routeInfo.error, props = routeInfo.props, __N_SSG = routeInfo.__N_SSG, __N_SSP = routeInfo.__N_SSP; // handle redirect on client-transition

                if (!((__N_SSG || __N_SSP) && props && props.pageProps && props.pageProps.__N_REDIRECT)) {
                  _context.next = 85;
                  break;
                }

                destination = props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt
                // client-navigation if it is falling back to hard navigation if
                // it's not

                if (!destination.startsWith('/')) {
                  _context.next = 83;
                  break;
                }

                parsedHref = (0, _parseRelativeUrl.parseRelativeUrl)(destination);

                this._resolveHref(parsedHref, pages, false);

                if (!pages.includes(parsedHref.pathname)) {
                  _context.next = 83;
                  break;
                }

                _prepareUrlAs3 = prepareUrlAs(this, destination, destination), newUrl = _prepareUrlAs3.url, newAs = _prepareUrlAs3.as;
                return _context.abrupt("return", this.change(method, newUrl, newAs, options));

              case 83:
                window.location.href = destination;
                return _context.abrupt("return", new Promise(function () {}));

              case 85:
                Router.events.emit('beforeHistoryChange', as);
                this.changeState(method, url, as, options);

                if (true) {
                  appComp = this.components['/_app'].Component;
                  window.next.isPrerendered = appComp.getInitialProps === appComp.origGetInitialProps && !routeInfo.Component.getInitialProps;
                }

                _context.next = 90;
                return this.set(route, pathname, query, cleanedAs, routeInfo)["catch"](function (e) {
                  if (e.cancelled) error = error || e;else throw e;
                });

              case 90:
                if (!error) {
                  _context.next = 93;
                  break;
                }

                Router.events.emit('routeChangeError', error, cleanedAs);
                throw error;

              case 93:
                if (false) {}

                if (false) {}

                Router.events.emit('routeChangeComplete', as);
                return _context.abrupt("return", true);

              case 99:
                _context.prev = 99;
                _context.t1 = _context["catch"](70);

                if (!_context.t1.cancelled) {
                  _context.next = 103;
                  break;
                }

                return _context.abrupt("return", false);

              case 103:
                throw _context.t1;

              case 104:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[31, 41], [70, 99]]);
      }));

      function change(_x, _x2, _x3, _x4) {
        return _change.apply(this, arguments);
      }

      return change;
    }()
  }, {
    key: "changeState",
    value: function changeState(method, url, as) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (true) {
        if (typeof window.history === 'undefined') {
          console.error("Warning: window.history is not available.");
          return;
        }

        if (typeof window.history[method] === 'undefined') {
          console.error("Warning: window.history.".concat(method, " is not available"));
          return;
        }
      }

      if (method !== 'pushState' || (0, _utils.getURL)() !== as) {
        this._shallow = options.shallow;
        window.history[method]({
          url: url,
          as: as,
          options: options,
          __N: true
        }, // Most browsers currently ignores this parameter, although they may use it in the future.
        // Passing the empty string here should be safe against future changes to the method.
        // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState
        '', as);
      }
    }
  }, {
    key: "handleRouteInfoError",
    value: function () {
      var _handleRouteInfoError = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(err, pathname, query, as, loadErrorFail) {
        var Component, styleSheets, props, ssg404, mod, _yield$this$fetchComp, _yield$this$fetchComp2, routeInfo;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!err.cancelled) {
                  _context2.next = 2;
                  break;
                }

                throw err;

              case 2:
                if (!((0, _routeLoader.isAssetError)(err) || loadErrorFail)) {
                  _context2.next = 6;
                  break;
                }

                Router.events.emit('routeChangeError', err, as); // If we can't load the page it could be one of following reasons
                //  1. Page doesn't exists
                //  2. Page does exist in a different zone
                //  3. Internal error while loading the page
                // So, doing a hard reload is the proper way to deal with this.

                window.location.href = as; // Changing the URL doesn't block executing the current code path.
                // So let's throw a cancellation error stop the routing logic.

                throw buildCancellationError();

              case 6:
                _context2.prev = 6;
                ssg404 = err.message === SSG_DATA_NOT_FOUND_ERROR;

                if (!ssg404) {
                  _context2.next = 24;
                  break;
                }

                _context2.prev = 9;
                _context2.next = 12;
                return this.fetchComponent('/404');

              case 12:
                _yield$this$fetchComp = _context2.sent;
                Component = _yield$this$fetchComp.page;
                styleSheets = _yield$this$fetchComp.styleSheets;
                mod = _yield$this$fetchComp.mod;

                if (!(mod && mod.__N_SSG)) {
                  _context2.next = 20;
                  break;
                }

                _context2.next = 19;
                return this._getStaticData(this.pageLoader.getDataHref('/404', '/404', true, this.locale));

              case 19:
                props = _context2.sent;

              case 20:
                _context2.next = 24;
                break;

              case 22:
                _context2.prev = 22;
                _context2.t0 = _context2["catch"](9);

              case 24:
                if (!(typeof Component === 'undefined' || typeof styleSheets === 'undefined')) {
                  _context2.next = 31;
                  break;
                }

                ;
                _context2.next = 28;
                return this.fetchComponent('/_error');

              case 28:
                _yield$this$fetchComp2 = _context2.sent;
                Component = _yield$this$fetchComp2.page;
                styleSheets = _yield$this$fetchComp2.styleSheets;

              case 31:
                routeInfo = {
                  props: props,
                  Component: Component,
                  styleSheets: styleSheets,
                  err: ssg404 ? undefined : err,
                  error: ssg404 ? undefined : err
                };

                if (routeInfo.props) {
                  _context2.next = 43;
                  break;
                }

                _context2.prev = 33;
                _context2.next = 36;
                return this.getInitialProps(Component, {
                  err: err,
                  pathname: pathname,
                  query: query
                });

              case 36:
                routeInfo.props = _context2.sent;
                _context2.next = 43;
                break;

              case 39:
                _context2.prev = 39;
                _context2.t1 = _context2["catch"](33);
                console.error('Error in error page `getInitialProps`: ', _context2.t1);
                routeInfo.props = {};

              case 43:
                return _context2.abrupt("return", routeInfo);

              case 46:
                _context2.prev = 46;
                _context2.t2 = _context2["catch"](6);
                return _context2.abrupt("return", this.handleRouteInfoError(_context2.t2, pathname, query, as, true));

              case 49:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[6, 46], [9, 22], [33, 39]]);
      }));

      function handleRouteInfoError(_x5, _x6, _x7, _x8, _x9) {
        return _handleRouteInfoError.apply(this, arguments);
      }

      return handleRouteInfoError;
    }()
  }, {
    key: "getRouteInfo",
    value: function () {
      var _getRouteInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(route, pathname, query, as) {
        var _this3 = this;

        var shallow,
            existingRouteInfo,
            cachedRouteInfo,
            routeInfo,
            Component,
            __N_SSG,
            __N_SSP,
            _require2,
            isValidElementType,
            dataHref,
            props,
            _args3 = arguments;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                shallow = _args3.length > 4 && _args3[4] !== undefined ? _args3[4] : false;
                _context3.prev = 1;
                existingRouteInfo = this.components[route];

                if (!(shallow && existingRouteInfo && this.route === route)) {
                  _context3.next = 5;
                  break;
                }

                return _context3.abrupt("return", existingRouteInfo);

              case 5:
                cachedRouteInfo = existingRouteInfo && 'initial' in existingRouteInfo ? undefined : existingRouteInfo;

                if (!cachedRouteInfo) {
                  _context3.next = 10;
                  break;
                }

                _context3.t0 = cachedRouteInfo;
                _context3.next = 13;
                break;

              case 10:
                _context3.next = 12;
                return this.fetchComponent(route).then(function (res) {
                  return {
                    Component: res.page,
                    styleSheets: res.styleSheets,
                    __N_SSG: res.mod.__N_SSG,
                    __N_SSP: res.mod.__N_SSP
                  };
                });

              case 12:
                _context3.t0 = _context3.sent;

              case 13:
                routeInfo = _context3.t0;
                Component = routeInfo.Component, __N_SSG = routeInfo.__N_SSG, __N_SSP = routeInfo.__N_SSP;

                if (false) {}

                _require2 = __webpack_require__(/*! react-is */ "./.yarn/cache/react-is-npm-16.13.1-a9b9382b4f-f7a19ac349.zip/node_modules/react-is/index.js"), isValidElementType = _require2.isValidElementType;

                if (isValidElementType(Component)) {
                  _context3.next = 19;
                  break;
                }

                throw new Error("The default export is not a React Component in page: \"".concat(pathname, "\""));

              case 19:
                if (__N_SSG || __N_SSP) {
                  dataHref = this.pageLoader.getDataHref((0, _utils.formatWithValidation)({
                    pathname: pathname,
                    query: query
                  }), delBasePath(as), __N_SSG, this.locale);
                }

                _context3.next = 22;
                return this._getData(function () {
                  return __N_SSG ? _this3._getStaticData(dataHref) : __N_SSP ? _this3._getServerData(dataHref) : _this3.getInitialProps(Component, // we provide AppTree later so this needs to be `any`
                  {
                    pathname: pathname,
                    query: query,
                    asPath: as
                  });
                });

              case 22:
                props = _context3.sent;
                routeInfo.props = props;
                this.components[route] = routeInfo;
                return _context3.abrupt("return", routeInfo);

              case 28:
                _context3.prev = 28;
                _context3.t1 = _context3["catch"](1);
                return _context3.abrupt("return", this.handleRouteInfoError(_context3.t1, pathname, query, as));

              case 31:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[1, 28]]);
      }));

      function getRouteInfo(_x10, _x11, _x12, _x13) {
        return _getRouteInfo.apply(this, arguments);
      }

      return getRouteInfo;
    }()
  }, {
    key: "set",
    value: function set(route, pathname, query, as, data) {
      this.isFallback = false;
      this.route = route;
      this.pathname = pathname;
      this.query = query;
      this.asPath = as;
      return this.notify(data);
    }
    /**
    * Callback to execute before replacing router state
    * @param cb callback to be executed
    */

  }, {
    key: "beforePopState",
    value: function beforePopState(cb) {
      this._bps = cb;
    }
  }, {
    key: "onlyAHashChange",
    value: function onlyAHashChange(as) {
      if (!this.asPath) return false;

      var _this$asPath$split = this.asPath.split('#'),
          _this$asPath$split2 = _slicedToArray(_this$asPath$split, 2),
          oldUrlNoHash = _this$asPath$split2[0],
          oldHash = _this$asPath$split2[1];

      var _as$split = as.split('#'),
          _as$split2 = _slicedToArray(_as$split, 2),
          newUrlNoHash = _as$split2[0],
          newHash = _as$split2[1]; // Makes sure we scroll to the provided hash if the url/hash are the same


      if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {
        return true;
      } // If the urls are change, there's more than a hash change


      if (oldUrlNoHash !== newUrlNoHash) {
        return false;
      } // If the hash has changed, then it's a hash only change.
      // This check is necessary to handle both the enter and
      // leave hash === '' cases. The identity case falls through
      // and is treated as a next reload.


      return oldHash !== newHash;
    }
  }, {
    key: "scrollToHash",
    value: function scrollToHash(as) {
      var _as$split3 = as.split('#'),
          _as$split4 = _slicedToArray(_as$split3, 2),
          hash = _as$split4[1]; // Scroll to top if the hash is just `#` with no value


      if (hash === '') {
        window.scrollTo(0, 0);
        return;
      } // First we check if the element by id is found


      var idEl = document.getElementById(hash);

      if (idEl) {
        idEl.scrollIntoView();
        return;
      } // If there's no element with the id, we check the `name` property
      // To mirror browsers


      var nameEl = document.getElementsByName(hash)[0];

      if (nameEl) {
        nameEl.scrollIntoView();
      }
    }
  }, {
    key: "urlIsNew",
    value: function urlIsNew(asPath) {
      return this.asPath !== asPath;
    }
  }, {
    key: "_resolveHref",
    value: function _resolveHref(parsedHref, pages) {
      var applyBasePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var pathname = parsedHref.pathname;
      var cleanPathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)((0, _denormalizePagePath.denormalizePagePath)(applyBasePath ? delBasePath(pathname) : pathname));

      if (cleanPathname === '/404' || cleanPathname === '/_error') {
        return parsedHref;
      } // handle resolving href for dynamic routes


      if (!pages.includes(cleanPathname)) {
        // eslint-disable-next-line array-callback-return
        pages.some(function (page) {
          if ((0, _isDynamic.isDynamicRoute)(page) && (0, _routeRegex.getRouteRegex)(page).re.test(cleanPathname)) {
            parsedHref.pathname = applyBasePath ? addBasePath(page) : page;
            return true;
          }
        });
      }

      return parsedHref;
    }
    /**
    * Prefetch page code, you may wait for the data during page rendering.
    * This feature only works in production!
    * @param url the href of prefetched page
    * @param asPath the as path of the prefetched page
    */

  }, {
    key: "prefetch",
    value: function () {
      var _prefetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(url) {
        var _this4 = this;

        var asPath,
            options,
            parsed,
            _parsed2,
            pathname,
            normalizeLocalePath,
            parsedAs,
            localePathResult,
            pages,
            route,
            _args4 = arguments;

        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                asPath = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : url;
                options = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
                parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);
                _parsed2 = parsed, pathname = _parsed2.pathname;

                if (false) {}

                _context4.next = 7;
                return this.pageLoader.getPageList();

              case 7:
                pages = _context4.sent;
                parsed = this._resolveHref(parsed, pages, false);

                if (parsed.pathname !== pathname) {
                  pathname = parsed.pathname;
                  url = (0, _utils.formatWithValidation)(parsed);
                } // Prefetch is not supported in development mode because it would trigger on-demand-entries


                if (false) {}

                return _context4.abrupt("return");

              case 12:
                route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);
                _context4.next = 15;
                return Promise.all([this.pageLoader._isSsg(url).then(function (isSsg) {
                  return isSsg ? _this4._getStaticData(_this4.pageLoader.getDataHref(url, asPath, true, typeof options.locale !== 'undefined' ? options.locale : _this4.locale)) : false;
                }), this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);

              case 15:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function prefetch(_x14) {
        return _prefetch.apply(this, arguments);
      }

      return prefetch;
    }()
  }, {
    key: "fetchComponent",
    value: function () {
      var _fetchComponent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(route) {
        var cancelled, cancel, componentResult, error;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                cancelled = false;

                cancel = this.clc = function () {
                  cancelled = true;
                };

                _context5.next = 4;
                return this.pageLoader.loadPage(route);

              case 4:
                componentResult = _context5.sent;

                if (!cancelled) {
                  _context5.next = 9;
                  break;
                }

                error = new Error("Abort fetching component for route: \"".concat(route, "\""));
                error.cancelled = true;
                throw error;

              case 9:
                if (cancel === this.clc) {
                  this.clc = null;
                }

                return _context5.abrupt("return", componentResult);

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function fetchComponent(_x15) {
        return _fetchComponent.apply(this, arguments);
      }

      return fetchComponent;
    }()
  }, {
    key: "_getData",
    value: function _getData(fn) {
      var _this5 = this;

      var cancelled = false;

      var cancel = function cancel() {
        cancelled = true;
      };

      this.clc = cancel;
      return fn().then(function (data) {
        if (cancel === _this5.clc) {
          _this5.clc = null;
        }

        if (cancelled) {
          var err = new Error('Loading initial props cancelled');
          err.cancelled = true;
          throw err;
        }

        return data;
      });
    }
  }, {
    key: "_getStaticData",
    value: function _getStaticData(dataHref) {
      var _this6 = this;

      var _URL = new URL(dataHref, window.location.href),
          cacheKey = _URL.href;

      if (false) {}

      return fetchNextData(dataHref, this.isSsr).then(function (data) {
        _this6.sdc[cacheKey] = data;
        return data;
      });
    }
  }, {
    key: "_getServerData",
    value: function _getServerData(dataHref) {
      return fetchNextData(dataHref, this.isSsr);
    }
  }, {
    key: "getInitialProps",
    value: function getInitialProps(Component, ctx) {
      var App = this.components['/_app'].Component;

      var AppTree = this._wrapApp(App);

      ctx.AppTree = AppTree;
      return (0, _utils.loadGetInitialProps)(App, {
        AppTree: AppTree,
        Component: Component,
        router: this,
        ctx: ctx
      });
    }
  }, {
    key: "abortComponentLoad",
    value: function abortComponentLoad(as) {
      if (this.clc) {
        Router.events.emit('routeChangeError', buildCancellationError(), as);
        this.clc();
        this.clc = null;
      }
    }
  }, {
    key: "notify",
    value: function notify(data) {
      return this.sub(data, this.components['/_app'].Component);
    }
  }]);

  return Router;
}();

exports["default"] = Router;
Router.events = (0, _mitt["default"])();

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../../../webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js */ "./.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/escape-path-delimiters.js":
/*!***********************************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/escape-path-delimiters.js ***!
  \***********************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = escapePathDelimiters; // escape delimiters used by path-to-regexp

function escapePathDelimiters(segment) {
  return segment.replace(/[/#?]/g, function (_char) {
    return encodeURIComponent(_char);
  });
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../../../../webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js */ "./.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/format-url.js":
/*!***********************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/format-url.js ***!
  \***********************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.formatUrl = formatUrl;

var querystring = _interopRequireWildcard(__webpack_require__(/*! ./querystring */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/querystring.js"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
} // Format function modified from nodejs
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var slashedProtocols = /https?|ftp|gopher|file/;

function formatUrl(urlObj) {
  var auth = urlObj.auth,
      hostname = urlObj.hostname;
  var protocol = urlObj.protocol || '';
  var pathname = urlObj.pathname || '';
  var hash = urlObj.hash || '';
  var query = urlObj.query || '';
  var host = false;
  auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';

  if (urlObj.host) {
    host = auth + urlObj.host;
  } else if (hostname) {
    host = auth + (~hostname.indexOf(':') ? "[".concat(hostname, "]") : hostname);

    if (urlObj.port) {
      host += ':' + urlObj.port;
    }
  }

  if (query && typeof query === 'object') {
    query = String(querystring.urlQueryToSearchParams(query));
  }

  var search = urlObj.search || query && "?".concat(query) || '';
  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname[0] !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash[0] !== '#') hash = '#' + hash;
  if (search && search[0] !== '?') search = '?' + search;
  pathname = pathname.replace(/[?#]/g, encodeURIComponent);
  search = search.replace('#', '%23');
  return "".concat(protocol).concat(host).concat(pathname).concat(search).concat(hash);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../../../../webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js */ "./.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js":
/*!**************************************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js ***!
  \**************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = getAssetPathFromRoute; // Translates a logical route into its pages asset path (relative from a common prefix)
// "asset path" being its javascript file, data file, prerendered html,...

function getAssetPathFromRoute(route) {
  var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var path = route === '/' ? '/index' : /^\/index(\/|$)/.test(route) ? "/index".concat(route) : "".concat(route);
  return path + ext;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../../../../webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js */ "./.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js":
/*!***********************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js ***!
  \***********************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.isDynamicRoute = isDynamicRoute; // Identify /[param]/ in route string

var TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/;

function isDynamicRoute(route) {
  return TEST_ROUTE.test(route);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../../../../webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js */ "./.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js":
/*!*******************************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js ***!
  \*******************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.parseRelativeUrl = parseRelativeUrl;

var _utils = __webpack_require__(/*! ../../utils */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/utils.js");

var _querystring = __webpack_require__(/*! ./querystring */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/querystring.js");
/**
* Parses path-relative urls (e.g. `/hello/world?foo=bar`). If url isn't path-relative
* (e.g. `./hello`) then at least base must be.
* Absolute urls are rejected with one exception, in the browser, absolute urls that are on
* the current origin will be parsed as relative
*/


function parseRelativeUrl(url, base) {
  var globalBase = new URL(false ? undefined : (0, _utils.getLocationOrigin)());
  var resolvedBase = base ? new URL(base, globalBase) : globalBase;

  var _URL = new URL(url, resolvedBase),
      pathname = _URL.pathname,
      searchParams = _URL.searchParams,
      search = _URL.search,
      hash = _URL.hash,
      href = _URL.href,
      origin = _URL.origin;

  if (origin !== globalBase.origin) {
    throw new Error('invariant: invalid relative URL');
  }

  return {
    pathname: pathname,
    query: (0, _querystring.searchParamsToUrlQuery)(searchParams),
    search: search,
    hash: hash,
    href: href.slice(globalBase.origin.length)
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../../../../webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js */ "./.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/path-match.js":
/*!***********************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/path-match.js ***!
  \***********************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _defineProperty = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/defineProperty */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/defineProperty.js");

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

exports.__esModule = true;
exports.pathToRegexp = exports["default"] = exports.customRouteMatcherOptions = exports.matcherOptions = void 0;

var pathToRegexp = _interopRequireWildcard(__webpack_require__(/*! next/dist/compiled/path-to-regexp */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/compiled/path-to-regexp/index.js"));

exports.pathToRegexp = pathToRegexp;

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var matcherOptions = {
  sensitive: false,
  delimiter: '/'
};
exports.matcherOptions = matcherOptions;

var customRouteMatcherOptions = _objectSpread(_objectSpread({}, matcherOptions), {}, {
  strict: true
});

exports.customRouteMatcherOptions = customRouteMatcherOptions;

var _default = function _default() {
  var customRoute = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  return function (path) {
    var keys = [];
    var matcherRegex = pathToRegexp.pathToRegexp(path, keys, customRoute ? customRouteMatcherOptions : matcherOptions);
    var matcher = pathToRegexp.regexpToFunction(matcherRegex, keys);
    return function (pathname, params) {
      var res = pathname == null ? false : matcher(pathname);

      if (!res) {
        return false;
      }

      if (customRoute) {
        var _iterator = _createForOfIteratorHelper(keys),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var key = _step.value;

            // unnamed params should be removed as they
            // are not allowed to be used in the destination
            if (typeof key.name === 'number') {
              delete res.params[key.name];
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return _objectSpread(_objectSpread({}, params), res.params);
    };
  };
};

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../../../../webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js */ "./.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js":
/*!********************************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js ***!
  \********************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _defineProperty = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/defineProperty */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/defineProperty.js");

var _slicedToArray = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/slicedToArray */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/slicedToArray.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

exports.__esModule = true;
exports.compileNonPath = compileNonPath;
exports["default"] = prepareDestination;

var _querystring = __webpack_require__(/*! ./querystring */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/querystring.js");

var _parseRelativeUrl = __webpack_require__(/*! ./parse-relative-url */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js");

var pathToRegexp = _interopRequireWildcard(__webpack_require__(/*! next/dist/compiled/path-to-regexp */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/compiled/path-to-regexp/index.js"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function compileNonPath(value, params) {
  if (!value.includes(':')) {
    return value;
  }

  for (var _i = 0, _Object$keys = Object.keys(params); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];

    if (value.includes(":".concat(key))) {
      value = value.replace(new RegExp(":".concat(key, "\\*"), 'g'), ":".concat(key, "--ESCAPED_PARAM_ASTERISKS")).replace(new RegExp(":".concat(key, "\\?"), 'g'), ":".concat(key, "--ESCAPED_PARAM_QUESTION")).replace(new RegExp(":".concat(key, "\\+"), 'g'), ":".concat(key, "--ESCAPED_PARAM_PLUS")).replace(new RegExp(":".concat(key, "(?!\\w)"), 'g'), "--ESCAPED_PARAM_COLON".concat(key));
    }
  }

  value = value.replace(/(:|\*|\?|\+|\(|\)|\{|\})/g, '\\$1').replace(/--ESCAPED_PARAM_PLUS/g, '+').replace(/--ESCAPED_PARAM_COLON/g, ':').replace(/--ESCAPED_PARAM_QUESTION/g, '?').replace(/--ESCAPED_PARAM_ASTERISKS/g, '*'); // the value needs to start with a forward-slash to be compiled
  // correctly

  return pathToRegexp.compile("/".concat(value), {
    validate: false
  })(params).substr(1);
}

function prepareDestination(destination, params, query, appendParamsToQuery, basePath) {
  var parsedDestination = {}; // clone query so we don't modify the original

  query = Object.assign({}, query);
  var hadLocale = query.__nextLocale;
  delete query.__nextLocale;
  delete query.__nextDefaultLocale;

  if (destination.startsWith('/')) {
    parsedDestination = (0, _parseRelativeUrl.parseRelativeUrl)(destination);
  } else {
    var _URL = new URL(destination),
        pathname = _URL.pathname,
        searchParams = _URL.searchParams,
        hash = _URL.hash,
        hostname = _URL.hostname,
        port = _URL.port,
        protocol = _URL.protocol,
        search = _URL.search,
        href = _URL.href;

    parsedDestination = {
      pathname: pathname,
      query: (0, _querystring.searchParamsToUrlQuery)(searchParams),
      hash: hash,
      protocol: protocol,
      hostname: hostname,
      port: port,
      search: search,
      href: href
    };
  }

  var destQuery = parsedDestination.query;
  var destPath = "".concat(parsedDestination.pathname).concat(parsedDestination.hash || '');
  var destPathParamKeys = [];
  pathToRegexp.pathToRegexp(destPath, destPathParamKeys);
  var destPathParams = destPathParamKeys.map(function (key) {
    return key.name;
  });
  var destinationCompiler = pathToRegexp.compile(destPath, // we don't validate while compiling the destination since we should
  // have already validated before we got to this point and validating
  // breaks compiling destinations with named pattern params from the source
  // e.g. /something:hello(.*) -> /another/:hello is broken with validation
  // since compile validation is meant for reversing and not for inserting
  // params from a separate path-regex into another
  {
    validate: false
  });
  var newUrl; // update any params in query values

  for (var _i2 = 0, _Object$entries = Object.entries(destQuery); _i2 < _Object$entries.length; _i2++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
        key = _Object$entries$_i[0],
        strOrArray = _Object$entries$_i[1];

    var value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray;

    if (value) {
      // the value needs to start with a forward-slash to be compiled
      // correctly
      value = compileNonPath(value, params);
    }

    destQuery[key] = value;
  } // add path params to query if it's not a redirect and not
  // already defined in destination query or path


  var paramKeys = Object.keys(params); // remove internal param for i18n

  if (hadLocale) {
    paramKeys = paramKeys.filter(function (name) {
      return name !== 'nextInternalLocale';
    });
  }

  if (appendParamsToQuery && !paramKeys.some(function (key) {
    return destPathParams.includes(key);
  })) {
    var _iterator = _createForOfIteratorHelper(paramKeys),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _key = _step.value;

        if (!(_key in destQuery)) {
          destQuery[_key] = params[_key];
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  var shouldAddBasePath = destination.startsWith('/') && basePath;

  try {
    newUrl = "".concat(shouldAddBasePath ? basePath : '').concat(destinationCompiler(params));

    var _newUrl$split = newUrl.split('#'),
        _newUrl$split2 = _slicedToArray(_newUrl$split, 2),
        _pathname = _newUrl$split2[0],
        _hash = _newUrl$split2[1];

    parsedDestination.pathname = _pathname;
    parsedDestination.hash = "".concat(_hash ? '#' : '').concat(_hash || '');
    delete parsedDestination.search;
  } catch (err) {
    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {
      throw new Error("To use a multi-match in the destination you must add `*` at the end of the param name to signify it should repeat. https://err.sh/vercel/next.js/invalid-multi-match");
    }

    throw err;
  } // Query merge order lowest priority to highest
  // 1. initial URL query values
  // 2. path segment values
  // 3. destination specified query values


  parsedDestination.query = _objectSpread(_objectSpread({}, query), parsedDestination.query);
  return {
    newUrl: newUrl,
    parsedDestination: parsedDestination
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../../../../webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js */ "./.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/querystring.js":
/*!************************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/querystring.js ***!
  \************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/slicedToArray */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/slicedToArray.js");

exports.__esModule = true;
exports.searchParamsToUrlQuery = searchParamsToUrlQuery;
exports.urlQueryToSearchParams = urlQueryToSearchParams;
exports.assign = assign;

function searchParamsToUrlQuery(searchParams) {
  var query = {};
  searchParams.forEach(function (value, key) {
    if (typeof query[key] === 'undefined') {
      query[key] = value;
    } else if (Array.isArray(query[key])) {
      ;
      query[key].push(value);
    } else {
      query[key] = [query[key], value];
    }
  });
  return query;
}

function stringifyUrlQueryParam(param) {
  if (typeof param === 'string' || typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {
    return String(param);
  } else {
    return '';
  }
}

function urlQueryToSearchParams(urlQuery) {
  var result = new URLSearchParams();
  Object.entries(urlQuery).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    if (Array.isArray(value)) {
      value.forEach(function (item) {
        return result.append(key, stringifyUrlQueryParam(item));
      });
    } else {
      result.set(key, stringifyUrlQueryParam(value));
    }
  });
  return result;
}

function assign(target) {
  for (var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    searchParamsList[_key - 1] = arguments[_key];
  }

  searchParamsList.forEach(function (searchParams) {
    Array.from(searchParams.keys()).forEach(function (key) {
      return target["delete"](key);
    });
    searchParams.forEach(function (value, key) {
      return target.append(key, value);
    });
  });
  return target;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../../../../webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js */ "./.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js":
/*!*****************************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js ***!
  \*****************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

exports.__esModule = true;
exports["default"] = resolveRewrites;

var _pathMatch = _interopRequireDefault(__webpack_require__(/*! ./path-match */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/path-match.js"));

var _prepareDestination = _interopRequireDefault(__webpack_require__(/*! ./prepare-destination */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js"));

var _normalizeTrailingSlash = __webpack_require__(/*! ../../../../client/normalize-trailing-slash */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/client/normalize-trailing-slash.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var customRouteMatcher = (0, _pathMatch["default"])(true);

function resolveRewrites(asPath, pages, basePath, rewrites, query, resolveHref) {
  if (!pages.includes(asPath)) {
    var _iterator = _createForOfIteratorHelper(rewrites),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var rewrite = _step.value;
        var matcher = customRouteMatcher(rewrite.source);
        var params = matcher(asPath);

        if (params) {
          if (!rewrite.destination) {
            // this is a proxied rewrite which isn't handled on the client
            break;
          }

          var destRes = (0, _prepareDestination["default"])(rewrite.destination, params, query, true, rewrite.basePath === false ? '' : basePath);
          asPath = destRes.parsedDestination.pathname;
          Object.assign(query, destRes.parsedDestination.query);

          if (pages.includes((0, _normalizeTrailingSlash.removePathTrailingSlash)(asPath))) {
            // check if we now match a page as this means we are done
            // resolving the rewrites
            break;
          } // check if we match a dynamic-route, if so we break the rewrites chain


          var resolvedHref = resolveHref(asPath);

          if (resolvedHref !== asPath && pages.includes(resolvedHref)) {
            break;
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  return asPath;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../../../../webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js */ "./.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/route-matcher.js":
/*!**************************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/route-matcher.js ***!
  \**************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteMatcher = getRouteMatcher;

function getRouteMatcher(routeRegex) {
  var re = routeRegex.re,
      groups = routeRegex.groups;
  return function (pathname) {
    var routeMatch = re.exec(pathname);

    if (!routeMatch) {
      return false;
    }

    var decode = function decode(param) {
      try {
        return decodeURIComponent(param);
      } catch (_) {
        var err = new Error('failed to decode param');
        err.code = 'DECODE_FAILED';
        throw err;
      }
    };

    var params = {};
    Object.keys(groups).forEach(function (slugName) {
      var g = groups[slugName];
      var m = routeMatch[g.pos];

      if (m !== undefined) {
        params[slugName] = ~m.indexOf('/') ? m.split('/').map(function (entry) {
          return decode(entry);
        }) : g.repeat ? [decode(m)] : decode(m);
      }
    });
    return params;
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../../../../webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js */ "./.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/route-regex.js":
/*!************************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/route-regex.js ***!
  \************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteRegex = getRouteRegex; // this isn't importing the escape-string-regex module
// to reduce bytes

function escapeRegex(str) {
  return str.replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&');
}

function parseParameter(param) {
  var optional = param.startsWith('[') && param.endsWith(']');

  if (optional) {
    param = param.slice(1, -1);
  }

  var repeat = param.startsWith('...');

  if (repeat) {
    param = param.slice(3);
  }

  return {
    key: param,
    repeat: repeat,
    optional: optional
  };
}

function getRouteRegex(normalizedRoute) {
  var segments = (normalizedRoute.replace(/\/$/, '') || '/').slice(1).split('/');
  var groups = {};
  var groupIndex = 1;
  var parameterizedRoute = segments.map(function (segment) {
    if (segment.startsWith('[') && segment.endsWith(']')) {
      var _parseParameter = parseParameter(segment.slice(1, -1)),
          key = _parseParameter.key,
          optional = _parseParameter.optional,
          repeat = _parseParameter.repeat;

      groups[key] = {
        pos: groupIndex++,
        repeat: repeat,
        optional: optional
      };
      return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';
    } else {
      return "/".concat(escapeRegex(segment));
    }
  }).join(''); // dead code eliminate for browser since it's only needed
  // while generating routes-manifest

  if (false) { var namedParameterizedRoute, routeKeys, getSafeRouteKey, routeKeyCharLength, routeKeyCharCode; }

  return {
    re: new RegExp("^".concat(parameterizedRoute, "(?:/)?$")),
    groups: groups
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../../../../webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js */ "./.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/utils.js":
/*!*****************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/utils.js ***!
  \*****************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/regenerator */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/asyncToGenerator */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/asyncToGenerator.js");

exports.__esModule = true;
exports.execOnce = execOnce;
exports.getLocationOrigin = getLocationOrigin;
exports.getURL = getURL;
exports.getDisplayName = getDisplayName;
exports.isResSent = isResSent;
exports.loadGetInitialProps = loadGetInitialProps;
exports.formatWithValidation = formatWithValidation;
exports.ST = exports.SP = exports.urlObjectKeys = void 0;

var _formatUrl = __webpack_require__(/*! ./router/utils/format-url */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/lib/router/utils/format-url.js");
/**
* Utils
*/


function execOnce(fn) {
  var used = false;
  var result;
  return function () {
    if (!used) {
      used = true;
      result = fn.apply(void 0, arguments);
    }

    return result;
  };
}

function getLocationOrigin() {
  var _window$location = window.location,
      protocol = _window$location.protocol,
      hostname = _window$location.hostname,
      port = _window$location.port;
  return "".concat(protocol, "//").concat(hostname).concat(port ? ':' + port : '');
}

function getURL() {
  var href = window.location.href;
  var origin = getLocationOrigin();
  return href.substring(origin.length);
}

function getDisplayName(Component) {
  return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}

function isResSent(res) {
  return res.finished || res.headersSent;
}

function loadGetInitialProps(_x, _x2) {
  return _loadGetInitialProps.apply(this, arguments);
}

function _loadGetInitialProps() {
  _loadGetInitialProps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(App, ctx) {
    var _App$prototype, message, res, props, _message;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (false) {}

            if (!((_App$prototype = App.prototype) == null ? void 0 : _App$prototype.getInitialProps)) {
              _context.next = 4;
              break;
            }

            message = "\"".concat(getDisplayName(App), ".getInitialProps()\" is defined as an instance method - visit https://err.sh/vercel/next.js/get-initial-props-as-an-instance-method for more information.");
            throw new Error(message);

          case 4:
            // when called from _app `ctx` is nested in `ctx`
            res = ctx.res || ctx.ctx && ctx.ctx.res;

            if (App.getInitialProps) {
              _context.next = 12;
              break;
            }

            if (!(ctx.ctx && ctx.Component)) {
              _context.next = 11;
              break;
            }

            _context.next = 9;
            return loadGetInitialProps(ctx.Component, ctx.ctx);

          case 9:
            _context.t0 = _context.sent;
            return _context.abrupt("return", {
              pageProps: _context.t0
            });

          case 11:
            return _context.abrupt("return", {});

          case 12:
            _context.next = 14;
            return App.getInitialProps(ctx);

          case 14:
            props = _context.sent;

            if (!(res && isResSent(res))) {
              _context.next = 17;
              break;
            }

            return _context.abrupt("return", props);

          case 17:
            if (props) {
              _context.next = 20;
              break;
            }

            _message = "\"".concat(getDisplayName(App), ".getInitialProps()\" should resolve to an object. But found \"").concat(props, "\" instead.");
            throw new Error(_message);

          case 20:
            if (true) {
              if (Object.keys(props).length === 0 && !ctx.ctx) {
                console.warn("".concat(getDisplayName(App), " returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://err.sh/vercel/next.js/empty-object-getInitialProps"));
              }
            }

            return _context.abrupt("return", props);

          case 22:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadGetInitialProps.apply(this, arguments);
}

var urlObjectKeys = ['auth', 'hash', 'host', 'hostname', 'href', 'path', 'pathname', 'port', 'protocol', 'query', 'search', 'slashes'];
exports.urlObjectKeys = urlObjectKeys;

function formatWithValidation(url) {
  if (true) {
    if (url !== null && typeof url === 'object') {
      Object.keys(url).forEach(function (key) {
        if (urlObjectKeys.indexOf(key) === -1) {
          console.warn("Unknown key passed via urlObject into url.format: ".concat(key));
        }
      });
    }
  }

  return (0, _formatUrl.formatUrl)(url);
}

var SP = typeof performance !== 'undefined';
exports.SP = SP;
var ST = SP && typeof performance.mark === 'function' && typeof performance.measure === 'function';
exports.ST = ST;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../../webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js */ "./.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/server/denormalize-page-path.js":
/*!************************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/next-server/server/denormalize-page-path.js ***!
  \************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
exports.__esModule=true;exports.normalizePathSep=normalizePathSep;exports.denormalizePagePath=denormalizePagePath;function normalizePathSep(path){return path.replace(/\\/g,'/');}function denormalizePagePath(page){page=normalizePathSep(page);if(page.startsWith('/index/')){page=page.slice(6);}else if(page==='/index'){page='/';}return page;}
//# sourceMappingURL=denormalize-page-path.js.map

/***/ }),

/***/ "./.yarn/__virtual__/style-loader-virtual-501e82968d/0/cache/style-loader-npm-1.2.1-d2e298addc-cd30484665.zip/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!***************************************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/style-loader-virtual-501e82968d/0/cache/style-loader-npm-1.2.1-d2e298addc-cd30484665.zip/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \***************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : undefined;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && btoa) {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*********************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!*******************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*********************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!*******************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/construct.js":
/*!**************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/construct.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/setPrototypeOf.js");

var isNativeReflectConstruct = __webpack_require__(/*! ./isNativeReflectConstruct */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js");

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/createClass.js":
/*!****************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/createClass.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/defineProperty.js":
/*!*******************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!***********************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \***********************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _defineProperty; });
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/interopRequireWildcard.js":
/*!***************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
  \***************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/typeof.js");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js ***!
  \*****************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!********************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!*******************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!******************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/arrayWithHoles.js");

var iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/iterableToArrayLimit.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableRest = __webpack_require__(/*! ./nonIterableRest */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/typeof.js":
/*!***********************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/typeof.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!*******************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \*******************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/regenerator/index.js":
/*!**************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/regenerator/index.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./.yarn/cache/regenerator-runtime-npm-0.13.7-41bcbe64ea-52b66e6669.zip/node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/boot/init.js":
/*!***********************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/boot/init.js ***!
  \***********************************************************************************************************************************/
/*! exports provided: makePublicApi, defineGlobal, BuildMode, commonInit, checkCookiesAuthorized, checkIsNotLocalFile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makePublicApi", function() { return makePublicApi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defineGlobal", function() { return defineGlobal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BuildMode", function() { return BuildMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "commonInit", function() { return commonInit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkCookiesAuthorized", function() { return checkCookiesAuthorized; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkIsNotLocalFile", function() { return checkIsNotLocalFile; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./.yarn/cache/tslib-npm-1.14.1-102499115e-dbe628ef87.zip/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _browser_cookie__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../browser/cookie */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/browser/cookie.js");
/* harmony import */ var _domain_configuration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../domain/configuration */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/configuration.js");
/* harmony import */ var _domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../domain/internalMonitoring */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/internalMonitoring.js");
/* harmony import */ var _tools_catchUserErrors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tools/catchUserErrors */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/catchUserErrors.js");





function makePublicApi(stub) {
    var publicApi = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, stub), { 
        // This API method is intentionally not monitored, since the only thing executed is the
        // user-provided 'callback'.  All SDK usages executed in the callback should be monitored, and
        // we don't want to interfer with the user uncaught exceptions.
        onReady: function (callback) {
            callback();
        } });
    // Add an "hidden" property to set debug mode. We define it that way to hide it
    // as much as possible but of course it's not a real protection.
    Object.defineProperty(publicApi, '_setDebug', {
        get: function () {
            return _domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_3__["setDebugMode"];
        },
        enumerable: false,
    });
    return publicApi;
}
function defineGlobal(global, name, api) {
    var existingGlobalVariable = global[name];
    global[name] = api;
    if (existingGlobalVariable && existingGlobalVariable.q) {
        existingGlobalVariable.q.forEach(function (fn) { return Object(_tools_catchUserErrors__WEBPACK_IMPORTED_MODULE_4__["catchUserErrors"])(fn, 'onReady callback threw an error:')(); });
    }
}
var BuildMode;
(function (BuildMode) {
    BuildMode["RELEASE"] = "release";
    BuildMode["STAGING"] = "staging";
    BuildMode["E2E_TEST"] = "e2e-test";
})(BuildMode || (BuildMode = {}));
function commonInit(userConfiguration, buildEnv) {
    var configuration = Object(_domain_configuration__WEBPACK_IMPORTED_MODULE_2__["buildConfiguration"])(userConfiguration, buildEnv);
    var internalMonitoring = Object(_domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_3__["startInternalMonitoring"])(configuration);
    return {
        configuration: configuration,
        internalMonitoring: internalMonitoring,
    };
}
function checkCookiesAuthorized(options) {
    if (!Object(_browser_cookie__WEBPACK_IMPORTED_MODULE_1__["areCookiesAuthorized"])(options)) {
        console.warn('Cookies are not authorized, we will not send any data.');
        return false;
    }
    return true;
}
function checkIsNotLocalFile() {
    if (isLocalFile()) {
        console.error('Execution is not allowed in the current context.');
        return false;
    }
    return true;
}
function isLocalFile() {
    return window.location.protocol === 'file:';
}
//# sourceMappingURL=init.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/browser/cookie.js":
/*!****************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/browser/cookie.js ***!
  \****************************************************************************************************************************************/
/*! exports provided: COOKIE_ACCESS_DELAY, cacheCookieAccess, setCookie, getCookie, areCookiesAuthorized, getCurrentSite */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COOKIE_ACCESS_DELAY", function() { return COOKIE_ACCESS_DELAY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cacheCookieAccess", function() { return cacheCookieAccess; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setCookie", function() { return setCookie; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCookie", function() { return getCookie; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areCookiesAuthorized", function() { return areCookiesAuthorized; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCurrentSite", function() { return getCurrentSite; });
/* harmony import */ var _tools_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/utils */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/utils.js");

var COOKIE_ACCESS_DELAY = _tools_utils__WEBPACK_IMPORTED_MODULE_0__["ONE_SECOND"];
function cacheCookieAccess(name, options) {
    var timeout;
    var cache;
    var hasCache = false;
    var cacheAccess = function () {
        hasCache = true;
        clearTimeout(timeout);
        timeout = setTimeout(function () {
            hasCache = false;
        }, COOKIE_ACCESS_DELAY);
    };
    return {
        get: function () {
            if (hasCache) {
                return cache;
            }
            cache = getCookie(name);
            cacheAccess();
            return cache;
        },
        set: function (value, expireDelay) {
            setCookie(name, value, expireDelay, options);
            cache = value;
            cacheAccess();
        },
    };
}
function setCookie(name, value, expireDelay, options) {
    var date = new Date();
    date.setTime(date.getTime() + expireDelay);
    var expires = "expires=" + date.toUTCString();
    var sameSite = options && options.crossSite ? 'none' : 'strict';
    var domain = options && options.domain ? ";domain=" + options.domain : '';
    var secure = options && options.secure ? ";secure" : '';
    document.cookie = name + "=" + value + ";" + expires + ";path=/;samesite=" + sameSite + domain + secure;
}
function getCookie(name) {
    return Object(_tools_utils__WEBPACK_IMPORTED_MODULE_0__["findCommaSeparatedValue"])(document.cookie, name);
}
function areCookiesAuthorized(options) {
    if (document.cookie === undefined || document.cookie === null) {
        return false;
    }
    try {
        // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during
        // the test cookie lifetime
        var testCookieName = "dd_cookie_test_" + Object(_tools_utils__WEBPACK_IMPORTED_MODULE_0__["generateUUID"])();
        var testCookieValue = 'test';
        setCookie(testCookieName, testCookieValue, _tools_utils__WEBPACK_IMPORTED_MODULE_0__["ONE_SECOND"], options);
        return getCookie(testCookieName) === testCookieValue;
    }
    catch (error) {
        console.error(error);
        return false;
    }
}
/**
 * No API to retrieve it, number of levels for subdomain and suffix are unknown
 * strategy: find the minimal domain on which cookies are allowed to be set
 * https://web.dev/same-site-same-origin/#site
 */
var getCurrentSiteCache;
function getCurrentSite() {
    if (getCurrentSiteCache === undefined) {
        // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during
        // the test cookie lifetime
        var testCookieName = "dd_site_test_" + Object(_tools_utils__WEBPACK_IMPORTED_MODULE_0__["generateUUID"])();
        var testCookieValue = 'test';
        var domainLevels = window.location.hostname.split('.');
        var candidateDomain = domainLevels.pop();
        while (domainLevels.length && !getCookie(testCookieName)) {
            candidateDomain = domainLevels.pop() + "." + candidateDomain;
            setCookie(testCookieName, testCookieValue, _tools_utils__WEBPACK_IMPORTED_MODULE_0__["ONE_SECOND"], { domain: candidateDomain });
        }
        getCurrentSiteCache = candidateDomain;
    }
    return getCurrentSiteCache;
}
//# sourceMappingURL=cookie.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/browser/fetchProxy.js":
/*!********************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/browser/fetchProxy.js ***!
  \********************************************************************************************************************************************/
/*! exports provided: startFetchProxy, resetFetchProxy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startFetchProxy", function() { return startFetchProxy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetFetchProxy", function() { return resetFetchProxy; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./.yarn/cache/tslib-npm-1.14.1-102499115e-dbe628ef87.zip/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../domain/internalMonitoring */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/internalMonitoring.js");
/* harmony import */ var _domain_tracekit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../domain/tracekit */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/tracekit/index.js");
/* harmony import */ var _tools_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tools/error */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/error.js");
/* harmony import */ var _tools_timeUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tools/timeUtils */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/timeUtils.js");
/* harmony import */ var _tools_urlPolyfill__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tools/urlPolyfill */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/urlPolyfill.js");






var fetchProxySingleton;
var originalFetch;
var beforeSendCallbacks = [];
var onRequestCompleteCallbacks = [];
function startFetchProxy() {
    if (!fetchProxySingleton) {
        proxyFetch();
        fetchProxySingleton = {
            beforeSend: function (callback) {
                beforeSendCallbacks.push(callback);
            },
            onRequestComplete: function (callback) {
                onRequestCompleteCallbacks.push(callback);
            },
        };
    }
    return fetchProxySingleton;
}
function resetFetchProxy() {
    if (fetchProxySingleton) {
        fetchProxySingleton = undefined;
        beforeSendCallbacks.splice(0, beforeSendCallbacks.length);
        onRequestCompleteCallbacks.splice(0, onRequestCompleteCallbacks.length);
        window.fetch = originalFetch;
    }
}
function proxyFetch() {
    if (!window.fetch) {
        return;
    }
    originalFetch = window.fetch;
    window.fetch = function (input, init) {
        var responsePromise;
        var context = Object(_domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_1__["callMonitored"])(beforeSend, null, [input, init]);
        if (context) {
            responsePromise = originalFetch.call(this, context.input, context.init);
            Object(_domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_1__["callMonitored"])(afterSend, null, [responsePromise, context]);
        }
        else {
            responsePromise = originalFetch.call(this, input, init);
        }
        return responsePromise;
    };
}
function beforeSend(input, init) {
    var method = (init && init.method) || (typeof input === 'object' && input.method) || 'GET';
    var url = Object(_tools_urlPolyfill__WEBPACK_IMPORTED_MODULE_5__["normalizeUrl"])((typeof input === 'object' && input.url) || input);
    var startTime = Object(_tools_timeUtils__WEBPACK_IMPORTED_MODULE_4__["relativeNow"])();
    var context = {
        init: init,
        input: input,
        method: method,
        startTime: startTime,
        url: url,
    };
    beforeSendCallbacks.forEach(function (callback) { return callback(context); });
    return context;
}
function afterSend(responsePromise, context) {
    var _this = this;
    var reportFetch = function (response) { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(_this, void 0, void 0, function () {
        var text, e_1;
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"])(this, function (_a) {
            switch (_a.label) {
                case 0:
                    context.duration = Object(_tools_timeUtils__WEBPACK_IMPORTED_MODULE_4__["elapsed"])(context.startTime, Object(_tools_timeUtils__WEBPACK_IMPORTED_MODULE_4__["relativeNow"])());
                    if (!('stack' in response || response instanceof Error)) return [3 /*break*/, 1];
                    context.status = 0;
                    context.response = Object(_tools_error__WEBPACK_IMPORTED_MODULE_3__["toStackTraceString"])(Object(_domain_tracekit__WEBPACK_IMPORTED_MODULE_2__["computeStackTrace"])(response));
                    context.isAborted = response instanceof DOMException && response.code === DOMException.ABORT_ERR;
                    onRequestCompleteCallbacks.forEach(function (callback) { return callback(context); });
                    return [3 /*break*/, 6];
                case 1:
                    if (!('status' in response)) return [3 /*break*/, 6];
                    text = void 0;
                    _a.label = 2;
                case 2:
                    _a.trys.push([2, 4, , 5]);
                    return [4 /*yield*/, response.clone().text()];
                case 3:
                    text = _a.sent();
                    return [3 /*break*/, 5];
                case 4:
                    e_1 = _a.sent();
                    text = "Unable to retrieve response: " + e_1;
                    return [3 /*break*/, 5];
                case 5:
                    context.response = text;
                    context.responseType = response.type;
                    context.status = response.status;
                    context.isAborted = false;
                    onRequestCompleteCallbacks.forEach(function (callback) { return callback(context); });
                    _a.label = 6;
                case 6: return [2 /*return*/];
            }
        });
    }); };
    responsePromise.then(Object(_domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_1__["monitor"])(reportFetch), Object(_domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_1__["monitor"])(reportFetch));
}
//# sourceMappingURL=fetchProxy.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/browser/xhrProxy.js":
/*!******************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/browser/xhrProxy.js ***!
  \******************************************************************************************************************************************/
/*! exports provided: startXhrProxy, resetXhrProxy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startXhrProxy", function() { return startXhrProxy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetXhrProxy", function() { return resetXhrProxy; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./.yarn/cache/tslib-npm-1.14.1-102499115e-dbe628ef87.zip/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../domain/internalMonitoring */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/internalMonitoring.js");
/* harmony import */ var _tools_timeUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/timeUtils */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/timeUtils.js");
/* harmony import */ var _tools_urlPolyfill__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tools/urlPolyfill */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/urlPolyfill.js");

/* eslint-disable no-underscore-dangle */



var xhrProxySingleton;
var beforeSendCallbacks = [];
var onRequestCompleteCallbacks = [];
var originalXhrOpen;
var originalXhrSend;
var originalXhrAbort;
function startXhrProxy() {
    if (!xhrProxySingleton) {
        proxyXhr();
        xhrProxySingleton = {
            beforeSend: function (callback) {
                beforeSendCallbacks.push(callback);
            },
            onRequestComplete: function (callback) {
                onRequestCompleteCallbacks.push(callback);
            },
        };
    }
    return xhrProxySingleton;
}
function resetXhrProxy() {
    if (xhrProxySingleton) {
        xhrProxySingleton = undefined;
        beforeSendCallbacks.length = 0;
        onRequestCompleteCallbacks.length = 0;
        XMLHttpRequest.prototype.open = originalXhrOpen;
        XMLHttpRequest.prototype.send = originalXhrSend;
        XMLHttpRequest.prototype.abort = originalXhrAbort;
    }
}
function proxyXhr() {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    originalXhrOpen = XMLHttpRequest.prototype.open;
    // eslint-disable-next-line @typescript-eslint/unbound-method
    originalXhrSend = XMLHttpRequest.prototype.send;
    // eslint-disable-next-line @typescript-eslint/unbound-method
    originalXhrAbort = XMLHttpRequest.prototype.abort;
    XMLHttpRequest.prototype.open = function (method, url) {
        var _this = this;
        Object(_domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_1__["callMonitored"])(function () {
            // WARN: since this data structure is tied to the instance, it is shared by both logs and rum
            // and can be used by different code versions depending on customer setup
            // so it should stay compatible with older versions
            _this._datadog_xhr = {
                method: method,
                startTime: -1,
                url: Object(_tools_urlPolyfill__WEBPACK_IMPORTED_MODULE_3__["normalizeUrl"])(url),
            };
        });
        return originalXhrOpen.apply(this, arguments);
    };
    XMLHttpRequest.prototype.send = function () {
        var _this = this;
        Object(_domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_1__["callMonitored"])(function () {
            if (_this._datadog_xhr) {
                var xhrPendingContext_1 = _this._datadog_xhr;
                xhrPendingContext_1.startTime = Object(_tools_timeUtils__WEBPACK_IMPORTED_MODULE_2__["relativeNow"])();
                xhrPendingContext_1.isAborted = false;
                var originalOnreadystatechange_1 = _this.onreadystatechange;
                _this.onreadystatechange = function () {
                    if (this.readyState === XMLHttpRequest.DONE) {
                        // Try to report the XHR as soon as possible, because the XHR may be mutated by the
                        // application during a future event. For example, Angular is calling .abort() on
                        // completed requests during a onreadystatechange event, so the status becomes '0'
                        // before the request is collected.
                        Object(_domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_1__["callMonitored"])(reportXhr_1);
                    }
                    if (originalOnreadystatechange_1) {
                        originalOnreadystatechange_1.apply(this, arguments);
                    }
                };
                var hasBeenReported_1 = false;
                var reportXhr_1 = function () {
                    if (hasBeenReported_1) {
                        return;
                    }
                    hasBeenReported_1 = true;
                    var xhrCompleteContext = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, xhrPendingContext_1), { duration: Object(_tools_timeUtils__WEBPACK_IMPORTED_MODULE_2__["elapsed"])(xhrPendingContext_1.startTime, Object(_tools_timeUtils__WEBPACK_IMPORTED_MODULE_2__["relativeNow"])()), response: _this.response, status: _this.status });
                    onRequestCompleteCallbacks.forEach(function (callback) { return callback(xhrCompleteContext); });
                };
                _this.addEventListener('loadend', Object(_domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_1__["monitor"])(reportXhr_1));
                beforeSendCallbacks.forEach(function (callback) { return callback(xhrPendingContext_1, _this); });
            }
        });
        return originalXhrSend.apply(this, arguments);
    };
    XMLHttpRequest.prototype.abort = function () {
        var _this = this;
        Object(_domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_1__["callMonitored"])(function () {
            if (_this._datadog_xhr) {
                _this._datadog_xhr.isAborted = true;
            }
        });
        return originalXhrAbort.apply(this, arguments);
    };
}
//# sourceMappingURL=xhrProxy.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/automaticErrorCollection.js":
/*!*********************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/automaticErrorCollection.js ***!
  \*********************************************************************************************************************************************************/
/*! exports provided: startAutomaticErrorCollection, filterErrors, startConsoleTracking, stopConsoleTracking, startRuntimeErrorTracking, stopRuntimeErrorTracking, trackNetworkError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startAutomaticErrorCollection", function() { return startAutomaticErrorCollection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filterErrors", function() { return filterErrors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startConsoleTracking", function() { return startConsoleTracking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stopConsoleTracking", function() { return stopConsoleTracking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startRuntimeErrorTracking", function() { return startRuntimeErrorTracking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stopRuntimeErrorTracking", function() { return stopRuntimeErrorTracking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackNetworkError", function() { return trackNetworkError; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./.yarn/cache/tslib-npm-1.14.1-102499115e-dbe628ef87.zip/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _browser_fetchProxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../browser/fetchProxy */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/browser/fetchProxy.js");
/* harmony import */ var _browser_xhrProxy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../browser/xhrProxy */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/browser/xhrProxy.js");
/* harmony import */ var _tools_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tools/error */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/error.js");
/* harmony import */ var _tools_observable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tools/observable */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/observable.js");
/* harmony import */ var _tools_timeUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tools/timeUtils */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/timeUtils.js");
/* harmony import */ var _tools_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../tools/utils */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/utils.js");
/* harmony import */ var _internalMonitoring__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./internalMonitoring */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/internalMonitoring.js");
/* harmony import */ var _tracekit__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tracekit */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/tracekit/index.js");









var filteredErrorsObservable;
function startAutomaticErrorCollection(configuration) {
    if (!filteredErrorsObservable) {
        var errorObservable = new _tools_observable__WEBPACK_IMPORTED_MODULE_4__["Observable"]();
        trackNetworkError(configuration, errorObservable);
        startConsoleTracking(errorObservable);
        startRuntimeErrorTracking(errorObservable);
        filteredErrorsObservable = filterErrors(configuration, errorObservable);
    }
    return filteredErrorsObservable;
}
function filterErrors(configuration, errorObservable) {
    var errorCount = 0;
    var filteredErrorObservable = new _tools_observable__WEBPACK_IMPORTED_MODULE_4__["Observable"]();
    errorObservable.subscribe(function (error) {
        if (errorCount < configuration.maxErrorsByMinute) {
            errorCount += 1;
            filteredErrorObservable.notify(error);
        }
        else if (errorCount === configuration.maxErrorsByMinute) {
            errorCount += 1;
            filteredErrorObservable.notify({
                message: "Reached max number of errors by minute: " + configuration.maxErrorsByMinute,
                source: _tools_error__WEBPACK_IMPORTED_MODULE_3__["ErrorSource"].AGENT,
                startTime: Object(_tools_timeUtils__WEBPACK_IMPORTED_MODULE_5__["relativeNow"])(),
            });
        }
    });
    setInterval(function () { return (errorCount = 0); }, _tools_utils__WEBPACK_IMPORTED_MODULE_6__["ONE_MINUTE"]);
    return filteredErrorObservable;
}
var originalConsoleError;
function startConsoleTracking(errorObservable) {
    originalConsoleError = console.error;
    console.error = Object(_internalMonitoring__WEBPACK_IMPORTED_MODULE_7__["monitor"])(function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        originalConsoleError.apply(console, params);
        errorObservable.notify(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, buildErrorFromParams(params)), { source: _tools_error__WEBPACK_IMPORTED_MODULE_3__["ErrorSource"].CONSOLE, startTime: Object(_tools_timeUtils__WEBPACK_IMPORTED_MODULE_5__["relativeNow"])() }));
    });
}
function buildErrorFromParams(params) {
    var firstErrorParam = Object(_tools_utils__WEBPACK_IMPORTED_MODULE_6__["find"])(params, function (param) { return param instanceof Error; });
    return {
        message: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__spreadArrays"])(['console error:'], params).map(function (param) { return formatConsoleParameters(param); }).join(' '),
        stack: firstErrorParam ? Object(_tools_error__WEBPACK_IMPORTED_MODULE_3__["toStackTraceString"])(Object(_tracekit__WEBPACK_IMPORTED_MODULE_8__["computeStackTrace"])(firstErrorParam)) : undefined,
    };
}
function stopConsoleTracking() {
    console.error = originalConsoleError;
}
function formatConsoleParameters(param) {
    if (typeof param === 'string') {
        return param;
    }
    if (param instanceof Error) {
        return Object(_tools_error__WEBPACK_IMPORTED_MODULE_3__["formatErrorMessage"])(Object(_tracekit__WEBPACK_IMPORTED_MODULE_8__["computeStackTrace"])(param));
    }
    return Object(_tools_utils__WEBPACK_IMPORTED_MODULE_6__["jsonStringify"])(param, undefined, 2);
}
var traceKitReportHandler;
function startRuntimeErrorTracking(errorObservable) {
    traceKitReportHandler = function (stackTrace, _, errorObject) {
        var _a = Object(_tools_error__WEBPACK_IMPORTED_MODULE_3__["formatUnknownError"])(stackTrace, errorObject, 'Uncaught'), stack = _a.stack, message = _a.message, type = _a.type;
        errorObservable.notify({
            message: message,
            stack: stack,
            type: type,
            source: _tools_error__WEBPACK_IMPORTED_MODULE_3__["ErrorSource"].SOURCE,
            startTime: Object(_tools_timeUtils__WEBPACK_IMPORTED_MODULE_5__["relativeNow"])(),
        });
    };
    Object(_tracekit__WEBPACK_IMPORTED_MODULE_8__["subscribe"])(traceKitReportHandler);
}
function stopRuntimeErrorTracking() {
    Object(_tracekit__WEBPACK_IMPORTED_MODULE_8__["unsubscribe"])(traceKitReportHandler);
}
function trackNetworkError(configuration, errorObservable) {
    Object(_browser_xhrProxy__WEBPACK_IMPORTED_MODULE_2__["startXhrProxy"])().onRequestComplete(function (context) { return handleCompleteRequest(_tools_utils__WEBPACK_IMPORTED_MODULE_6__["RequestType"].XHR, context); });
    Object(_browser_fetchProxy__WEBPACK_IMPORTED_MODULE_1__["startFetchProxy"])().onRequestComplete(function (context) { return handleCompleteRequest(_tools_utils__WEBPACK_IMPORTED_MODULE_6__["RequestType"].FETCH, context); });
    function handleCompleteRequest(type, request) {
        if (!configuration.isIntakeUrl(request.url) &&
            (!configuration.isEnabled('remove-network-errors') || !request.isAborted) &&
            (isRejected(request) || isServerError(request))) {
            errorObservable.notify({
                message: format(type) + " error " + request.method + " " + request.url,
                resource: {
                    method: request.method,
                    statusCode: request.status,
                    url: request.url,
                },
                source: _tools_error__WEBPACK_IMPORTED_MODULE_3__["ErrorSource"].NETWORK,
                stack: truncateResponse(request.response, configuration) || 'Failed to load',
                startTime: request.startTime,
            });
        }
    }
    return {
        stop: function () {
            Object(_browser_xhrProxy__WEBPACK_IMPORTED_MODULE_2__["resetXhrProxy"])();
            Object(_browser_fetchProxy__WEBPACK_IMPORTED_MODULE_1__["resetFetchProxy"])();
        },
    };
}
function isRejected(request) {
    return request.status === 0 && request.responseType !== 'opaque';
}
function isServerError(request) {
    return request.status >= 500;
}
function truncateResponse(response, configuration) {
    if (response && response.length > configuration.requestErrorResponseLengthLimit) {
        return response.substring(0, configuration.requestErrorResponseLengthLimit) + "...";
    }
    return response;
}
function format(type) {
    if (_tools_utils__WEBPACK_IMPORTED_MODULE_6__["RequestType"].XHR === type) {
        return 'XHR';
    }
    return 'Fetch';
}
//# sourceMappingURL=automaticErrorCollection.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/configuration.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/configuration.js ***!
  \**********************************************************************************************************************************************/
/*! exports provided: DEFAULT_CONFIGURATION, buildConfiguration, buildCookieOptions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_CONFIGURATION", function() { return DEFAULT_CONFIGURATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildConfiguration", function() { return buildConfiguration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildCookieOptions", function() { return buildCookieOptions; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./.yarn/cache/tslib-npm-1.14.1-102499115e-dbe628ef87.zip/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _browser_cookie__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../browser/cookie */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/browser/cookie.js");
/* harmony import */ var _tools_catchUserErrors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/catchUserErrors */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/catchUserErrors.js");
/* harmony import */ var _tools_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tools/utils */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/utils.js");
/* harmony import */ var _transportConfiguration__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./transportConfiguration */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/transportConfiguration.js");





var DEFAULT_CONFIGURATION = {
    allowedTracingOrigins: [],
    maxErrorsByMinute: 3000,
    maxInternalMonitoringMessagesPerPage: 15,
    resourceSampleRate: 100,
    sampleRate: 100,
    silentMultipleInit: false,
    trackInteractions: false,
    /**
     * arbitrary value, byte precision not needed
     */
    requestErrorResponseLengthLimit: 32 * _tools_utils__WEBPACK_IMPORTED_MODULE_3__["ONE_KILO_BYTE"],
    /**
     * flush automatically, aim to be lower than ALB connection timeout
     * to maximize connection reuse.
     */
    flushTimeout: 30 * _tools_utils__WEBPACK_IMPORTED_MODULE_3__["ONE_SECOND"],
    /**
     * Logs intake limit
     */
    maxBatchSize: 50,
    maxMessageSize: 256 * _tools_utils__WEBPACK_IMPORTED_MODULE_3__["ONE_KILO_BYTE"],
    /**
     * beacon payload max queue size implementation is 64kb
     * ensure that we leave room for logs, rum and potential other users
     */
    batchBytesLimit: 16 * _tools_utils__WEBPACK_IMPORTED_MODULE_3__["ONE_KILO_BYTE"],
};
function buildConfiguration(userConfiguration, buildEnv) {
    var enableExperimentalFeatures = Array.isArray(userConfiguration.enableExperimentalFeatures)
        ? userConfiguration.enableExperimentalFeatures
        : [];
    var configuration = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({ beforeSend: userConfiguration.beforeSend && Object(_tools_catchUserErrors__WEBPACK_IMPORTED_MODULE_2__["catchUserErrors"])(userConfiguration.beforeSend, 'beforeSend threw an error:'), cookieOptions: buildCookieOptions(userConfiguration), isEnabled: function (feature) { return Object(_tools_utils__WEBPACK_IMPORTED_MODULE_3__["includes"])(enableExperimentalFeatures, feature); }, service: userConfiguration.service }, Object(_transportConfiguration__WEBPACK_IMPORTED_MODULE_4__["computeTransportConfiguration"])(userConfiguration, buildEnv)), DEFAULT_CONFIGURATION);
    if ('allowedTracingOrigins' in userConfiguration) {
        configuration.allowedTracingOrigins = userConfiguration.allowedTracingOrigins;
    }
    if ('sampleRate' in userConfiguration) {
        configuration.sampleRate = userConfiguration.sampleRate;
    }
    if ('resourceSampleRate' in userConfiguration) {
        configuration.resourceSampleRate = userConfiguration.resourceSampleRate;
    }
    if ('trackInteractions' in userConfiguration) {
        configuration.trackInteractions = !!userConfiguration.trackInteractions;
    }
    return configuration;
}
function buildCookieOptions(userConfiguration) {
    var cookieOptions = {};
    cookieOptions.secure = mustUseSecureCookie(userConfiguration);
    cookieOptions.crossSite = !!userConfiguration.useCrossSiteSessionCookie;
    if (!!userConfiguration.trackSessionAcrossSubdomains) {
        cookieOptions.domain = Object(_browser_cookie__WEBPACK_IMPORTED_MODULE_1__["getCurrentSite"])();
    }
    return cookieOptions;
}
function mustUseSecureCookie(userConfiguration) {
    return !!userConfiguration.useSecureSessionCookie || !!userConfiguration.useCrossSiteSessionCookie;
}
//# sourceMappingURL=configuration.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/internalMonitoring.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/internalMonitoring.js ***!
  \***************************************************************************************************************************************************/
/*! exports provided: startInternalMonitoring, resetInternalMonitoring, monitored, monitor, callMonitored, addMonitoringMessage, addErrorToMonitoringBatch, setDebugMode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startInternalMonitoring", function() { return startInternalMonitoring; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetInternalMonitoring", function() { return resetInternalMonitoring; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "monitored", function() { return monitored; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "monitor", function() { return monitor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "callMonitored", function() { return callMonitored; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addMonitoringMessage", function() { return addMonitoringMessage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addErrorToMonitoringBatch", function() { return addErrorToMonitoringBatch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setDebugMode", function() { return setDebugMode; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./.yarn/cache/tslib-npm-1.14.1-102499115e-dbe628ef87.zip/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tools_context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/context */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/context.js");
/* harmony import */ var _tools_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/error */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/error.js");
/* harmony import */ var _tools_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tools/utils */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/utils.js");
/* harmony import */ var _tools_timeUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tools/timeUtils */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/timeUtils.js");
/* harmony import */ var _transport_transport__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../transport/transport */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/transport/transport.js");
/* harmony import */ var _tracekit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tracekit */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/tracekit/index.js");







var StatusType;
(function (StatusType) {
    StatusType["info"] = "info";
    StatusType["error"] = "error";
})(StatusType || (StatusType = {}));
var monitoringConfiguration = { maxMessagesPerPage: 0, sentMessageCount: 0 };
var externalContextProvider;
function startInternalMonitoring(configuration) {
    if (configuration.internalMonitoringEndpoint) {
        var batch = startMonitoringBatch(configuration);
        Object(_tools_utils__WEBPACK_IMPORTED_MODULE_3__["assign"])(monitoringConfiguration, {
            batch: batch,
            maxMessagesPerPage: configuration.maxInternalMonitoringMessagesPerPage,
            sentMessageCount: 0,
        });
        startMonitoringClockDrift();
    }
    return {
        setExternalContextProvider: function (provider) {
            externalContextProvider = provider;
        },
    };
}
function startMonitoringBatch(configuration) {
    var primaryBatch = createMonitoringBatch(configuration.internalMonitoringEndpoint);
    var replicaBatch;
    if (configuration.replica !== undefined) {
        replicaBatch = createMonitoringBatch(configuration.replica.internalMonitoringEndpoint);
    }
    function createMonitoringBatch(endpointUrl) {
        return new _transport_transport__WEBPACK_IMPORTED_MODULE_5__["Batch"](new _transport_transport__WEBPACK_IMPORTED_MODULE_5__["HttpRequest"](endpointUrl, configuration.batchBytesLimit), configuration.maxBatchSize, configuration.batchBytesLimit, configuration.maxMessageSize, configuration.flushTimeout);
    }
    function withContext(message) {
        return Object(_tools_context__WEBPACK_IMPORTED_MODULE_1__["combine"])({
            date: new Date().getTime(),
            view: {
                referrer: document.referrer,
                url: window.location.href,
            },
        }, externalContextProvider !== undefined ? externalContextProvider() : {}, message);
    }
    return {
        add: function (message) {
            var contextualizedMessage = withContext(message);
            primaryBatch.add(contextualizedMessage);
            if (replicaBatch) {
                replicaBatch.add(contextualizedMessage);
            }
        },
    };
}
function resetInternalMonitoring() {
    monitoringConfiguration.batch = undefined;
}
function startMonitoringClockDrift() {
    var interval = setInterval(monitor(function () {
        var drift = Date.now() - Object(_tools_timeUtils__WEBPACK_IMPORTED_MODULE_4__["getTimeStamp"])(Object(_tools_timeUtils__WEBPACK_IMPORTED_MODULE_4__["relativeNow"])());
        if (Math.abs(drift) > _tools_utils__WEBPACK_IMPORTED_MODULE_3__["ONE_SECOND"]) {
            clearInterval(interval);
            var navigationStart = Object(_tools_timeUtils__WEBPACK_IMPORTED_MODULE_4__["getTimeStamp"])(0);
            addMonitoringMessage('clock drift detected', {
                debug: {
                    navigationStartUTC: new Date(navigationStart).toUTCString(),
                    timeSpent: Date.now() - navigationStart,
                    drift: drift,
                },
            });
        }
    }), _tools_utils__WEBPACK_IMPORTED_MODULE_3__["ONE_MINUTE"]);
}
function monitored(_, __, descriptor) {
    var originalMethod = descriptor.value;
    descriptor.value = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var decorated = monitoringConfiguration.batch ? monitor(originalMethod) : originalMethod;
        return decorated.apply(this, args);
    };
}
function monitor(fn) {
    return function () {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return callMonitored(fn, this, arguments);
    }; // consider output type has input type
}
function callMonitored(fn, context, args) {
    try {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return fn.apply(context, args);
    }
    catch (e) {
        logErrorIfDebug(e);
        try {
            addErrorToMonitoringBatch(e);
        }
        catch (e) {
            logErrorIfDebug(e);
        }
    }
}
function addMonitoringMessage(message, context) {
    logMessageIfDebug(message);
    addToMonitoringBatch(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({ message: message }, context), { status: StatusType.info }));
}
function addErrorToMonitoringBatch(e) {
    addToMonitoringBatch(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, formatError(e)), { status: StatusType.error }));
}
function addToMonitoringBatch(message) {
    if (monitoringConfiguration.batch &&
        monitoringConfiguration.sentMessageCount < monitoringConfiguration.maxMessagesPerPage) {
        monitoringConfiguration.sentMessageCount += 1;
        monitoringConfiguration.batch.add(message);
    }
}
function formatError(e) {
    if (e instanceof Error) {
        var stackTrace = Object(_tracekit__WEBPACK_IMPORTED_MODULE_6__["computeStackTrace"])(e);
        return {
            error: {
                kind: stackTrace.name,
                stack: Object(_tools_error__WEBPACK_IMPORTED_MODULE_2__["toStackTraceString"])(stackTrace),
            },
            message: stackTrace.message,
        };
    }
    return {
        error: {
            stack: 'Not an instance of error',
        },
        message: "Uncaught " + Object(_tools_utils__WEBPACK_IMPORTED_MODULE_3__["jsonStringify"])(e),
    };
}
function setDebugMode(debugMode) {
    monitoringConfiguration.debugMode = debugMode;
}
function logErrorIfDebug(e) {
    if (monitoringConfiguration.debugMode) {
        // Log as warn to not forward the logs.
        console.warn('[INTERNAL ERROR]', e);
    }
}
function logMessageIfDebug(message) {
    if (monitoringConfiguration.debugMode) {
        console.log('[MONITORING MESSAGE]', message);
    }
}
//# sourceMappingURL=internalMonitoring.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/oldCookiesMigration.js":
/*!****************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/oldCookiesMigration.js ***!
  \****************************************************************************************************************************************************/
/*! exports provided: OLD_SESSION_COOKIE_NAME, OLD_RUM_COOKIE_NAME, OLD_LOGS_COOKIE_NAME, RUM_SESSION_KEY, LOGS_SESSION_KEY, tryOldCookiesMigration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OLD_SESSION_COOKIE_NAME", function() { return OLD_SESSION_COOKIE_NAME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OLD_RUM_COOKIE_NAME", function() { return OLD_RUM_COOKIE_NAME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OLD_LOGS_COOKIE_NAME", function() { return OLD_LOGS_COOKIE_NAME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RUM_SESSION_KEY", function() { return RUM_SESSION_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LOGS_SESSION_KEY", function() { return LOGS_SESSION_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tryOldCookiesMigration", function() { return tryOldCookiesMigration; });
/* harmony import */ var _browser_cookie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../browser/cookie */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/browser/cookie.js");
/* harmony import */ var _sessionManagement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sessionManagement */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/sessionManagement.js");


var OLD_SESSION_COOKIE_NAME = '_dd';
var OLD_RUM_COOKIE_NAME = '_dd_r';
var OLD_LOGS_COOKIE_NAME = '_dd_l';
// duplicate values to avoid dependency issues
var RUM_SESSION_KEY = 'rum';
var LOGS_SESSION_KEY = 'logs';
/**
 * This migration should remain in the codebase as long as older versions are available/live
 * to allow older sdk versions to be upgraded to newer versions without compatibility issues.
 */
function tryOldCookiesMigration(sessionCookie) {
    var sessionString = sessionCookie.get();
    var oldSessionId = Object(_browser_cookie__WEBPACK_IMPORTED_MODULE_0__["getCookie"])(OLD_SESSION_COOKIE_NAME);
    var oldRumType = Object(_browser_cookie__WEBPACK_IMPORTED_MODULE_0__["getCookie"])(OLD_RUM_COOKIE_NAME);
    var oldLogsType = Object(_browser_cookie__WEBPACK_IMPORTED_MODULE_0__["getCookie"])(OLD_LOGS_COOKIE_NAME);
    if (!sessionString) {
        var session = {};
        if (oldSessionId) {
            session.id = oldSessionId;
        }
        if (oldLogsType && /^[01]$/.test(oldLogsType)) {
            session[LOGS_SESSION_KEY] = oldLogsType;
        }
        if (oldRumType && /^[012]$/.test(oldRumType)) {
            session[RUM_SESSION_KEY] = oldRumType;
        }
        Object(_sessionManagement__WEBPACK_IMPORTED_MODULE_1__["persistSession"])(session, sessionCookie);
    }
}
//# sourceMappingURL=oldCookiesMigration.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/sessionManagement.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/sessionManagement.js ***!
  \**************************************************************************************************************************************************/
/*! exports provided: SESSION_COOKIE_NAME, SESSION_EXPIRATION_DELAY, SESSION_TIME_OUT_DELAY, VISIBILITY_CHECK_DELAY, startSessionManagement, isValidSessionString, persistSession, stopSessionManagement, trackActivity */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SESSION_COOKIE_NAME", function() { return SESSION_COOKIE_NAME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SESSION_EXPIRATION_DELAY", function() { return SESSION_EXPIRATION_DELAY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SESSION_TIME_OUT_DELAY", function() { return SESSION_TIME_OUT_DELAY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VISIBILITY_CHECK_DELAY", function() { return VISIBILITY_CHECK_DELAY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startSessionManagement", function() { return startSessionManagement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidSessionString", function() { return isValidSessionString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "persistSession", function() { return persistSession; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stopSessionManagement", function() { return stopSessionManagement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackActivity", function() { return trackActivity; });
/* harmony import */ var _browser_cookie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../browser/cookie */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/browser/cookie.js");
/* harmony import */ var _tools_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/observable */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/observable.js");
/* harmony import */ var _tools_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/utils */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/utils.js");
/* harmony import */ var _internalMonitoring__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internalMonitoring */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/internalMonitoring.js");
/* harmony import */ var _oldCookiesMigration__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./oldCookiesMigration */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/oldCookiesMigration.js");





var SESSION_COOKIE_NAME = '_dd_s';
var SESSION_EXPIRATION_DELAY = 15 * _tools_utils__WEBPACK_IMPORTED_MODULE_2__["ONE_MINUTE"];
var SESSION_TIME_OUT_DELAY = 4 * _tools_utils__WEBPACK_IMPORTED_MODULE_2__["ONE_HOUR"];
var VISIBILITY_CHECK_DELAY = _tools_utils__WEBPACK_IMPORTED_MODULE_2__["ONE_MINUTE"];
/**
 * Limit access to cookie to avoid performance issues
 */
function startSessionManagement(options, productKey, computeSessionState) {
    var sessionCookie = Object(_browser_cookie__WEBPACK_IMPORTED_MODULE_0__["cacheCookieAccess"])(SESSION_COOKIE_NAME, options);
    Object(_oldCookiesMigration__WEBPACK_IMPORTED_MODULE_4__["tryOldCookiesMigration"])(sessionCookie);
    var renewObservable = new _tools_observable__WEBPACK_IMPORTED_MODULE_1__["Observable"]();
    var currentSessionId = retrieveActiveSession(sessionCookie).id;
    var expandOrRenewSession = _tools_utils__WEBPACK_IMPORTED_MODULE_2__["throttle"](Object(_internalMonitoring__WEBPACK_IMPORTED_MODULE_3__["monitor"])(function () {
        var session = retrieveActiveSession(sessionCookie);
        var _a = computeSessionState(session[productKey]), trackingType = _a.trackingType, isTracked = _a.isTracked;
        session[productKey] = trackingType;
        if (isTracked && !session.id) {
            session.id = _tools_utils__WEBPACK_IMPORTED_MODULE_2__["generateUUID"]();
            session.created = String(Date.now());
        }
        // save changes and expand session duration
        persistSession(session, sessionCookie);
        // If the session id has changed, notify that the session has been renewed
        if (isTracked && currentSessionId !== session.id) {
            currentSessionId = session.id;
            renewObservable.notify();
        }
    }), _browser_cookie__WEBPACK_IMPORTED_MODULE_0__["COOKIE_ACCESS_DELAY"]).throttled;
    var expandSession = function () {
        var session = retrieveActiveSession(sessionCookie);
        persistSession(session, sessionCookie);
    };
    expandOrRenewSession();
    trackActivity(expandOrRenewSession);
    trackVisibility(expandSession);
    return {
        getId: function () { return retrieveActiveSession(sessionCookie).id; },
        getTrackingType: function () { return retrieveActiveSession(sessionCookie)[productKey]; },
        renewObservable: renewObservable,
    };
}
var SESSION_ENTRY_REGEXP = /^([a-z]+)=([a-z0-9-]+)$/;
var SESSION_ENTRY_SEPARATOR = '&';
function isValidSessionString(sessionString) {
    return (sessionString !== undefined &&
        (sessionString.indexOf(SESSION_ENTRY_SEPARATOR) !== -1 || SESSION_ENTRY_REGEXP.test(sessionString)));
}
function retrieveActiveSession(sessionCookie) {
    var session = retrieveSession(sessionCookie);
    if (isActiveSession(session)) {
        return session;
    }
    clearSession(sessionCookie);
    return {};
}
function isActiveSession(session) {
    // created and expire can be undefined for versions which was not storing them
    // these checks could be removed when older versions will not be available/live anymore
    return ((session.created === undefined || Date.now() - Number(session.created) < SESSION_TIME_OUT_DELAY) &&
        (session.expire === undefined || Date.now() < Number(session.expire)));
}
function retrieveSession(sessionCookie) {
    var sessionString = sessionCookie.get();
    var session = {};
    if (isValidSessionString(sessionString)) {
        sessionString.split(SESSION_ENTRY_SEPARATOR).forEach(function (entry) {
            var matches = SESSION_ENTRY_REGEXP.exec(entry);
            if (matches !== null) {
                var key = matches[1], value = matches[2];
                session[key] = value;
            }
        });
    }
    return session;
}
function persistSession(session, cookie) {
    if (_tools_utils__WEBPACK_IMPORTED_MODULE_2__["isEmptyObject"](session)) {
        clearSession(cookie);
        return;
    }
    session.expire = String(Date.now() + SESSION_EXPIRATION_DELAY);
    var cookieString = _tools_utils__WEBPACK_IMPORTED_MODULE_2__["objectEntries"](session)
        .map(function (_a) {
        var key = _a[0], value = _a[1];
        return key + "=" + value;
    })
        .join(SESSION_ENTRY_SEPARATOR);
    cookie.set(cookieString, SESSION_EXPIRATION_DELAY);
}
function clearSession(cookie) {
    cookie.set('', 0);
}
function stopSessionManagement() {
    stopCallbacks.forEach(function (e) { return e(); });
    stopCallbacks = [];
}
var stopCallbacks = [];
function trackActivity(expandOrRenewSession) {
    var stop = _tools_utils__WEBPACK_IMPORTED_MODULE_2__["addEventListeners"](window, ["click" /* CLICK */, "touchstart" /* TOUCH_START */, "keydown" /* KEY_DOWN */, "scroll" /* SCROLL */], expandOrRenewSession, { capture: true, passive: true }).stop;
    stopCallbacks.push(stop);
}
function trackVisibility(expandSession) {
    var expandSessionWhenVisible = Object(_internalMonitoring__WEBPACK_IMPORTED_MODULE_3__["monitor"])(function () {
        if (document.visibilityState === 'visible') {
            expandSession();
        }
    });
    var stop = _tools_utils__WEBPACK_IMPORTED_MODULE_2__["addEventListener"](document, "visibilitychange" /* VISIBILITY_CHANGE */, expandSessionWhenVisible).stop;
    stopCallbacks.push(stop);
    var visibilityCheckInterval = setInterval(expandSessionWhenVisible, VISIBILITY_CHECK_DELAY);
    stopCallbacks.push(function () {
        clearInterval(visibilityCheckInterval);
    });
}
//# sourceMappingURL=sessionManagement.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/tracekit/computeStackTrace.js":
/*!***********************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/tracekit/computeStackTrace.js ***!
  \***********************************************************************************************************************************************************/
/*! exports provided: computeStackTrace, computeStackTraceFromStackProp, augmentStackTraceWithInitialElement, computeStackTraceOfCaller */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeStackTrace", function() { return computeStackTrace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeStackTraceFromStackProp", function() { return computeStackTraceFromStackProp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "augmentStackTraceWithInitialElement", function() { return augmentStackTraceWithInitialElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeStackTraceOfCaller", function() { return computeStackTraceOfCaller; });
/* harmony import */ var _report__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./report */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/tracekit/report.js");

var UNKNOWN_FUNCTION = '?';
/**
 * computeStackTrace: cross-browser stack traces in JavaScript
 *
 * Syntax:
 * ```js
 * s = computeStackTraceOfCaller([depth])
 * s = computeStackTrace(exception) // consider using report instead (see below)
 * ```
 *
 * Supports:
 *   - Firefox:  full stack trace with line numbers and unreliable column
 *               number on top frame
 *   - Opera 10: full stack trace with line and column numbers
 *   - Opera 9-: full stack trace with line numbers
 *   - Chrome:   full stack trace with line and column numbers
 *   - Safari:   line and column number for the topmost stacktrace element
 *               only
 *   - IE:       no line numbers whatsoever
 *
 * Tries to guess names of anonymous functions by looking for assignments
 * in the source code. In IE and Safari, we have to guess source file names
 * by searching for function bodies inside all page scripts. This will not
 * work for scripts that are loaded cross-domain.
 * Here be dragons: some function names may be guessed incorrectly, and
 * duplicate functions may be mismatched.
 *
 * computeStackTrace should only be used for tracing purposes.
 * Logging of unhandled exceptions should be done with report,
 * which builds on top of computeStackTrace and provides better
 * IE support by utilizing the window.onerror event to retrieve information
 * about the top of the stack.
 *
 * Note: In IE and Safari, no stack trace is recorded on the Error object,
 * so computeStackTrace instead walks its *own* chain of callers.
 * This means that:
 *  * in Safari, some methods may be missing from the stack trace;
 *  * in IE, the topmost function in the stack trace will always be the
 *    caller of computeStackTrace.
 *
 * This is okay for tracing (because you are likely to be calling
 * computeStackTrace from the function you want to be the topmost element
 * of the stack trace anyway), but not okay for logging unhandled
 * exceptions (because your catch block will likely be far away from the
 * inner function that actually caused the exception).
 *
 * Tracing example:
 * ```js
 *     function trace(message) {
 *         let stackInfo = computeStackTrace.ofCaller();
 *         let data = message + "\n";
 *         for(let i in stackInfo.stack) {
 *             let item = stackInfo.stack[i];
 *             data += (item.func || '[anonymous]') + "() in " + item.url + ":" + (item.line || '0') + "\n";
 *         }
 *         if (window.console)
 *             console.info(data);
 *         else
 *             alert(data);
 *     }
 * ```
 * @memberof TraceKit
 * @namespace
 */
/**
 * Computes a stack trace for an exception.
 * @param {Error} ex
 * @param {(string|number)=} depth
 * @memberof computeStackTrace
 */
function computeStackTrace(ex, depth) {
    var stack;
    var normalizedDepth = depth === undefined ? 0 : +depth;
    try {
        // This must be tried first because Opera 10 *destroys*
        // its stacktrace property if you try to access the stack
        // property first!!
        stack = computeStackTraceFromStacktraceProp(ex);
        if (stack) {
            return stack;
        }
    }
    catch (e) {
        if (debug) {
            throw e;
        }
    }
    try {
        stack = computeStackTraceFromStackProp(ex);
        if (stack) {
            return stack;
        }
    }
    catch (e) {
        if (debug) {
            throw e;
        }
    }
    try {
        stack = computeStackTraceFromOperaMultiLineMessage(ex);
        if (stack) {
            return stack;
        }
    }
    catch (e) {
        if (debug) {
            throw e;
        }
    }
    try {
        stack = computeStackTraceByWalkingCallerChain(ex, normalizedDepth + 1);
        if (stack) {
            return stack;
        }
    }
    catch (e) {
        if (debug) {
            throw e;
        }
    }
    return {
        message: tryToGetString(ex, 'message'),
        name: tryToGetString(ex, 'name'),
        stack: [],
    };
}
var debug = false;
// Contents of Exception in various browsers.
//
// SAFARI:
// ex.message = Can't find variable: qq
// ex.line = 59
// ex.sourceId = 580238192
// ex.sourceURL = http://...
// ex.expressionBeginOffset = 96
// ex.expressionCaretOffset = 98
// ex.expressionEndOffset = 98
// ex.name = ReferenceError
//
// FIREFOX:
// ex.message = qq is not defined
// ex.fileName = http://...
// ex.lineNumber = 59
// ex.columnNumber = 69
// ex.stack = ...stack trace... (see the example below)
// ex.name = ReferenceError
//
// CHROME:
// ex.message = qq is not defined
// ex.name = ReferenceError
// ex.type = not_defined
// ex.arguments = ['aa']
// ex.stack = ...stack trace...
//
// INTERNET EXPLORER:
// ex.message = ...
// ex.name = ReferenceError
//
// OPERA:
// ex.message = ...message... (see the example below)
// ex.name = ReferenceError
// ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)
// ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'
/**
 * Computes stack trace information from the stack property.
 * Chrome and Gecko use this property.
 * @param {Error} ex
 * @return {?StackTrace} Stack trace information.
 * @memberof computeStackTrace
 */
function computeStackTraceFromStackProp(ex) {
    var stacktrace = tryToGetString(ex, 'stack');
    if (!stacktrace) {
        return;
    }
    // eslint-disable-next-line  max-len
    var chrome = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
    // eslint-disable-next-line  max-len
    var gecko = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|capacitor|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
    // eslint-disable-next-line  max-len
    var winjs = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    // Used to additionally parse URL/line/column from eval frames
    var isEval;
    var geckoEval = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
    var chromeEval = /\((\S*)(?::(\d+))(?::(\d+))\)/;
    var lines = stacktrace.split('\n');
    var stack = [];
    var submatch;
    var parts;
    var element;
    for (var i = 0, j = lines.length; i < j; i += 1) {
        if (chrome.exec(lines[i])) {
            parts = chrome.exec(lines[i]);
            var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line
            isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line
            submatch = chromeEval.exec(parts[2]);
            if (isEval && submatch) {
                // throw out eval line/column and use top-most line/column number
                parts[2] = submatch[1]; // url
                parts[3] = submatch[2]; // line
                parts[4] = submatch[3]; // column
            }
            element = {
                args: isNative ? [parts[2]] : [],
                column: parts[4] ? +parts[4] : undefined,
                func: parts[1] || UNKNOWN_FUNCTION,
                line: parts[3] ? +parts[3] : undefined,
                url: !isNative ? parts[2] : undefined,
            };
        }
        else if (winjs.exec(lines[i])) {
            parts = winjs.exec(lines[i]);
            element = {
                args: [],
                column: parts[4] ? +parts[4] : undefined,
                func: parts[1] || UNKNOWN_FUNCTION,
                line: +parts[3],
                url: parts[2],
            };
        }
        else if (gecko.exec(lines[i])) {
            parts = gecko.exec(lines[i]);
            isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
            submatch = geckoEval.exec(parts[3]);
            if (isEval && submatch) {
                // throw out eval line/column and use top-most line number
                parts[3] = submatch[1];
                parts[4] = submatch[2];
                parts[5] = undefined; // no column when eval
            }
            else if (i === 0 && !parts[5] && !isUndefined(ex.columnNumber)) {
                // FireFox uses this awesome columnNumber property for its top frame
                // Also note, Firefox's column number is 0-based and everything else expects 1-based,
                // so adding 1
                // NOTE: this hack doesn't work if top-most frame is eval
                stack[0].column = ex.columnNumber + 1;
            }
            element = {
                args: parts[2] ? parts[2].split(',') : [],
                column: parts[5] ? +parts[5] : undefined,
                func: parts[1] || UNKNOWN_FUNCTION,
                line: parts[4] ? +parts[4] : undefined,
                url: parts[3],
            };
        }
        else {
            continue;
        }
        if (!element.func && element.line) {
            element.func = UNKNOWN_FUNCTION;
        }
        stack.push(element);
    }
    if (!stack.length) {
        return;
    }
    return {
        stack: stack,
        message: tryToGetString(ex, 'message'),
        name: tryToGetString(ex, 'name'),
    };
}
/**
 * Computes stack trace information from the stacktrace property.
 * Opera 10+ uses this property.
 * @param {Error} ex
 * @return {?StackTrace} Stack trace information.
 * @memberof computeStackTrace
 */
function computeStackTraceFromStacktraceProp(ex) {
    // Access and store the stacktrace property before doing ANYTHING
    // else to it because Opera is not very good at providing it
    // reliably in other circumstances.
    var stacktrace = tryToGetString(ex, 'stacktrace');
    if (!stacktrace) {
        return;
    }
    var opera10Regex = / line (\d+).*script (?:in )?(\S+)(?:: in function (\S+))?$/i;
    // eslint-disable-next-line  max-len
    var opera11Regex = / line (\d+), column (\d+)\s*(?:in (?:<anonymous function: ([^>]+)>|([^\)]+))\((.*)\))? in (.*):\s*$/i;
    var lines = stacktrace.split('\n');
    var stack = [];
    var parts;
    for (var line = 0; line < lines.length; line += 2) {
        var element = void 0;
        if (opera10Regex.exec(lines[line])) {
            parts = opera10Regex.exec(lines[line]);
            element = {
                args: [],
                column: undefined,
                func: parts[3],
                line: +parts[1],
                url: parts[2],
            };
        }
        else if (opera11Regex.exec(lines[line])) {
            parts = opera11Regex.exec(lines[line]);
            element = {
                args: parts[5] ? parts[5].split(',') : [],
                column: +parts[2],
                func: parts[3] || parts[4],
                line: +parts[1],
                url: parts[6],
            };
        }
        if (element) {
            if (!element.func && element.line) {
                element.func = UNKNOWN_FUNCTION;
            }
            element.context = [lines[line + 1]];
            stack.push(element);
        }
    }
    if (!stack.length) {
        return;
    }
    return {
        stack: stack,
        message: tryToGetString(ex, 'message'),
        name: tryToGetString(ex, 'name'),
    };
}
/**
 * NOT TESTED.
 * Computes stack trace information from an error message that includes
 * the stack trace.
 * Opera 9 and earlier use this method if the option to show stack
 * traces is turned on in opera:config.
 * @param {Error} ex
 * @return {?StackTrace} Stack information.
 * @memberof computeStackTrace
 */
function computeStackTraceFromOperaMultiLineMessage(ex) {
    // TODO: Clean this function up
    // Opera includes a stack trace into the exception message. An example is:
    //
    // Statement on line 3: Undefined variable: undefinedFunc
    // Backtrace:
    //   Line 3 of linked script file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.js:
    //   In function zzz
    //         undefinedFunc(a);
    //   Line 7 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html:
    //   In function yyy
    //           zzz(x, y, z);
    //   Line 3 of inline#1 script in file://localhost/Users/andreyvit/Projects/TraceKit/javascript-client/sample.html:
    //   In function xxx
    //           yyy(a, a, a);
    //   Line 1 of function script
    //     try { xxx('hi'); return false; } catch(ex) { report(ex); }
    //   ...
    var message = tryToGetString(ex, 'message');
    if (!message) {
        return;
    }
    var lines = message.split('\n');
    if (lines.length < 4) {
        return;
    }
    var lineRE1 = /^\s*Line (\d+) of linked script ((?:file|https?|blob)\S+)(?:: in function (\S+))?\s*$/i;
    var lineRE2 = /^\s*Line (\d+) of inline#(\d+) script in ((?:file|https?|blob)\S+)(?:: in function (\S+))?\s*$/i;
    var lineRE3 = /^\s*Line (\d+) of function script\s*$/i;
    var stack = [];
    var scripts = window && window.document && window.document.getElementsByTagName('script');
    var inlineScriptBlocks = [];
    var parts;
    for (var s in scripts) {
        if (has(scripts, s) && !scripts[s].src) {
            inlineScriptBlocks.push(scripts[s]);
        }
    }
    for (var line = 2; line < lines.length; line += 2) {
        var item = void 0;
        if (lineRE1.exec(lines[line])) {
            parts = lineRE1.exec(lines[line]);
            item = {
                args: [],
                column: undefined,
                func: parts[3],
                line: +parts[1],
                url: parts[2],
            };
        }
        else if (lineRE2.exec(lines[line])) {
            parts = lineRE2.exec(lines[line]);
            item = {
                args: [],
                column: undefined,
                func: parts[4],
                line: +parts[1],
                url: parts[3],
            };
        }
        else if (lineRE3.exec(lines[line])) {
            parts = lineRE3.exec(lines[line]);
            var url = window.location.href.replace(/#.*$/, '');
            item = {
                url: url,
                args: [],
                column: undefined,
                func: '',
                line: +parts[1],
            };
        }
        if (item) {
            if (!item.func) {
                item.func = UNKNOWN_FUNCTION;
            }
            item.context = [lines[line + 1]];
            stack.push(item);
        }
    }
    if (!stack.length) {
        return; // could not parse multiline exception message as Opera stack trace
    }
    return {
        stack: stack,
        message: lines[0],
        name: tryToGetString(ex, 'name'),
    };
}
/**
 * Adds information about the first frame to incomplete stack traces.
 * Safari and IE require this to get complete data on the first frame.
 * @param {StackTrace} stackInfo Stack trace information from
 * one of the compute* methods.
 * @param {string=} url The URL of the script that caused an error.
 * @param {(number|string)=} lineNo The line number of the script that
 * caused an error.
 * @param {string=} message The error generated by the browser, which
 * hopefully contains the name of the object that caused the error.
 * @return {boolean} Whether or not the stack information was
 * augmented.
 * @memberof computeStackTrace
 */
function augmentStackTraceWithInitialElement(stackInfo, url, lineNo) {
    var initial = {
        url: url,
        line: lineNo ? +lineNo : undefined,
    };
    if (initial.url && initial.line) {
        stackInfo.incomplete = false;
        var stack = stackInfo.stack;
        if (stack.length > 0) {
            if (stack[0].url === initial.url) {
                if (stack[0].line === initial.line) {
                    return false; // already in stack trace
                }
                if (!stack[0].line && stack[0].func === initial.func) {
                    stack[0].line = initial.line;
                    stack[0].context = initial.context;
                    return false;
                }
            }
        }
        stack.unshift(initial);
        stackInfo.partial = true;
        return true;
    }
    stackInfo.incomplete = true;
    return false;
}
/**
 * Computes stack trace information by walking the arguments.caller
 * chain at the time the exception occurred. This will cause earlier
 * frames to be missed but is the only way to get any stack trace in
 * Safari and IE. The top frame is restored by
 * {@link augmentStackTraceWithInitialElement}.
 * @param {Error} ex
 * @param {number} depth
 * @return {StackTrace} Stack trace information.
 * @memberof computeStackTrace
 */
function computeStackTraceByWalkingCallerChain(ex, depth) {
    var functionName = /function\s+([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?\s*\(/i;
    var stack = [];
    var funcs = {};
    var recursion = false;
    var parts;
    var item;
    for (var curr = computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {
        if (curr === computeStackTrace || curr === _report__WEBPACK_IMPORTED_MODULE_0__["report"]) {
            continue;
        }
        item = {
            args: [],
            column: undefined,
            func: UNKNOWN_FUNCTION,
            line: undefined,
            url: undefined,
        };
        parts = functionName.exec(curr.toString());
        if (curr.name) {
            item.func = curr.name;
        }
        else if (parts) {
            item.func = parts[1];
        }
        if (typeof item.func === 'undefined') {
            item.func = parts ? parts.input.substring(0, parts.input.indexOf('{')) : undefined;
        }
        if (funcs[curr.toString()]) {
            recursion = true;
        }
        else {
            funcs[curr.toString()] = true;
        }
        stack.push(item);
    }
    if (depth) {
        stack.splice(0, depth);
    }
    var result = {
        stack: stack,
        message: tryToGetString(ex, 'message'),
        name: tryToGetString(ex, 'name'),
    };
    augmentStackTraceWithInitialElement(result, tryToGetString(ex, 'sourceURL') || tryToGetString(ex, 'fileName'), tryToGetString(ex, 'line') || tryToGetString(ex, 'lineNumber'));
    return result;
}
function tryToGetString(candidate, property) {
    if (typeof candidate !== 'object' || !candidate || !(property in candidate)) {
        return undefined;
    }
    var value = candidate[property];
    return typeof value === 'string' ? value : undefined;
}
/**
 * Logs a stacktrace starting from the previous call and working down.
 * @param {(number|string)=} depth How many frames deep to trace.
 * @return {StackTrace} Stack trace information.
 * @memberof computeStackTrace
 */
function computeStackTraceOfCaller(depth) {
    var currentDepth = (depth === undefined ? 0 : +depth) + 1; // "+ 1" because "ofCaller" should drop one frame
    try {
        throw new Error();
    }
    catch (ex) {
        return computeStackTrace(ex, currentDepth + 1);
    }
}
/**
 * A better form of hasOwnProperty<br/>
 * Example: `has(MainHostObject, property) === true/false`
 *
 * @param {Object} object to check property
 * @param {string} key to check
 * @return {Boolean} true if the object has the key and it is not inherited
 */
function has(object, key) {
    return Object.prototype.hasOwnProperty.call(object, key);
}
/**
 * Returns true if the parameter is undefined<br/>
 * Example: `isUndefined(val) === true/false`
 *
 * @param {*} what Value to check
 * @return {Boolean} true if undefined and false otherwise
 */
function isUndefined(what) {
    return typeof what === 'undefined';
}
//# sourceMappingURL=computeStackTrace.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/tracekit/index.js":
/*!***********************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/tracekit/index.js ***!
  \***********************************************************************************************************************************************/
/*! exports provided: computeStackTrace, report, subscribe, unsubscribe */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _computeStackTrace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./computeStackTrace */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/tracekit/computeStackTrace.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "computeStackTrace", function() { return _computeStackTrace__WEBPACK_IMPORTED_MODULE_0__["computeStackTrace"]; });

/* harmony import */ var _report__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./report */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/tracekit/report.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "report", function() { return _report__WEBPACK_IMPORTED_MODULE_1__["report"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "subscribe", function() { return _report__WEBPACK_IMPORTED_MODULE_1__["subscribe"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unsubscribe", function() { return _report__WEBPACK_IMPORTED_MODULE_1__["unsubscribe"]; });



//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/tracekit/report.js":
/*!************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/tracekit/report.js ***!
  \************************************************************************************************************************************************/
/*! exports provided: report, subscribe, unsubscribe, traceKitWindowOnError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "report", function() { return report; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subscribe", function() { return subscribe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unsubscribe", function() { return unsubscribe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "traceKitWindowOnError", function() { return traceKitWindowOnError; });
/* harmony import */ var _internalMonitoring__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internalMonitoring */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/internalMonitoring.js");
/* harmony import */ var _computeStackTrace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./computeStackTrace */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/tracekit/computeStackTrace.js");


// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types
// eslint-disable-next-line  max-len
var ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/;
/**
 * Cross-browser processing of unhandled exceptions
 *
 * Syntax:
 * ```js
 *   subscribe(function(stackInfo) { ... })
 *   unsubscribe(function(stackInfo) { ... })
 *   report(exception)
 *   try { ...code... } catch(ex) { report(ex); }
 * ```
 *
 * Supports:
 *   - Firefox: full stack trace with line numbers, plus column number
 *     on top frame; column number is not guaranteed
 *   - Opera: full stack trace with line and column numbers
 *   - Chrome: full stack trace with line and column numbers
 *   - Safari: line and column number for the top frame only; some frames
 *     may be missing, and column number is not guaranteed
 *   - IE: line and column number for the top frame only; some frames
 *     may be missing, and column number is not guaranteed
 *
 * In theory, TraceKit should work on all of the following versions:
 *   - IE5.5+ (only 8.0 tested)
 *   - Firefox 0.9+ (only 3.5+ tested)
 *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require
 *     Exceptions Have Stacktrace to be enabled in opera:config)
 *   - Safari 3+ (only 4+ tested)
 *   - Chrome 1+ (only 5+ tested)
 *   - Konqueror 3.5+ (untested)
 *
 * Requires computeStackTrace.
 *
 * Tries to catch all unhandled exceptions and report them to the
 * subscribed handlers. Please note that report will rethrow the
 * exception. This is REQUIRED in order to get a useful stack trace in IE.
 * If the exception does not reach the top of the browser, you will only
 * get a stack trace from the point where report was called.
 *
 * Handlers receive a StackTrace object as described in the
 * computeStackTrace docs.
 *
 * @memberof TraceKit
 * @namespace
 */
/**
 * Reports an unhandled Error.
 * @param {Error} ex
 * @memberof report
 * @throws An exception if an incomplete stack trace is detected (old IE browsers).
 */
function report(ex) {
    if (lastExceptionStack) {
        if (lastException === ex) {
            return; // already caught by an inner catch block, ignore
        }
        processLastException();
    }
    var stack = Object(_computeStackTrace__WEBPACK_IMPORTED_MODULE_1__["computeStackTrace"])(ex);
    lastExceptionStack = stack;
    lastException = ex;
    // If the stack trace is incomplete, wait for 2 seconds for
    // slow slow IE to see if onerror occurs or not before reporting
    // this exception; otherwise, we will end up with an incomplete
    // stack trace
    setTimeout(Object(_internalMonitoring__WEBPACK_IMPORTED_MODULE_0__["monitor"])(function () {
        if (lastException === ex) {
            processLastException();
        }
    }), stack.incomplete ? 2000 : 0);
    throw ex; // re-throw to propagate to the top level (and cause window.onerror)
}
var handlers = [];
var lastException;
var lastExceptionStack;
/**
 * Add a crash handler.
 * @param {Function} handler
 * @memberof report
 */
function subscribe(handler) {
    installGlobalHandler();
    installGlobalUnhandledRejectionHandler();
    handlers.push(handler);
}
/**
 * Remove a crash handler.
 * @param {Function} handler
 * @memberof report
 */
function unsubscribe(handler) {
    for (var i = handlers.length - 1; i >= 0; i -= 1) {
        if (handlers[i] === handler) {
            handlers.splice(i, 1);
        }
    }
    if (handlers.length === 0) {
        uninstallGlobalHandler();
        uninstallGlobalUnhandledRejectionHandler();
    }
}
/**
 * Dispatch stack information to all handlers.
 * @param {StackTrace} stack
 * @param {boolean} isWindowError Is this a top-level window error?
 * @param {Error=} error The error that's being handled (if available, null otherwise)
 * @memberof report
 * @throws An exception if an error occurs while calling an handler.
 */
function notifyHandlers(stack, isWindowError, error) {
    var exception;
    handlers.forEach(function (handler) {
        try {
            handler(stack, isWindowError, error);
        }
        catch (inner) {
            exception = inner;
        }
    });
    if (exception) {
        throw exception;
    }
}
var oldOnerrorHandler;
var onErrorHandlerInstalled;
var oldOnunhandledrejectionHandler;
var onUnhandledRejectionHandlerInstalled;
/**
 * Ensures all global unhandled exceptions are recorded.
 * Supported by Gecko and IE.
 * @param {Event|string} message Error message.
 * @param {string=} url URL of script that generated the exception.
 * @param {(number|string)=} lineNo The line number at which the error occurred.
 * @param {(number|string)=} columnNo The column number at which the error occurred.
 * @param {Error=} errorObj The actual Error object.
 * @memberof report
 */
function traceKitWindowOnError(message, url, lineNo, columnNo, errorObj) {
    var stack;
    if (lastExceptionStack) {
        Object(_computeStackTrace__WEBPACK_IMPORTED_MODULE_1__["augmentStackTraceWithInitialElement"])(lastExceptionStack, url, lineNo);
        processLastException();
    }
    else if (errorObj) {
        stack = Object(_computeStackTrace__WEBPACK_IMPORTED_MODULE_1__["computeStackTrace"])(errorObj);
        notifyHandlers(stack, true, errorObj);
    }
    else {
        var location_1 = {
            url: url,
            column: columnNo,
            line: lineNo,
        };
        var name_1;
        var msg = message;
        if ({}.toString.call(message) === '[object String]') {
            var groups = ERROR_TYPES_RE.exec(msg);
            if (groups) {
                name_1 = groups[1];
                msg = groups[2];
            }
        }
        stack = {
            name: name_1,
            message: typeof msg === 'string' ? msg : undefined,
            stack: [location_1],
        };
        notifyHandlers(stack, true, message);
    }
    if (oldOnerrorHandler) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return oldOnerrorHandler.apply(this, arguments);
    }
    return false;
}
/**
 * Ensures all unhandled rejections are recorded.
 * @param {PromiseRejectionEvent} e event.
 * @memberof report
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onunhandledrejection
 * @see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent
 */
function traceKitWindowOnUnhandledRejection(e) {
    var reason = e.reason || 'Empty reason';
    var stack = Object(_computeStackTrace__WEBPACK_IMPORTED_MODULE_1__["computeStackTrace"])(reason);
    notifyHandlers(stack, true, reason);
}
/**
 * Install a global onerror handler
 * @memberof report
 */
function installGlobalHandler() {
    if (onErrorHandlerInstalled) {
        return;
    }
    oldOnerrorHandler = window.onerror;
    window.onerror = Object(_internalMonitoring__WEBPACK_IMPORTED_MODULE_0__["monitor"])(traceKitWindowOnError);
    onErrorHandlerInstalled = true;
}
/**
 * Uninstall the global onerror handler
 * @memberof report
 */
function uninstallGlobalHandler() {
    if (onErrorHandlerInstalled) {
        window.onerror = oldOnerrorHandler;
        onErrorHandlerInstalled = false;
    }
}
/**
 * Install a global onunhandledrejection handler
 * @memberof report
 */
function installGlobalUnhandledRejectionHandler() {
    if (onUnhandledRejectionHandlerInstalled) {
        return;
    }
    oldOnunhandledrejectionHandler = window.onunhandledrejection !== null ? window.onunhandledrejection : undefined;
    window.onunhandledrejection = Object(_internalMonitoring__WEBPACK_IMPORTED_MODULE_0__["monitor"])(traceKitWindowOnUnhandledRejection);
    onUnhandledRejectionHandlerInstalled = true;
}
/**
 * Uninstall the global onunhandledrejection handler
 * @memberof report
 */
function uninstallGlobalUnhandledRejectionHandler() {
    if (onUnhandledRejectionHandlerInstalled) {
        window.onunhandledrejection = oldOnunhandledrejectionHandler;
        onUnhandledRejectionHandlerInstalled = false;
    }
}
/**
 * Process the most recent exception
 * @memberof report
 */
function processLastException() {
    var currentLastExceptionStack = lastExceptionStack;
    var currentLastException = lastException;
    lastExceptionStack = undefined;
    lastException = undefined;
    notifyHandlers(currentLastExceptionStack, false, currentLastException);
}
//# sourceMappingURL=report.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/transportConfiguration.js":
/*!*******************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/transportConfiguration.js ***!
  \*******************************************************************************************************************************************************/
/*! exports provided: Datacenter, INTAKE_SITE, computeTransportConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Datacenter", function() { return Datacenter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INTAKE_SITE", function() { return INTAKE_SITE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeTransportConfiguration", function() { return computeTransportConfiguration; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./.yarn/cache/tslib-npm-1.14.1-102499115e-dbe628ef87.zip/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _boot_init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../boot/init */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/boot/init.js");
/* harmony import */ var _tools_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/utils */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/utils.js");
var _a;



var ENDPOINTS = {
    alternate: {
        logs: 'logs',
        rum: 'rum',
        sessionReplay: 'session-replay',
        trace: 'trace',
    },
    classic: {
        logs: 'browser',
        rum: 'rum',
        // session-replay has no classic endpoint
        sessionReplay: undefined,
        trace: 'public-trace',
    },
};
var Datacenter = {
    EU: 'eu',
    US: 'us',
};
var INTAKE_SITE = (_a = {},
    _a[Datacenter.EU] = 'datadoghq.eu',
    _a[Datacenter.US] = 'datadoghq.com',
    _a);
var CLASSIC_ALLOWED_SITES = [INTAKE_SITE[Datacenter.US], INTAKE_SITE[Datacenter.EU]];
function computeTransportConfiguration(userConfiguration, buildEnv) {
    var transportSettings = {
        buildMode: buildEnv.buildMode,
        clientToken: userConfiguration.clientToken,
        env: userConfiguration.env,
        proxyHost: userConfiguration.proxyHost,
        sdkVersion: buildEnv.sdkVersion,
        service: userConfiguration.service,
        site: userConfiguration.site || INTAKE_SITE[userConfiguration.datacenter || buildEnv.datacenter],
        version: userConfiguration.version,
    };
    var intakeType = getIntakeType(transportSettings.site, userConfiguration);
    var intakeUrls = getIntakeUrls(intakeType, transportSettings, userConfiguration.replica !== undefined);
    var configuration = {
        isIntakeUrl: function (url) { return intakeUrls.some(function (intakeUrl) { return url.indexOf(intakeUrl) === 0; }); },
        logsEndpoint: getEndpoint(intakeType, 'logs', transportSettings),
        rumEndpoint: getEndpoint(intakeType, 'rum', transportSettings),
        sessionReplayEndpoint: getEndpoint(intakeType, 'sessionReplay', transportSettings),
        traceEndpoint: getEndpoint(intakeType, 'trace', transportSettings),
    };
    if (userConfiguration.internalMonitoringApiKey) {
        configuration.internalMonitoringEndpoint = getEndpoint(intakeType, 'logs', transportSettings, 'browser-agent-internal-monitoring');
    }
    if (transportSettings.buildMode === _boot_init__WEBPACK_IMPORTED_MODULE_1__["BuildMode"].E2E_TEST) {
        configuration.internalMonitoringEndpoint = '<<< E2E INTERNAL MONITORING ENDPOINT >>>';
        configuration.logsEndpoint = '<<< E2E LOGS ENDPOINT >>>';
        configuration.rumEndpoint = '<<< E2E RUM ENDPOINT >>>';
        configuration.sessionReplayEndpoint = '<<< E2E SESSION REPLAY ENDPOINT >>>';
    }
    if (transportSettings.buildMode === _boot_init__WEBPACK_IMPORTED_MODULE_1__["BuildMode"].STAGING) {
        if (userConfiguration.replica !== undefined) {
            var replicaTransportSettings = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, transportSettings), { applicationId: userConfiguration.replica.applicationId, clientToken: userConfiguration.replica.clientToken, site: INTAKE_SITE[Datacenter.US] });
            configuration.replica = {
                applicationId: userConfiguration.replica.applicationId,
                internalMonitoringEndpoint: getEndpoint(intakeType, 'logs', replicaTransportSettings, 'browser-agent-internal-monitoring'),
                logsEndpoint: getEndpoint(intakeType, 'logs', replicaTransportSettings),
                rumEndpoint: getEndpoint(intakeType, 'rum', replicaTransportSettings),
            };
        }
    }
    return configuration;
}
function getIntakeType(site, userConfiguration) {
    return !userConfiguration.useAlternateIntakeDomains && Object(_tools_utils__WEBPACK_IMPORTED_MODULE_2__["includes"])(CLASSIC_ALLOWED_SITES, site) ? 'classic' : 'alternate';
}
function getIntakeUrls(intakeType, settings, withReplica) {
    if (settings.proxyHost) {
        return ["https://" + settings.proxyHost + "/v1/input/"];
    }
    var sites = [settings.site];
    if (settings.buildMode === _boot_init__WEBPACK_IMPORTED_MODULE_1__["BuildMode"].STAGING && withReplica) {
        sites.push(INTAKE_SITE[Datacenter.US]);
    }
    var urls = [];
    var endpointTypes = Object.keys(ENDPOINTS[intakeType]);
    for (var _i = 0, sites_1 = sites; _i < sites_1.length; _i++) {
        var site = sites_1[_i];
        for (var _a = 0, endpointTypes_1 = endpointTypes; _a < endpointTypes_1.length; _a++) {
            var endpointType = endpointTypes_1[_a];
            urls.push("https://" + getHost(intakeType, endpointType, site) + "/v1/input/");
        }
    }
    return urls;
}
function getHost(intakeType, endpointType, site) {
    return (intakeType === 'classic' && getClassicHost(endpointType, site)) || getAlternateHost(endpointType, site);
}
function getClassicHost(endpointType, site) {
    var endpoint = ENDPOINTS.classic[endpointType];
    return endpoint && endpoint + "-http-intake.logs." + site;
}
function getAlternateHost(endpointType, site) {
    var endpoint = ENDPOINTS.alternate[endpointType];
    var domainParts = site.split('.');
    var extension = domainParts.pop();
    var suffix = domainParts.join('-') + "." + extension;
    return endpoint + ".browser-intake-" + suffix;
}
function getEndpoint(intakeType, endpointType, settings, source) {
    var tags = "sdk_version:" + settings.sdkVersion +
        ("" + (settings.env ? ",env:" + settings.env : '')) +
        ("" + (settings.service ? ",service:" + settings.service : '')) +
        ("" + (settings.version ? ",version:" + settings.version : ''));
    var datadogHost = getHost(intakeType, endpointType, settings.site);
    var host = settings.proxyHost ? settings.proxyHost : datadogHost;
    var proxyParameter = settings.proxyHost ? "ddhost=" + datadogHost + "&" : '';
    var parameters = proxyParameter + "ddsource=" + (source || 'browser') + "&ddtags=" + encodeURIComponent(tags);
    return "https://" + host + "/v1/input/" + settings.clientToken + "?" + parameters;
}
//# sourceMappingURL=transportConfiguration.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js":
/*!*******************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js ***!
  \*******************************************************************************************************************************/
/*! exports provided: DEFAULT_CONFIGURATION, buildCookieOptions, startAutomaticErrorCollection, computeStackTrace, BuildMode, defineGlobal, makePublicApi, commonInit, checkCookiesAuthorized, checkIsNotLocalFile, monitored, monitor, callMonitored, addMonitoringMessage, addErrorToMonitoringBatch, setDebugMode, Observable, startSessionManagement, SESSION_TIME_OUT_DELAY, SESSION_COOKIE_NAME, stopSessionManagement, HttpRequest, Batch, normalizeUrl, isValidUrl, haveSameOrigin, getOrigin, getPathName, getSearch, getHash, buildUrl, toServerDuration, timeStampNow, relativeNow, elapsed, getRelativeTime, getTimeStamp, ONE_SECOND, ONE_MINUTE, ONE_HOUR, ONE_KILO_BYTE, ResourceType, RequestType, throttle, assign, generateUUID, performDraw, round, noop, jsonStringify, includes, find, isPercentage, isNumber, objectValues, objectEntries, isEmptyObject, mapValues, getGlobalObject, getLocationOrigin, getLinkElementOrigin, findCommaSeparatedValue, safeTruncate, addEventListener, addEventListeners, runOnReadyState, ErrorSource, formatUnknownError, combine, deepClone, areCookiesAuthorized, getCookie, setCookie, COOKIE_ACCESS_DELAY, startXhrProxy, resetXhrProxy, startFetchProxy, resetFetchProxy, BoundedBuffer, catchUserErrors, createContextManager, limitModification, SPEC_ENDPOINTS, isSafari, isFirefox, isIE, clearAllCookies, stubFetch, createNewEvent, stubXhr, withXhr, setPageVisibility, restorePageVisibility, Datacenter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _domain_configuration__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./domain/configuration */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/configuration.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_CONFIGURATION", function() { return _domain_configuration__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_CONFIGURATION"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "buildCookieOptions", function() { return _domain_configuration__WEBPACK_IMPORTED_MODULE_0__["buildCookieOptions"]; });

/* harmony import */ var _domain_automaticErrorCollection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./domain/automaticErrorCollection */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/automaticErrorCollection.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "startAutomaticErrorCollection", function() { return _domain_automaticErrorCollection__WEBPACK_IMPORTED_MODULE_1__["startAutomaticErrorCollection"]; });

/* harmony import */ var _domain_tracekit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./domain/tracekit */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/tracekit/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "computeStackTrace", function() { return _domain_tracekit__WEBPACK_IMPORTED_MODULE_2__["computeStackTrace"]; });

/* harmony import */ var _boot_init__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./boot/init */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/boot/init.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BuildMode", function() { return _boot_init__WEBPACK_IMPORTED_MODULE_3__["BuildMode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defineGlobal", function() { return _boot_init__WEBPACK_IMPORTED_MODULE_3__["defineGlobal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "makePublicApi", function() { return _boot_init__WEBPACK_IMPORTED_MODULE_3__["makePublicApi"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "commonInit", function() { return _boot_init__WEBPACK_IMPORTED_MODULE_3__["commonInit"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "checkCookiesAuthorized", function() { return _boot_init__WEBPACK_IMPORTED_MODULE_3__["checkCookiesAuthorized"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "checkIsNotLocalFile", function() { return _boot_init__WEBPACK_IMPORTED_MODULE_3__["checkIsNotLocalFile"]; });

/* harmony import */ var _domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./domain/internalMonitoring */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/internalMonitoring.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "monitored", function() { return _domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_4__["monitored"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "monitor", function() { return _domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_4__["monitor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "callMonitored", function() { return _domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_4__["callMonitored"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addMonitoringMessage", function() { return _domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_4__["addMonitoringMessage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addErrorToMonitoringBatch", function() { return _domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_4__["addErrorToMonitoringBatch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setDebugMode", function() { return _domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_4__["setDebugMode"]; });

/* harmony import */ var _tools_observable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tools/observable */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/observable.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Observable", function() { return _tools_observable__WEBPACK_IMPORTED_MODULE_5__["Observable"]; });

/* harmony import */ var _domain_sessionManagement__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./domain/sessionManagement */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/sessionManagement.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "startSessionManagement", function() { return _domain_sessionManagement__WEBPACK_IMPORTED_MODULE_6__["startSessionManagement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SESSION_TIME_OUT_DELAY", function() { return _domain_sessionManagement__WEBPACK_IMPORTED_MODULE_6__["SESSION_TIME_OUT_DELAY"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SESSION_COOKIE_NAME", function() { return _domain_sessionManagement__WEBPACK_IMPORTED_MODULE_6__["SESSION_COOKIE_NAME"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stopSessionManagement", function() { return _domain_sessionManagement__WEBPACK_IMPORTED_MODULE_6__["stopSessionManagement"]; });

/* harmony import */ var _transport_transport__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./transport/transport */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/transport/transport.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HttpRequest", function() { return _transport_transport__WEBPACK_IMPORTED_MODULE_7__["HttpRequest"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Batch", function() { return _transport_transport__WEBPACK_IMPORTED_MODULE_7__["Batch"]; });

/* harmony import */ var _tools_urlPolyfill__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tools/urlPolyfill */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/urlPolyfill.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "normalizeUrl", function() { return _tools_urlPolyfill__WEBPACK_IMPORTED_MODULE_8__["normalizeUrl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isValidUrl", function() { return _tools_urlPolyfill__WEBPACK_IMPORTED_MODULE_8__["isValidUrl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "haveSameOrigin", function() { return _tools_urlPolyfill__WEBPACK_IMPORTED_MODULE_8__["haveSameOrigin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getOrigin", function() { return _tools_urlPolyfill__WEBPACK_IMPORTED_MODULE_8__["getOrigin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getPathName", function() { return _tools_urlPolyfill__WEBPACK_IMPORTED_MODULE_8__["getPathName"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getSearch", function() { return _tools_urlPolyfill__WEBPACK_IMPORTED_MODULE_8__["getSearch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getHash", function() { return _tools_urlPolyfill__WEBPACK_IMPORTED_MODULE_8__["getHash"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "buildUrl", function() { return _tools_urlPolyfill__WEBPACK_IMPORTED_MODULE_8__["buildUrl"]; });

/* harmony import */ var _tools_timeUtils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./tools/timeUtils */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/timeUtils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toServerDuration", function() { return _tools_timeUtils__WEBPACK_IMPORTED_MODULE_9__["toServerDuration"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeStampNow", function() { return _tools_timeUtils__WEBPACK_IMPORTED_MODULE_9__["timeStampNow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "relativeNow", function() { return _tools_timeUtils__WEBPACK_IMPORTED_MODULE_9__["relativeNow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "elapsed", function() { return _tools_timeUtils__WEBPACK_IMPORTED_MODULE_9__["elapsed"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getRelativeTime", function() { return _tools_timeUtils__WEBPACK_IMPORTED_MODULE_9__["getRelativeTime"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getTimeStamp", function() { return _tools_timeUtils__WEBPACK_IMPORTED_MODULE_9__["getTimeStamp"]; });

/* harmony import */ var _tools_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./tools/utils */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ONE_SECOND", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["ONE_SECOND"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ONE_MINUTE", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["ONE_MINUTE"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ONE_HOUR", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["ONE_HOUR"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ONE_KILO_BYTE", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["ONE_KILO_BYTE"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ResourceType", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["ResourceType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RequestType", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["RequestType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "throttle", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["throttle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assign", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["assign"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "generateUUID", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["generateUUID"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "performDraw", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["performDraw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "round", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["round"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "noop", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["noop"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "jsonStringify", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["jsonStringify"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "includes", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["includes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "find", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["find"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isPercentage", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["isPercentage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isNumber", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["isNumber"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "objectValues", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["objectValues"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "objectEntries", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["objectEntries"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isEmptyObject", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["isEmptyObject"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mapValues", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["mapValues"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getGlobalObject", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["getGlobalObject"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getLocationOrigin", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["getLocationOrigin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getLinkElementOrigin", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["getLinkElementOrigin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findCommaSeparatedValue", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["findCommaSeparatedValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "safeTruncate", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["safeTruncate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addEventListener", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["addEventListener"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addEventListeners", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["addEventListeners"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "runOnReadyState", function() { return _tools_utils__WEBPACK_IMPORTED_MODULE_10__["runOnReadyState"]; });

/* harmony import */ var _tools_error__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./tools/error */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/error.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrorSource", function() { return _tools_error__WEBPACK_IMPORTED_MODULE_11__["ErrorSource"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatUnknownError", function() { return _tools_error__WEBPACK_IMPORTED_MODULE_11__["formatUnknownError"]; });

/* harmony import */ var _tools_context__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./tools/context */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/context.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "combine", function() { return _tools_context__WEBPACK_IMPORTED_MODULE_12__["combine"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "deepClone", function() { return _tools_context__WEBPACK_IMPORTED_MODULE_12__["deepClone"]; });

/* harmony import */ var _browser_cookie__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./browser/cookie */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/browser/cookie.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "areCookiesAuthorized", function() { return _browser_cookie__WEBPACK_IMPORTED_MODULE_13__["areCookiesAuthorized"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getCookie", function() { return _browser_cookie__WEBPACK_IMPORTED_MODULE_13__["getCookie"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setCookie", function() { return _browser_cookie__WEBPACK_IMPORTED_MODULE_13__["setCookie"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "COOKIE_ACCESS_DELAY", function() { return _browser_cookie__WEBPACK_IMPORTED_MODULE_13__["COOKIE_ACCESS_DELAY"]; });

/* harmony import */ var _browser_xhrProxy__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./browser/xhrProxy */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/browser/xhrProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "startXhrProxy", function() { return _browser_xhrProxy__WEBPACK_IMPORTED_MODULE_14__["startXhrProxy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resetXhrProxy", function() { return _browser_xhrProxy__WEBPACK_IMPORTED_MODULE_14__["resetXhrProxy"]; });

/* harmony import */ var _browser_fetchProxy__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./browser/fetchProxy */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/browser/fetchProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "startFetchProxy", function() { return _browser_fetchProxy__WEBPACK_IMPORTED_MODULE_15__["startFetchProxy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resetFetchProxy", function() { return _browser_fetchProxy__WEBPACK_IMPORTED_MODULE_15__["resetFetchProxy"]; });

/* harmony import */ var _tools_boundedBuffer__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./tools/boundedBuffer */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/boundedBuffer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BoundedBuffer", function() { return _tools_boundedBuffer__WEBPACK_IMPORTED_MODULE_16__["BoundedBuffer"]; });

/* harmony import */ var _tools_catchUserErrors__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./tools/catchUserErrors */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/catchUserErrors.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "catchUserErrors", function() { return _tools_catchUserErrors__WEBPACK_IMPORTED_MODULE_17__["catchUserErrors"]; });

/* harmony import */ var _tools_contextManager__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./tools/contextManager */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/contextManager.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createContextManager", function() { return _tools_contextManager__WEBPACK_IMPORTED_MODULE_18__["createContextManager"]; });

/* harmony import */ var _tools_limitModification__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./tools/limitModification */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/limitModification.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "limitModification", function() { return _tools_limitModification__WEBPACK_IMPORTED_MODULE_19__["limitModification"]; });

/* harmony import */ var _tools_specHelper__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./tools/specHelper */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/specHelper.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SPEC_ENDPOINTS", function() { return _tools_specHelper__WEBPACK_IMPORTED_MODULE_20__["SPEC_ENDPOINTS"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isSafari", function() { return _tools_specHelper__WEBPACK_IMPORTED_MODULE_20__["isSafari"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isFirefox", function() { return _tools_specHelper__WEBPACK_IMPORTED_MODULE_20__["isFirefox"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isIE", function() { return _tools_specHelper__WEBPACK_IMPORTED_MODULE_20__["isIE"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clearAllCookies", function() { return _tools_specHelper__WEBPACK_IMPORTED_MODULE_20__["clearAllCookies"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stubFetch", function() { return _tools_specHelper__WEBPACK_IMPORTED_MODULE_20__["stubFetch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createNewEvent", function() { return _tools_specHelper__WEBPACK_IMPORTED_MODULE_20__["createNewEvent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stubXhr", function() { return _tools_specHelper__WEBPACK_IMPORTED_MODULE_20__["stubXhr"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withXhr", function() { return _tools_specHelper__WEBPACK_IMPORTED_MODULE_20__["withXhr"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setPageVisibility", function() { return _tools_specHelper__WEBPACK_IMPORTED_MODULE_20__["setPageVisibility"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "restorePageVisibility", function() { return _tools_specHelper__WEBPACK_IMPORTED_MODULE_20__["restorePageVisibility"]; });

/* harmony import */ var _domain_transportConfiguration__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./domain/transportConfiguration */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/transportConfiguration.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Datacenter", function() { return _domain_transportConfiguration__WEBPACK_IMPORTED_MODULE_21__["Datacenter"]; });























//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/boundedBuffer.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/boundedBuffer.js ***!
  \*********************************************************************************************************************************************/
/*! exports provided: BoundedBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoundedBuffer", function() { return BoundedBuffer; });
var DEFAULT_LIMIT = 10000;
var BoundedBuffer = /** @class */ (function () {
    function BoundedBuffer(limit) {
        if (limit === void 0) { limit = DEFAULT_LIMIT; }
        this.limit = limit;
        this.buffer = [];
    }
    BoundedBuffer.prototype.add = function (item) {
        var length = this.buffer.push(item);
        if (length > this.limit) {
            this.buffer.splice(0, 1);
        }
    };
    BoundedBuffer.prototype.drain = function (fn) {
        this.buffer.forEach(function (item) { return fn(item); });
        this.buffer.length = 0;
    };
    return BoundedBuffer;
}());

//# sourceMappingURL=boundedBuffer.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/catchUserErrors.js":
/*!***********************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/catchUserErrors.js ***!
  \***********************************************************************************************************************************************/
/*! exports provided: catchUserErrors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "catchUserErrors", function() { return catchUserErrors; });
function catchUserErrors(fn, errorMsg) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        try {
            return fn.apply(void 0, args);
        }
        catch (err) {
            console.error(errorMsg, err);
        }
    };
}
//# sourceMappingURL=catchUserErrors.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/context.js":
/*!***************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/context.js ***!
  \***************************************************************************************************************************************/
/*! exports provided: combine, deepClone, createCircularReferenceChecker, mergeInto */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combine", function() { return combine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deepClone", function() { return deepClone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCircularReferenceChecker", function() { return createCircularReferenceChecker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeInto", function() { return mergeInto; });
var isContextArray = function (value) { return Array.isArray(value); };
var isContext = function (value) {
    return !Array.isArray(value) && typeof value === 'object' && value !== null;
};
function combine() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    var destination;
    for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {
        var source = sources_1[_a];
        // Ignore any undefined or null sources.
        if (source === undefined || source === null) {
            continue;
        }
        destination = mergeInto(destination, source, createCircularReferenceChecker());
    }
    return destination;
}
/*
 * Performs a deep clone of objects and arrays.
 * - Circular references are replaced by 'undefined'
 */
function deepClone(context) {
    return mergeInto(undefined, context, createCircularReferenceChecker());
}
function createCircularReferenceChecker() {
    if (typeof WeakSet !== 'undefined') {
        var set_1 = new WeakSet();
        return {
            hasAlreadyBeenSeen: function (value) {
                var has = set_1.has(value);
                if (!has) {
                    set_1.add(value);
                }
                return has;
            },
        };
    }
    var array = [];
    return {
        hasAlreadyBeenSeen: function (value) {
            var has = array.indexOf(value) >= 0;
            if (!has) {
                array.push(value);
            }
            return has;
        },
    };
}
/**
 * Iterate over 'source' and affect its subvalues into 'destination', recursively.  If the 'source'
 * and 'destination' can't be merged, return 'source'.
 */
function mergeInto(destination, source, circularReferenceChecker) {
    // Ignore the 'source' if it is undefined
    if (source === undefined) {
        return destination;
    }
    // If the 'source' is not an object or array, it can't be merged with 'destination' in any way, so
    // return it directly.
    if (!isContext(source) && !isContextArray(source)) {
        return source;
    }
    // Return 'undefined' if we already iterated over this 'source' to avoid infinite recursion
    if (circularReferenceChecker.hasAlreadyBeenSeen(source)) {
        return undefined;
    }
    // 'source' and 'destination' are objects, merge them together
    if (isContext(source) && (destination === undefined || isContext(destination))) {
        var finalDestination = destination || {};
        for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
                finalDestination[key] = mergeInto(finalDestination[key], source[key], circularReferenceChecker);
            }
        }
        return finalDestination;
    }
    // 'source' and 'destination' are arrays, merge them together
    if (isContextArray(source) && (destination === undefined || isContextArray(destination))) {
        var finalDestination = destination || [];
        finalDestination.length = Math.max(finalDestination.length, source.length);
        for (var index = 0; index < source.length; index += 1) {
            finalDestination[index] = mergeInto(finalDestination[index], source[index], circularReferenceChecker);
        }
        return finalDestination;
    }
    // The destination in not an array nor an object, so we can't merge it
    return source;
}
//# sourceMappingURL=context.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/contextManager.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/contextManager.js ***!
  \**********************************************************************************************************************************************/
/*! exports provided: createContextManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createContextManager", function() { return createContextManager; });
function createContextManager() {
    var context = {};
    return {
        get: function () { return context; },
        add: function (key, value) {
            context[key] = value;
        },
        remove: function (key) {
            delete context[key];
        },
        set: function (newContext) {
            context = newContext;
        },
    };
}
//# sourceMappingURL=contextManager.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/error.js":
/*!*************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/error.js ***!
  \*************************************************************************************************************************************/
/*! exports provided: ErrorSource, formatUnknownError, toStackTraceString, formatErrorMessage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ErrorSource", function() { return ErrorSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatUnknownError", function() { return formatUnknownError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toStackTraceString", function() { return toStackTraceString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatErrorMessage", function() { return formatErrorMessage; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/utils.js");

var ErrorSource = {
    AGENT: 'agent',
    CONSOLE: 'console',
    CUSTOM: 'custom',
    LOGGER: 'logger',
    NETWORK: 'network',
    SOURCE: 'source',
};
function formatUnknownError(stackTrace, errorObject, nonErrorPrefix) {
    if (!stackTrace || (stackTrace.message === undefined && !(errorObject instanceof Error))) {
        return {
            message: nonErrorPrefix + " " + Object(_utils__WEBPACK_IMPORTED_MODULE_0__["jsonStringify"])(errorObject),
            stack: 'No stack, consider using an instance of Error',
            type: stackTrace && stackTrace.name,
        };
    }
    return {
        message: stackTrace.message || 'Empty message',
        stack: toStackTraceString(stackTrace),
        type: stackTrace.name,
    };
}
function toStackTraceString(stack) {
    var result = formatErrorMessage(stack);
    stack.stack.forEach(function (frame) {
        var func = frame.func === '?' ? '<anonymous>' : frame.func;
        var args = frame.args && frame.args.length > 0 ? "(" + frame.args.join(', ') + ")" : '';
        var line = frame.line ? ":" + frame.line : '';
        var column = frame.line && frame.column ? ":" + frame.column : '';
        result += "\n  at " + func + args + " @ " + frame.url + line + column;
    });
    return result;
}
function formatErrorMessage(stack) {
    return (stack.name || 'Error') + ": " + stack.message;
}
//# sourceMappingURL=error.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/limitModification.js":
/*!*************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/limitModification.js ***!
  \*************************************************************************************************************************************************/
/*! exports provided: limitModification */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "limitModification", function() { return limitModification; });
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./context */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/context.js");

/**
 * Current limitations:
 * - field path do not support array, 'a.b.c' only
 * - modifiable fields type must be string
 */
function limitModification(object, modifiableFieldPaths, modifier) {
    var clone = Object(_context__WEBPACK_IMPORTED_MODULE_0__["deepClone"])(object);
    var result = modifier(clone);
    modifiableFieldPaths.forEach(function (path) {
        var originalValue = get(object, path);
        var newValue = get(clone, path);
        if (typeof originalValue === 'string' && typeof newValue === 'string') {
            set(object, path, newValue);
        }
    });
    return result;
}
function get(object, path) {
    var current = object;
    for (var _i = 0, _a = path.split('.'); _i < _a.length; _i++) {
        var field = _a[_i];
        if (!isValidObjectContaining(current, field)) {
            return;
        }
        current = current[field];
    }
    return current;
}
function set(object, path, value) {
    var current = object;
    var fields = path.split('.');
    for (var i = 0; i < fields.length; i += 1) {
        var field = fields[i];
        if (!isValidObjectContaining(current, field)) {
            return;
        }
        if (i !== fields.length - 1) {
            current = current[field];
        }
        else {
            current[field] = value;
        }
    }
}
function isValidObjectContaining(object, field) {
    return typeof object === 'object' && object !== null && field in object;
}
//# sourceMappingURL=limitModification.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/observable.js":
/*!******************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/observable.js ***!
  \******************************************************************************************************************************************/
/*! exports provided: Observable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Observable", function() { return Observable; });
var Observable = /** @class */ (function () {
    function Observable() {
        this.observers = [];
    }
    Observable.prototype.subscribe = function (f) {
        this.observers.push(f);
    };
    Observable.prototype.notify = function (data) {
        this.observers.forEach(function (observer) { return observer(data); });
    };
    return Observable;
}());

//# sourceMappingURL=observable.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/specHelper.js":
/*!******************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/specHelper.js ***!
  \******************************************************************************************************************************************/
/*! exports provided: SPEC_ENDPOINTS, isSafari, isFirefox, isIE, clearAllCookies, stubFetch, createNewEvent, stubXhr, withXhr, setPageVisibility, restorePageVisibility */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SPEC_ENDPOINTS", function() { return SPEC_ENDPOINTS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSafari", function() { return isSafari; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFirefox", function() { return isFirefox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIE", function() { return isIE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearAllCookies", function() { return clearAllCookies; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stubFetch", function() { return stubFetch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createNewEvent", function() { return createNewEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stubXhr", function() { return stubXhr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withXhr", function() { return withXhr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setPageVisibility", function() { return setPageVisibility; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "restorePageVisibility", function() { return restorePageVisibility; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./.yarn/cache/tslib-npm-1.14.1-102499115e-dbe628ef87.zip/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/utils.js");


var SPEC_ENDPOINTS = {
    internalMonitoringEndpoint: 'https://monitoring-intake.com/v1/input/abcde?foo=bar',
    logsEndpoint: 'https://logs-intake.com/v1/input/abcde?foo=bar',
    rumEndpoint: 'https://rum-intake.com/v1/input/abcde?foo=bar',
    traceEndpoint: 'https://trace-intake.com/v1/input/abcde?foo=bar',
    isIntakeUrl: function (url) {
        var intakeUrls = [
            'https://monitoring-intake.com/v1/input/',
            'https://logs-intake.com/v1/input/',
            'https://rum-intake.com/v1/input/',
            'https://trace-intake.com/v1/input/',
        ];
        return intakeUrls.some(function (intakeUrl) { return url.indexOf(intakeUrl) === 0; });
    },
};
function isSafari() {
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
function isFirefox() {
    return navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
}
function isIE() {
    var hasIEAgent = /Trident.*rv\:11\./.test(navigator.userAgent);
    return navigator.userAgent.indexOf('MSIE ') > 0 || hasIEAgent;
}
function clearAllCookies() {
    document.cookie.split(';').forEach(function (c) {
        document.cookie = c.replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/;samesite=strict");
    });
}
function stubFetch() {
    var originalFetch = window.fetch;
    var allFetchCompleteCallback = _utils__WEBPACK_IMPORTED_MODULE_1__["noop"];
    var pendingRequests = 0;
    function onRequestEnd() {
        pendingRequests -= 1;
        if (pendingRequests === 0) {
            setTimeout(function () { return allFetchCompleteCallback(); });
        }
    }
    window.fetch = (function () {
        pendingRequests += 1;
        var resolve;
        var reject;
        var promise = new Promise(function (res, rej) {
            resolve = res;
            reject = rej;
        });
        promise.resolveWith = function (response) {
            resolve(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, response), { clone: function () {
                    var cloned = {
                        text: function () {
                            if (response.responseTextError) {
                                return Promise.reject(response.responseTextError);
                            }
                            return Promise.resolve(response.responseText);
                        },
                    };
                    return cloned;
                } }));
            onRequestEnd();
        };
        promise.rejectWith = function (error) {
            reject(error);
            onRequestEnd();
        };
        return promise;
    });
    return {
        whenAllComplete: function (callback) {
            allFetchCompleteCallback = callback;
        },
        reset: function () {
            window.fetch = originalFetch;
            allFetchCompleteCallback = _utils__WEBPACK_IMPORTED_MODULE_1__["noop"];
        },
    };
}
var StubXhr = /** @class */ (function () {
    function StubXhr() {
        this.response = undefined;
        this.status = undefined;
        this.readyState = XMLHttpRequest.UNSENT;
        this.onreadystatechange = _utils__WEBPACK_IMPORTED_MODULE_1__["noop"];
        this.hasEnded = false;
        this.fakeEventTarget = document.createElement('div');
    }
    /* eslint-disable @typescript-eslint/no-empty-function,@typescript-eslint/no-unused-vars */
    StubXhr.prototype.open = function (method, url) { };
    StubXhr.prototype.send = function () { };
    /* eslint-enable @typescript-eslint/no-empty-function,@typescript-eslint/no-unused-vars */
    StubXhr.prototype.abort = function () {
        this.status = 0;
        if (this.hasEnded) {
            // Calling xhr.abort() on an ended request does not trigger events
            return;
        }
        this.hasEnded = true;
        this.readyState = XMLHttpRequest.DONE;
        this.onreadystatechange();
        this.dispatchEvent('abort');
        this.dispatchEvent('loadend');
    };
    StubXhr.prototype.complete = function (status, response) {
        if (this.hasEnded) {
            throw new Error("Can't call complete() on a ended request");
        }
        this.hasEnded = true;
        this.response = response;
        this.status = status;
        this.readyState = XMLHttpRequest.DONE;
        this.onreadystatechange();
        if (status >= 200 && status < 500) {
            this.dispatchEvent('load');
        }
        if (status >= 500) {
            this.dispatchEvent('error');
        }
        this.dispatchEvent('loadend');
    };
    StubXhr.prototype.addEventListener = function (name, callback) {
        this.fakeEventTarget.addEventListener(name, callback);
    };
    StubXhr.prototype.dispatchEvent = function (name) {
        this.fakeEventTarget.dispatchEvent(createNewEvent(name));
    };
    return StubXhr;
}());
function createNewEvent(eventName, properties) {
    if (properties === void 0) { properties = {}; }
    var event;
    if (typeof Event === 'function') {
        event = new Event(eventName);
    }
    else {
        event = document.createEvent('Event');
        event.initEvent(eventName, true, true);
    }
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["objectEntries"])(properties).forEach(function (_a) {
        var name = _a[0], value = _a[1];
        // Setting values directly or with a `value` descriptor seems unsupported in IE11
        Object.defineProperty(event, name, {
            get: function () {
                return value;
            },
        });
    });
    return event;
}
function stubXhr() {
    var originalXhr = XMLHttpRequest;
    XMLHttpRequest = StubXhr;
    return {
        reset: function () {
            XMLHttpRequest = originalXhr;
        },
    };
}
function withXhr(_a) {
    var setup = _a.setup, onComplete = _a.onComplete;
    var xhr = new XMLHttpRequest();
    xhr.addEventListener('loadend', function () {
        setTimeout(function () {
            onComplete(xhr);
        });
    });
    setup(xhr);
}
function setPageVisibility(visibility) {
    Object.defineProperty(document, 'visibilityState', {
        get: function () {
            return visibility;
        },
        configurable: true,
    });
}
function restorePageVisibility() {
    delete document.visibilityState;
}
//# sourceMappingURL=specHelper.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/timeUtils.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/timeUtils.js ***!
  \*****************************************************************************************************************************************/
/*! exports provided: toServerDuration, timeStampNow, relativeNow, elapsed, getRelativeTime, getTimeStamp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toServerDuration", function() { return toServerDuration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timeStampNow", function() { return timeStampNow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "relativeNow", function() { return relativeNow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elapsed", function() { return elapsed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRelativeTime", function() { return getRelativeTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTimeStamp", function() { return getTimeStamp; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/utils.js");

function toServerDuration(duration) {
    if (!Object(_utils__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(duration)) {
        return duration;
    }
    return Object(_utils__WEBPACK_IMPORTED_MODULE_0__["round"])(duration * 1e6, 0);
}
function timeStampNow() {
    return Date.now();
}
function relativeNow() {
    return performance.now();
}
function elapsed(start, end) {
    return (end - start);
}
/**
 * Get the time since the navigation was started.
 *
 * Note: this does not use `performance.timeOrigin` because it doesn't seem to reflect the actual
 * time on which the navigation has started: it may be much farther in the past, at least in Firefox 71.
 * Related issue in Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1429926
 */
function getRelativeTime(timestamp) {
    return (timestamp - getNavigationStart());
}
function getTimeStamp(relativeTime) {
    // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
    return Math.floor(getNavigationStart() + relativeTime);
}
/**
 * Navigation start slightly change on some rare cases
 */
var navigationStart;
function getNavigationStart() {
    if (navigationStart === undefined) {
        navigationStart = performance.timing.navigationStart;
    }
    return navigationStart;
}
//# sourceMappingURL=timeUtils.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/urlPolyfill.js":
/*!*******************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/urlPolyfill.js ***!
  \*******************************************************************************************************************************************/
/*! exports provided: normalizeUrl, isValidUrl, haveSameOrigin, getOrigin, getPathName, getSearch, getHash, buildUrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeUrl", function() { return normalizeUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidUrl", function() { return isValidUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "haveSameOrigin", function() { return haveSameOrigin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOrigin", function() { return getOrigin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPathName", function() { return getPathName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSearch", function() { return getSearch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHash", function() { return getHash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildUrl", function() { return buildUrl; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/utils.js");

function normalizeUrl(url) {
    return buildUrl(url, Object(_utils__WEBPACK_IMPORTED_MODULE_0__["getLocationOrigin"])()).href;
}
function isValidUrl(url) {
    try {
        return !!buildUrl(url);
    }
    catch (_a) {
        return false;
    }
}
function haveSameOrigin(url1, url2) {
    return getOrigin(url1) === getOrigin(url2);
}
function getOrigin(url) {
    return Object(_utils__WEBPACK_IMPORTED_MODULE_0__["getLinkElementOrigin"])(buildUrl(url));
}
function getPathName(url) {
    var pathname = buildUrl(url).pathname;
    return pathname[0] === '/' ? pathname : "/" + pathname;
}
function getSearch(url) {
    return buildUrl(url).search;
}
function getHash(url) {
    return buildUrl(url).hash;
}
function buildUrl(url, base) {
    if (checkURLSupported()) {
        return base !== undefined ? new URL(url, base) : new URL(url);
    }
    if (base === undefined && !/:/.test(url)) {
        throw new Error("Invalid URL: '" + url + "'");
    }
    var doc = document;
    var anchorElement = doc.createElement('a');
    if (base !== undefined) {
        doc = document.implementation.createHTMLDocument('');
        var baseElement = doc.createElement('base');
        baseElement.href = base;
        doc.head.appendChild(baseElement);
        doc.body.appendChild(anchorElement);
    }
    anchorElement.href = url;
    return anchorElement;
}
var isURLSupported;
function checkURLSupported() {
    if (isURLSupported !== undefined) {
        return isURLSupported;
    }
    try {
        var url = new URL('http://test/path');
        isURLSupported = url.href === 'http://test/path';
        return isURLSupported;
    }
    catch (_a) {
        isURLSupported = false;
    }
    return isURLSupported;
}
//# sourceMappingURL=urlPolyfill.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/utils.js":
/*!*************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/utils.js ***!
  \*************************************************************************************************************************************/
/*! exports provided: ONE_SECOND, ONE_MINUTE, ONE_HOUR, ONE_KILO_BYTE, ResourceType, RequestType, throttle, assign, generateUUID, performDraw, round, noop, jsonStringify, includes, find, isPercentage, isNumber, objectValues, objectEntries, isEmptyObject, mapValues, getGlobalObject, getLocationOrigin, getLinkElementOrigin, findCommaSeparatedValue, safeTruncate, addEventListener, addEventListeners, runOnReadyState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ONE_SECOND", function() { return ONE_SECOND; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ONE_MINUTE", function() { return ONE_MINUTE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ONE_HOUR", function() { return ONE_HOUR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ONE_KILO_BYTE", function() { return ONE_KILO_BYTE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResourceType", function() { return ResourceType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RequestType", function() { return RequestType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throttle", function() { return throttle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assign", function() { return assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateUUID", function() { return generateUUID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "performDraw", function() { return performDraw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "noop", function() { return noop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "jsonStringify", function() { return jsonStringify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "includes", function() { return includes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "find", function() { return find; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPercentage", function() { return isPercentage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNumber", function() { return isNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "objectValues", function() { return objectValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "objectEntries", function() { return objectEntries; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEmptyObject", function() { return isEmptyObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapValues", function() { return mapValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGlobalObject", function() { return getGlobalObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLocationOrigin", function() { return getLocationOrigin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLinkElementOrigin", function() { return getLinkElementOrigin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findCommaSeparatedValue", function() { return findCommaSeparatedValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "safeTruncate", function() { return safeTruncate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addEventListener", function() { return addEventListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addEventListeners", function() { return addEventListeners; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "runOnReadyState", function() { return runOnReadyState; });
/* harmony import */ var _domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../domain/internalMonitoring */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/internalMonitoring.js");

var ONE_SECOND = 1000;
var ONE_MINUTE = 60 * ONE_SECOND;
var ONE_HOUR = 60 * ONE_MINUTE;
var ONE_KILO_BYTE = 1024;
var ResourceType;
(function (ResourceType) {
    ResourceType["DOCUMENT"] = "document";
    ResourceType["XHR"] = "xhr";
    ResourceType["BEACON"] = "beacon";
    ResourceType["FETCH"] = "fetch";
    ResourceType["CSS"] = "css";
    ResourceType["JS"] = "js";
    ResourceType["IMAGE"] = "image";
    ResourceType["FONT"] = "font";
    ResourceType["MEDIA"] = "media";
    ResourceType["OTHER"] = "other";
})(ResourceType || (ResourceType = {}));
var RequestType;
(function (RequestType) {
    RequestType["FETCH"] = "fetch";
    RequestType["XHR"] = "xhr";
})(RequestType || (RequestType = {}));
// use lodash API
function throttle(fn, wait, options) {
    var needLeadingExecution = options && options.leading !== undefined ? options.leading : true;
    var needTrailingExecution = options && options.trailing !== undefined ? options.trailing : true;
    var inWaitPeriod = false;
    var pendingExecutionWithParameters;
    var pendingTimeoutId;
    return {
        throttled: function () {
            var parameters = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                parameters[_i] = arguments[_i];
            }
            if (inWaitPeriod) {
                pendingExecutionWithParameters = parameters;
                return;
            }
            if (needLeadingExecution) {
                fn.apply(void 0, parameters);
            }
            else {
                pendingExecutionWithParameters = parameters;
            }
            inWaitPeriod = true;
            pendingTimeoutId = setTimeout(function () {
                if (needTrailingExecution && pendingExecutionWithParameters) {
                    fn.apply(void 0, pendingExecutionWithParameters);
                }
                inWaitPeriod = false;
                pendingExecutionWithParameters = undefined;
            }, wait);
        },
        cancel: function () {
            clearTimeout(pendingTimeoutId);
            inWaitPeriod = false;
            pendingExecutionWithParameters = undefined;
        },
    };
}
function assign(target) {
    var toAssign = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        toAssign[_i - 1] = arguments[_i];
    }
    toAssign.forEach(function (source) {
        for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
            }
        }
    });
}
/**
 * UUID v4
 * from https://gist.github.com/jed/982883
 */
function generateUUID(placeholder) {
    return placeholder
        ? // eslint-disable-next-line  no-bitwise
            (parseInt(placeholder, 10) ^ ((Math.random() * 16) >> (parseInt(placeholder, 10) / 4))).toString(16)
        : (1e7 + "-" + 1e3 + "-" + 4e3 + "-" + 8e3 + "-" + 1e11).replace(/[018]/g, generateUUID);
}
/**
 * Return true if the draw is successful
 * @param threshold between 0 and 100
 */
function performDraw(threshold) {
    return threshold !== 0 && Math.random() * 100 <= threshold;
}
function round(num, decimals) {
    return +num.toFixed(decimals);
}
// eslint-disable-next-line @typescript-eslint/no-empty-function
function noop() { }
/**
 * Custom implementation of JSON.stringify that ignores value.toJSON.
 * We need to do that because some sites badly override toJSON on certain objects.
 * Note this still supposes that JSON.stringify is correct...
 */
function jsonStringify(value, replacer, space) {
    if (value === null || value === undefined) {
        return JSON.stringify(value);
    }
    var originalToJSON = [false, undefined];
    if (hasToJSON(value)) {
        // We need to add a flag and not rely on the truthiness of value.toJSON
        // because it can be set but undefined and that's actually significant.
        originalToJSON = [true, value.toJSON];
        delete value.toJSON;
    }
    var originalProtoToJSON = [false, undefined];
    var prototype;
    if (typeof value === 'object') {
        prototype = Object.getPrototypeOf(value);
        if (hasToJSON(prototype)) {
            originalProtoToJSON = [true, prototype.toJSON];
            delete prototype.toJSON;
        }
    }
    var result;
    try {
        result = JSON.stringify(value, replacer, space);
    }
    catch (_a) {
        result = '<error: unable to serialize object>';
    }
    finally {
        if (originalToJSON[0]) {
            ;
            value.toJSON = originalToJSON[1];
        }
        if (originalProtoToJSON[0]) {
            ;
            prototype.toJSON = originalProtoToJSON[1];
        }
    }
    return result;
}
function hasToJSON(value) {
    return typeof value === 'object' && value !== null && value.hasOwnProperty('toJSON');
}
function includes(candidate, search) {
    return candidate.indexOf(search) !== -1;
}
function find(array, predicate) {
    for (var i = 0; i < array.length; i += 1) {
        var item = array[i];
        if (predicate(item, i, array)) {
            return item;
        }
    }
    return undefined;
}
function isPercentage(value) {
    return isNumber(value) && value >= 0 && value <= 100;
}
function isNumber(value) {
    return typeof value === 'number';
}
function objectValues(object) {
    var values = [];
    Object.keys(object).forEach(function (key) {
        values.push(object[key]);
    });
    return values;
}
function objectEntries(object) {
    return Object.keys(object).map(function (key) { return [key, object[key]]; });
}
function isEmptyObject(object) {
    return Object.keys(object).length === 0;
}
function mapValues(object, fn) {
    var newObject = {};
    for (var _i = 0, _a = Object.keys(object); _i < _a.length; _i++) {
        var key = _a[_i];
        newObject[key] = fn(object[key]);
    }
    return newObject;
}
/**
 * inspired by https://mathiasbynens.be/notes/globalthis
 */
function getGlobalObject() {
    if (typeof globalThis === 'object') {
        return globalThis;
    }
    Object.defineProperty(Object.prototype, '_dd_temp_', {
        get: function () {
            return this;
        },
        configurable: true,
    });
    // @ts-ignore _dd_temp is defined using defineProperty
    var globalObject = _dd_temp_;
    // @ts-ignore _dd_temp is defined using defineProperty
    delete Object.prototype._dd_temp_; // eslint-disable-line no-underscore-dangle
    if (typeof globalObject !== 'object') {
        // on safari _dd_temp_ is available on window but not globally
        // fallback on other browser globals check
        if (typeof self === 'object') {
            globalObject = self;
        }
        else if (typeof window === 'object') {
            globalObject = window;
        }
        else {
            globalObject = {};
        }
    }
    return globalObject;
}
function getLocationOrigin() {
    return getLinkElementOrigin(window.location);
}
/**
 * IE fallback
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/origin
 */
function getLinkElementOrigin(element) {
    if (element.origin) {
        return element.origin;
    }
    var sanitizedHost = element.host.replace(/(:80|:443)$/, '');
    return element.protocol + "//" + sanitizedHost;
}
function findCommaSeparatedValue(rawString, name) {
    var regex = new RegExp("(?:^|;)\\s*" + name + "\\s*=\\s*([^;]+)");
    var matches = regex.exec(rawString);
    return matches ? matches[1] : undefined;
}
function safeTruncate(candidate, length) {
    var lastChar = candidate.charCodeAt(length - 1);
    // check if it is the high part of a surrogate pair
    if (lastChar >= 0xd800 && lastChar <= 0xdbff) {
        return candidate.slice(0, length + 1);
    }
    return candidate.slice(0, length);
}
/**
 * Add an event listener to an event emitter object (Window, Element, mock object...).  This provides
 * a few conveniences compared to using `element.addEventListener` directly:
 *
 * * supports IE11 by: using an option object only if needed and emulating the `once` option
 *
 * * wraps the listener with a `monitor` function
 *
 * * returns a `stop` function to remove the listener
 */
function addEventListener(emitter, event, listener, options) {
    return addEventListeners(emitter, [event], listener, options);
}
/**
 * Add event listeners to an event emitter object (Window, Element, mock object...).  This provides
 * a few conveniences compared to using `element.addEventListener` directly:
 *
 * * supports IE11 by: using an option object only if needed and emulating the `once` option
 *
 * * wraps the listener with a `monitor` function
 *
 * * returns a `stop` function to remove the listener
 *
 * * with `once: true`, the listener will be called at most once, even if different events are listened
 */
function addEventListeners(emitter, events, listener, _a) {
    var _b = _a === void 0 ? {} : _a, once = _b.once, capture = _b.capture, passive = _b.passive;
    var wrappedListener = Object(_domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_0__["monitor"])(once
        ? function (event) {
            stop();
            listener(event);
        }
        : listener);
    var options = passive ? { capture: capture, passive: passive } : capture;
    events.forEach(function (event) { return emitter.addEventListener(event, wrappedListener, options); });
    var stop = function () { return events.forEach(function (event) { return emitter.removeEventListener(event, wrappedListener, options); }); };
    return {
        stop: stop,
    };
}
function runOnReadyState(expectedReadyState, callback) {
    if (document.readyState === expectedReadyState || document.readyState === 'complete') {
        callback();
    }
    else {
        var eventName = expectedReadyState === 'complete' ? "load" /* LOAD */ : "DOMContentLoaded" /* DOM_CONTENT_LOADED */;
        addEventListener(window, eventName, callback, { once: true });
    }
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/transport/transport.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/transport/transport.js ***!
  \*********************************************************************************************************************************************/
/*! exports provided: HttpRequest, Batch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HttpRequest", function() { return HttpRequest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Batch", function() { return Batch; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./.yarn/cache/tslib-npm-1.14.1-102499115e-dbe628ef87.zip/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _tools_timeUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/timeUtils */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/timeUtils.js");
/* harmony import */ var _tools_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/utils */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/tools/utils.js");
/* harmony import */ var _domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../domain/internalMonitoring */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/domain/internalMonitoring.js");




// https://en.wikipedia.org/wiki/UTF-8
var HAS_MULTI_BYTES_CHARACTERS = /[^\u0000-\u007F]/;
/**
 * Use POST request without content type to:
 * - avoid CORS preflight requests
 * - allow usage of sendBeacon
 *
 * multiple elements are sent separated by \n in order
 * to be parsed correctly without content type header
 */
var HttpRequest = /** @class */ (function () {
    function HttpRequest(endpointUrl, bytesLimit, withBatchTime) {
        if (withBatchTime === void 0) { withBatchTime = false; }
        this.endpointUrl = endpointUrl;
        this.bytesLimit = bytesLimit;
        this.withBatchTime = withBatchTime;
    }
    HttpRequest.prototype.send = function (data, size) {
        var url = this.withBatchTime ? addBatchTime(this.endpointUrl) : this.endpointUrl;
        if (navigator.sendBeacon && size < this.bytesLimit) {
            try {
                var isQueued = navigator.sendBeacon(url, data);
                if (isQueued) {
                    return;
                }
            }
            catch (e) {
                reportBeaconError(e);
            }
        }
        var request = new XMLHttpRequest();
        request.open('POST', url, true);
        request.send(data);
    };
    return HttpRequest;
}());

function addBatchTime(url) {
    return "" + url + (url.indexOf('?') === -1 ? '?' : '&') + "batch_time=" + new Date().getTime() + "&m_time=" + Object(_tools_timeUtils__WEBPACK_IMPORTED_MODULE_1__["getTimeStamp"])(Object(_tools_timeUtils__WEBPACK_IMPORTED_MODULE_1__["relativeNow"])());
}
var hasReportedBeaconError = false;
function reportBeaconError(e) {
    if (!hasReportedBeaconError) {
        hasReportedBeaconError = true;
        Object(_domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_3__["addErrorToMonitoringBatch"])(e);
    }
}
var Batch = /** @class */ (function () {
    function Batch(request, maxSize, bytesLimit, maxMessageSize, flushTimeout, beforeUnloadCallback) {
        if (beforeUnloadCallback === void 0) { beforeUnloadCallback = _tools_utils__WEBPACK_IMPORTED_MODULE_2__["noop"]; }
        this.request = request;
        this.maxSize = maxSize;
        this.bytesLimit = bytesLimit;
        this.maxMessageSize = maxMessageSize;
        this.flushTimeout = flushTimeout;
        this.beforeUnloadCallback = beforeUnloadCallback;
        this.pushOnlyBuffer = [];
        this.upsertBuffer = {};
        this.bufferBytesSize = 0;
        this.bufferMessageCount = 0;
        this.flushOnVisibilityHidden();
        this.flushPeriodically();
    }
    Batch.prototype.add = function (message) {
        this.addOrUpdate(message);
    };
    Batch.prototype.upsert = function (message, key) {
        this.addOrUpdate(message, key);
    };
    Batch.prototype.flush = function () {
        if (this.bufferMessageCount !== 0) {
            var messages = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__spreadArrays"])(this.pushOnlyBuffer, Object(_tools_utils__WEBPACK_IMPORTED_MODULE_2__["objectValues"])(this.upsertBuffer));
            this.request.send(messages.join('\n'), this.bufferBytesSize);
            this.pushOnlyBuffer = [];
            this.upsertBuffer = {};
            this.bufferBytesSize = 0;
            this.bufferMessageCount = 0;
        }
    };
    Batch.prototype.sizeInBytes = function (candidate) {
        // Accurate byte size computations can degrade performances when there is a lot of events to process
        if (!HAS_MULTI_BYTES_CHARACTERS.test(candidate)) {
            return candidate.length;
        }
        if (window.TextEncoder !== undefined) {
            return new TextEncoder().encode(candidate).length;
        }
        return new Blob([candidate]).size;
    };
    Batch.prototype.addOrUpdate = function (message, key) {
        var _a = this.process(message), processedMessage = _a.processedMessage, messageBytesSize = _a.messageBytesSize;
        if (messageBytesSize >= this.maxMessageSize) {
            console.warn("Discarded a message whose size was bigger than the maximum allowed size " + this.maxMessageSize + "KB.");
            return;
        }
        if (this.hasMessageFor(key)) {
            this.remove(key);
        }
        if (this.willReachedBytesLimitWith(messageBytesSize)) {
            this.flush();
        }
        this.push(processedMessage, messageBytesSize, key);
        if (this.isFull()) {
            this.flush();
        }
    };
    Batch.prototype.process = function (message) {
        var processedMessage = Object(_tools_utils__WEBPACK_IMPORTED_MODULE_2__["jsonStringify"])(message);
        var messageBytesSize = this.sizeInBytes(processedMessage);
        return { processedMessage: processedMessage, messageBytesSize: messageBytesSize };
    };
    Batch.prototype.push = function (processedMessage, messageBytesSize, key) {
        if (this.bufferMessageCount > 0) {
            // \n separator at serialization
            this.bufferBytesSize += 1;
        }
        if (key !== undefined) {
            this.upsertBuffer[key] = processedMessage;
        }
        else {
            this.pushOnlyBuffer.push(processedMessage);
        }
        this.bufferBytesSize += messageBytesSize;
        this.bufferMessageCount += 1;
    };
    Batch.prototype.remove = function (key) {
        var removedMessage = this.upsertBuffer[key];
        delete this.upsertBuffer[key];
        var messageBytesSize = this.sizeInBytes(removedMessage);
        this.bufferBytesSize -= messageBytesSize;
        this.bufferMessageCount -= 1;
        if (this.bufferMessageCount > 0) {
            this.bufferBytesSize -= 1;
        }
    };
    Batch.prototype.hasMessageFor = function (key) {
        return key !== undefined && this.upsertBuffer[key] !== undefined;
    };
    Batch.prototype.willReachedBytesLimitWith = function (messageBytesSize) {
        // byte of the separator at the end of the message
        return this.bufferBytesSize + messageBytesSize + 1 >= this.bytesLimit;
    };
    Batch.prototype.isFull = function () {
        return this.bufferMessageCount === this.maxSize || this.bufferBytesSize >= this.bytesLimit;
    };
    Batch.prototype.flushPeriodically = function () {
        var _this = this;
        setTimeout(Object(_domain_internalMonitoring__WEBPACK_IMPORTED_MODULE_3__["monitor"])(function () {
            _this.flush();
            _this.flushPeriodically();
        }), this.flushTimeout);
    };
    Batch.prototype.flushOnVisibilityHidden = function () {
        var _this = this;
        /**
         * With sendBeacon, requests are guaranteed to be successfully sent during document unload
         */
        // @ts-ignore this function is not always defined
        if (navigator.sendBeacon) {
            /**
             * beforeunload is called before visibilitychange
             * register first to be sure to be called before flush on beforeunload
             * caveat: unload can still be canceled by another listener
             */
            Object(_tools_utils__WEBPACK_IMPORTED_MODULE_2__["addEventListener"])(window, "beforeunload" /* BEFORE_UNLOAD */, this.beforeUnloadCallback);
            /**
             * Only event that guarantee to fire on mobile devices when the page transitions to background state
             * (e.g. when user switches to a different application, goes to homescreen, etc), or is being unloaded.
             */
            Object(_tools_utils__WEBPACK_IMPORTED_MODULE_2__["addEventListener"])(document, "visibilitychange" /* VISIBILITY_CHANGE */, function () {
                if (document.visibilityState === 'hidden') {
                    _this.flush();
                }
            });
            /**
             * Safari does not support yet to send a request during:
             * - a visibility change during doc unload (cf: https://bugs.webkit.org/show_bug.cgi?id=194897)
             * - a page hide transition (cf: https://bugs.webkit.org/show_bug.cgi?id=188329)
             */
            Object(_tools_utils__WEBPACK_IMPORTED_MODULE_2__["addEventListener"])(window, "beforeunload" /* BEFORE_UNLOAD */, function () { return _this.flush(); });
        }
    };
    return Batch;
}());

//# sourceMappingURL=transport.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/boot/buildEnv.js":
/*!***********************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/boot/buildEnv.js ***!
  \***********************************************************************************************************************************************/
/*! exports provided: buildEnv */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildEnv", function() { return buildEnv; });
var buildEnv = {
    buildMode: 'release',
    datacenter: 'us',
    sdkVersion: '2.7.4',
};
//# sourceMappingURL=buildEnv.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/boot/rum.js":
/*!******************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/boot/rum.js ***!
  \******************************************************************************************************************************************/
/*! exports provided: startRum, startRumEventCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startRum", function() { return startRum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startRumEventCollection", function() { return startRumEventCollection; });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");
/* harmony import */ var _browser_domMutationCollection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../browser/domMutationCollection */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/browser/domMutationCollection.js");
/* harmony import */ var _browser_performanceCollection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../browser/performanceCollection */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/browser/performanceCollection.js");
/* harmony import */ var _domain_assembly__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../domain/assembly */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/assembly.js");
/* harmony import */ var _domain_internalContext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../domain/internalContext */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/internalContext.js");
/* harmony import */ var _domain_lifeCycle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../domain/lifeCycle */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js");
/* harmony import */ var _domain_parentContexts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../domain/parentContexts */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/parentContexts.js");
/* harmony import */ var _domain_requestCollection__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../domain/requestCollection */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/requestCollection.js");
/* harmony import */ var _domain_rumEventsCollection_action_actionCollection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../domain/rumEventsCollection/action/actionCollection */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/action/actionCollection.js");
/* harmony import */ var _domain_rumEventsCollection_error_errorCollection__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../domain/rumEventsCollection/error/errorCollection */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/error/errorCollection.js");
/* harmony import */ var _domain_rumEventsCollection_longTask_longTaskCollection__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../domain/rumEventsCollection/longTask/longTaskCollection */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/longTask/longTaskCollection.js");
/* harmony import */ var _domain_rumEventsCollection_resource_resourceCollection__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../domain/rumEventsCollection/resource/resourceCollection */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/resource/resourceCollection.js");
/* harmony import */ var _domain_rumEventsCollection_view_viewCollection__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../domain/rumEventsCollection/view/viewCollection */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/view/viewCollection.js");
/* harmony import */ var _domain_rumSession__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../domain/rumSession */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumSession.js");
/* harmony import */ var _transport_batch__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../transport/batch */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/transport/batch.js");
/* harmony import */ var _buildEnv__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./buildEnv */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/boot/buildEnv.js");
















function startRum(userConfiguration, getCommonContext) {
    var lifeCycle = new _domain_lifeCycle__WEBPACK_IMPORTED_MODULE_5__["LifeCycle"]();
    var _a = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["commonInit"])(userConfiguration, _buildEnv__WEBPACK_IMPORTED_MODULE_15__["buildEnv"]), configuration = _a.configuration, internalMonitoring = _a.internalMonitoring;
    var session = Object(_domain_rumSession__WEBPACK_IMPORTED_MODULE_13__["startRumSession"])(configuration, lifeCycle);
    internalMonitoring.setExternalContextProvider(function () {
        return Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["combine"])({
            application_id: userConfiguration.applicationId,
        }, parentContexts.findView(), getCommonContext().context);
    });
    var _b = startRumEventCollection(userConfiguration.applicationId, location, lifeCycle, configuration, session, getCommonContext), parentContexts = _b.parentContexts, addError = _b.addError, addAction = _b.addAction, addTiming = _b.addTiming;
    Object(_domain_requestCollection__WEBPACK_IMPORTED_MODULE_7__["startRequestCollection"])(lifeCycle, configuration);
    Object(_browser_performanceCollection__WEBPACK_IMPORTED_MODULE_2__["startPerformanceCollection"])(lifeCycle, configuration);
    Object(_browser_domMutationCollection__WEBPACK_IMPORTED_MODULE_1__["startDOMMutationCollection"])(lifeCycle);
    var internalContext = Object(_domain_internalContext__WEBPACK_IMPORTED_MODULE_4__["startInternalContext"])(userConfiguration.applicationId, session, parentContexts);
    return {
        addAction: addAction,
        addError: addError,
        addTiming: addTiming,
        configuration: configuration,
        lifeCycle: lifeCycle,
        parentContexts: parentContexts,
        session: session,
        getInternalContext: internalContext.get,
    };
}
function startRumEventCollection(applicationId, location, lifeCycle, configuration, session, getCommonContext) {
    var parentContexts = Object(_domain_parentContexts__WEBPACK_IMPORTED_MODULE_6__["startParentContexts"])(lifeCycle, session);
    var batch = Object(_transport_batch__WEBPACK_IMPORTED_MODULE_14__["startRumBatch"])(configuration, lifeCycle);
    Object(_domain_assembly__WEBPACK_IMPORTED_MODULE_3__["startRumAssembly"])(applicationId, configuration, lifeCycle, session, parentContexts, getCommonContext);
    Object(_domain_rumEventsCollection_longTask_longTaskCollection__WEBPACK_IMPORTED_MODULE_10__["startLongTaskCollection"])(lifeCycle);
    Object(_domain_rumEventsCollection_resource_resourceCollection__WEBPACK_IMPORTED_MODULE_11__["startResourceCollection"])(lifeCycle, session);
    var _a = Object(_domain_rumEventsCollection_view_viewCollection__WEBPACK_IMPORTED_MODULE_12__["startViewCollection"])(lifeCycle, location), addTiming = _a.addTiming, stopViewCollection = _a.stop;
    var addError = Object(_domain_rumEventsCollection_error_errorCollection__WEBPACK_IMPORTED_MODULE_9__["startErrorCollection"])(lifeCycle, configuration).addError;
    var addAction = Object(_domain_rumEventsCollection_action_actionCollection__WEBPACK_IMPORTED_MODULE_8__["startActionCollection"])(lifeCycle, configuration).addAction;
    return {
        addAction: addAction,
        addError: addError,
        parentContexts: parentContexts,
        addTiming: addTiming,
        stop: function () {
            stopViewCollection();
            // prevent batch from previous tests to keep running and send unwanted requests
            // could be replaced by stopping all the component when they will all have a stop method
            batch.stop();
        },
    };
}
//# sourceMappingURL=rum.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/boot/rumPublicApi.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/boot/rumPublicApi.js ***!
  \***************************************************************************************************************************************************/
/*! exports provided: makeRumPublicApi */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeRumPublicApi", function() { return makeRumPublicApi; });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");
/* harmony import */ var _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rawRumEvent.types */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/rawRumEvent.types.js");


function makeRumPublicApi(startRumImpl) {
    var isAlreadyInitialized = false;
    var globalContextManager = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["createContextManager"])();
    var user = {};
    var getInternalContextStrategy = function () { return undefined; };
    var beforeInitAddTiming = new _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["BoundedBuffer"]();
    var addTimingStrategy = function (name) {
        beforeInitAddTiming.add([name, Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["relativeNow"])()]);
    };
    var beforeInitAddAction = new _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["BoundedBuffer"]();
    var addActionStrategy = function (action) {
        beforeInitAddAction.add([action, clonedCommonContext()]);
    };
    var beforeInitAddError = new _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["BoundedBuffer"]();
    var addErrorStrategy = function (providedError) {
        beforeInitAddError.add([providedError, clonedCommonContext()]);
    };
    function clonedCommonContext() {
        return Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["deepClone"])({
            context: globalContextManager.get(),
            user: user,
        });
    }
    var rumPublicApi = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["makePublicApi"])({
        init: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["monitor"])(function (userConfiguration) {
            var _a;
            if (!Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["checkCookiesAuthorized"])(Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["buildCookieOptions"])(userConfiguration)) ||
                !Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["checkIsNotLocalFile"])() ||
                !canInitRum(userConfiguration)) {
                return;
            }
            if (userConfiguration.publicApiKey) {
                userConfiguration.clientToken = userConfiguration.publicApiKey;
            }
            ;
            (_a = startRumImpl(userConfiguration, function () { return ({
                user: user,
                context: globalContextManager.get(),
            }); }), addActionStrategy = _a.addAction, addErrorStrategy = _a.addError, addTimingStrategy = _a.addTiming, getInternalContextStrategy = _a.getInternalContext);
            beforeInitAddAction.drain(function (_a) {
                var action = _a[0], commonContext = _a[1];
                return addActionStrategy(action, commonContext);
            });
            beforeInitAddError.drain(function (_a) {
                var error = _a[0], commonContext = _a[1];
                return addErrorStrategy(error, commonContext);
            });
            beforeInitAddTiming.drain(function (_a) {
                var name = _a[0], time = _a[1];
                return addTimingStrategy(name, time);
            });
            isAlreadyInitialized = true;
        }),
        addRumGlobalContext: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["monitor"])(globalContextManager.add),
        removeRumGlobalContext: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["monitor"])(globalContextManager.remove),
        getRumGlobalContext: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["monitor"])(globalContextManager.get),
        setRumGlobalContext: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["monitor"])(globalContextManager.set),
        getInternalContext: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["monitor"])(function (startTime) { return getInternalContextStrategy(startTime); }),
        addAction: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["monitor"])(function (name, context) {
            addActionStrategy({
                name: name,
                context: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["deepClone"])(context),
                startTime: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["relativeNow"])(),
                type: _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_1__["ActionType"].CUSTOM,
            });
        }),
        /**
         * @deprecated use addAction instead
         */
        addUserAction: function (name, context) {
            rumPublicApi.addAction(name, context);
        },
        addError: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["monitor"])(function (error, context, source) {
            if (source === void 0) { source = _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["ErrorSource"].CUSTOM; }
            var checkedSource;
            if (source === _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["ErrorSource"].CUSTOM || source === _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["ErrorSource"].NETWORK || source === _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["ErrorSource"].SOURCE) {
                checkedSource = source;
            }
            else {
                console.error("DD_RUM.addError: Invalid source '" + source + "'");
                checkedSource = _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["ErrorSource"].CUSTOM;
            }
            addErrorStrategy({
                error: error,
                context: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["deepClone"])(context),
                source: checkedSource,
                startTime: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["relativeNow"])(),
            });
        }),
        addTiming: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["monitor"])(function (name) {
            addTimingStrategy(name);
        }),
        setUser: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["monitor"])(function (newUser) {
            var sanitizedUser = sanitizeUser(newUser);
            if (sanitizedUser) {
                user = sanitizedUser;
            }
            else {
                console.error('Unsupported user:', newUser);
            }
        }),
    });
    return rumPublicApi;
    function sanitizeUser(newUser) {
        if (typeof newUser !== 'object' || !newUser) {
            return;
        }
        var result = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["deepClone"])(newUser);
        if ('id' in result) {
            result.id = String(result.id);
        }
        if ('name' in result) {
            result.name = String(result.name);
        }
        if ('email' in result) {
            result.email = String(result.email);
        }
        return result;
    }
    function canInitRum(userConfiguration) {
        if (isAlreadyInitialized) {
            if (!userConfiguration.silentMultipleInit) {
                console.error('DD_RUM is already initialized.');
            }
            return false;
        }
        if (!userConfiguration || (!userConfiguration.clientToken && !userConfiguration.publicApiKey)) {
            console.error('Client Token is not configured, we will not send any data.');
            return false;
        }
        if (!userConfiguration.applicationId) {
            console.error('Application ID is not configured, no RUM data will be collected.');
            return false;
        }
        if (userConfiguration.sampleRate !== undefined && !Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["isPercentage"])(userConfiguration.sampleRate)) {
            console.error('Sample Rate should be a number between 0 and 100');
            return false;
        }
        if (userConfiguration.resourceSampleRate !== undefined && !Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["isPercentage"])(userConfiguration.resourceSampleRate)) {
            console.error('Resource Sample Rate should be a number between 0 and 100');
            return false;
        }
        if (Array.isArray(userConfiguration.allowedTracingOrigins) &&
            userConfiguration.allowedTracingOrigins.length !== 0 &&
            userConfiguration.service === undefined) {
            console.error('Service need to be configured when tracing is enabled');
            return false;
        }
        return true;
    }
}
//# sourceMappingURL=rumPublicApi.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/browser/domMutationCollection.js":
/*!***************************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/browser/domMutationCollection.js ***!
  \***************************************************************************************************************************************************************/
/*! exports provided: startDOMMutationCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startDOMMutationCollection", function() { return startDOMMutationCollection; });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");
/* harmony import */ var _domain_lifeCycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../domain/lifeCycle */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js");


function getMutationObserverConstructor() {
    var constructor;
    var browserWindow = window;
    // Angular uses Zone.js to provide a context persisting accross async tasks.  Zone.js replaces the
    // global MutationObserver constructor with a patched version to support the context propagation.
    // There is an ongoing issue[1][2] with this setup when using a MutationObserver within a Angular
    // component: on some occasions, the callback is being called in an infinite loop, causing the
    // page to freeze (even if the callback is completely empty).
    //
    // To work around this issue, we are using the Zone __symbol__ API to get the original, unpatched
    // MutationObserver constructor.
    //
    // [1] https://github.com/angular/angular/issues/26948
    // [2] https://github.com/angular/angular/issues/31712
    if (browserWindow.Zone) {
        // eslint-disable-next-line no-underscore-dangle
        var symbol = browserWindow.Zone.__symbol__('MutationObserver');
        constructor = browserWindow[symbol];
    }
    if (!constructor) {
        constructor = browserWindow.MutationObserver;
    }
    return constructor;
}
function startDOMMutationCollection(lifeCycle) {
    var observer;
    var MutationObserver = getMutationObserverConstructor();
    if (MutationObserver) {
        observer = new MutationObserver(Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["monitor"])(function () {
            lifeCycle.notify(_domain_lifeCycle__WEBPACK_IMPORTED_MODULE_1__["LifeCycleEventType"].DOM_MUTATED);
        }));
        observer.observe(document.documentElement, {
            attributes: true,
            characterData: true,
            childList: true,
            subtree: true,
        });
    }
    return {
        stop: function () {
            if (observer) {
                observer.disconnect();
            }
        },
    };
}
//# sourceMappingURL=domMutationCollection.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/browser/performanceCollection.js":
/*!***************************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/browser/performanceCollection.js ***!
  \***************************************************************************************************************************************************************/
/*! exports provided: supportPerformanceTimingEvent, startPerformanceCollection, retrieveInitialDocumentResourceTiming */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supportPerformanceTimingEvent", function() { return supportPerformanceTimingEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startPerformanceCollection", function() { return startPerformanceCollection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "retrieveInitialDocumentResourceTiming", function() { return retrieveInitialDocumentResourceTiming; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./.yarn/cache/tslib-npm-1.14.1-102499115e-dbe628ef87.zip/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");
/* harmony import */ var _domain_lifeCycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../domain/lifeCycle */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js");
/* harmony import */ var _domain_rumEventsCollection_resource_resourceUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../domain/rumEventsCollection/resource/resourceUtils */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/resource/resourceUtils.js");
/* harmony import */ var _domain_tracing_getDocumentTraceId__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../domain/tracing/getDocumentTraceId */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/tracing/getDocumentTraceId.js");





function supportPerformanceObject() {
    return window.performance !== undefined && 'getEntries' in performance;
}
function supportPerformanceTimingEvent(entryType) {
    return (window.PerformanceObserver &&
        PerformanceObserver.supportedEntryTypes !== undefined &&
        PerformanceObserver.supportedEntryTypes.includes(entryType));
}
function startPerformanceCollection(lifeCycle, configuration) {
    retrieveInitialDocumentResourceTiming(function (timing) {
        handleRumPerformanceEntry(lifeCycle, configuration, timing);
    });
    if (supportPerformanceObject()) {
        handlePerformanceEntries(lifeCycle, configuration, performance.getEntries());
    }
    if (window.PerformanceObserver) {
        var observer = new PerformanceObserver(Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["monitor"])(function (entries) {
            return handlePerformanceEntries(lifeCycle, configuration, entries.getEntries());
        }));
        var entryTypes = [
            'resource',
            'navigation',
            'longtask',
            'paint',
            'largest-contentful-paint',
            'first-input',
            'layout-shift',
        ];
        observer.observe({ entryTypes: entryTypes });
        if (supportPerformanceObject() && 'addEventListener' in performance) {
            // https://bugzilla.mozilla.org/show_bug.cgi?id=1559377
            performance.addEventListener('resourcetimingbufferfull', function () {
                performance.clearResourceTimings();
            });
        }
    }
    if (!supportPerformanceTimingEvent('navigation')) {
        retrieveNavigationTiming(function (timing) {
            handleRumPerformanceEntry(lifeCycle, configuration, timing);
        });
    }
    if (!supportPerformanceTimingEvent('first-input')) {
        retrieveFirstInputTiming(function (timing) {
            handleRumPerformanceEntry(lifeCycle, configuration, timing);
        });
    }
}
function retrieveInitialDocumentResourceTiming(callback) {
    Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["runOnReadyState"])('interactive', function () {
        var timing;
        var forcedAttributes = {
            entryType: 'resource',
            initiatorType: _domain_rumEventsCollection_resource_resourceUtils__WEBPACK_IMPORTED_MODULE_3__["FAKE_INITIAL_DOCUMENT"],
            traceId: Object(_domain_tracing_getDocumentTraceId__WEBPACK_IMPORTED_MODULE_4__["getDocumentTraceId"])(document),
        };
        if (supportPerformanceTimingEvent('navigation') && performance.getEntriesByType('navigation').length > 0) {
            var navigationEntry = performance.getEntriesByType('navigation')[0];
            timing = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, navigationEntry.toJSON()), forcedAttributes);
        }
        else {
            var relativePerformanceTiming = computeRelativePerformanceTiming();
            timing = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, relativePerformanceTiming), { decodedBodySize: 0, duration: relativePerformanceTiming.responseEnd, name: window.location.href, startTime: 0 }), forcedAttributes);
        }
        callback(timing);
    });
}
function retrieveNavigationTiming(callback) {
    function sendFakeTiming() {
        callback(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, computeRelativePerformanceTiming()), { entryType: 'navigation' }));
    }
    Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["runOnReadyState"])('complete', function () {
        // Send it a bit after the actual load event, so the "loadEventEnd" timing is accurate
        setTimeout(Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["monitor"])(sendFakeTiming));
    });
}
/**
 * first-input timing entry polyfill based on
 * https://github.com/GoogleChrome/web-vitals/blob/master/src/lib/polyfills/firstInputPolyfill.ts
 */
function retrieveFirstInputTiming(callback) {
    var startTimeStamp = Date.now();
    var timingSent = false;
    var removeEventListeners = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["addEventListeners"])(window, ["click" /* CLICK */, "mousedown" /* MOUSE_DOWN */, "keydown" /* KEY_DOWN */, "touchstart" /* TOUCH_START */, "pointerdown" /* POINTER_DOWN */], function (evt) {
        // Only count cancelable events, which should trigger behavior important to the user.
        if (!evt.cancelable) {
            return;
        }
        // This timing will be used to compute the "first Input delay", which is the delta between
        // when the system received the event (e.g. evt.timeStamp) and when it could run the callback
        // (e.g. performance.now()).
        var timing = {
            entryType: 'first-input',
            processingStart: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["relativeNow"])(),
            startTime: evt.timeStamp,
        };
        if (evt.type === "pointerdown" /* POINTER_DOWN */) {
            sendTimingIfPointerIsNotCancelled(timing);
        }
        else {
            sendTiming(timing);
        }
    }, { passive: true, capture: true }).stop;
    /**
     * Pointer events are a special case, because they can trigger main or compositor thread behavior.
     * We differentiate these cases based on whether or not we see a pointercancel event, which are
     * fired when we scroll. If we're scrolling we don't need to report input delay since FID excludes
     * scrolling and pinch/zooming.
     */
    function sendTimingIfPointerIsNotCancelled(timing) {
        Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["addEventListeners"])(window, ["pointerup" /* POINTER_UP */, "pointercancel" /* POINTER_CANCEL */], function (event) {
            if (event.type === "pointerup" /* POINTER_UP */) {
                sendTiming(timing);
            }
        }, { once: true });
    }
    function sendTiming(timing) {
        if (!timingSent) {
            timingSent = true;
            removeEventListeners();
            // In some cases the recorded delay is clearly wrong, e.g. it's negative or it's larger than
            // the time between now and when the page was loaded.
            // - https://github.com/GoogleChromeLabs/first-input-delay/issues/4
            // - https://github.com/GoogleChromeLabs/first-input-delay/issues/6
            // - https://github.com/GoogleChromeLabs/first-input-delay/issues/7
            var delay = timing.processingStart - timing.startTime;
            if (delay >= 0 && delay < Date.now() - startTimeStamp) {
                callback(timing);
            }
        }
    }
}
function computeRelativePerformanceTiming() {
    var result = {};
    var timing = performance.timing;
    for (var key in timing) {
        if (Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["isNumber"])(timing[key])) {
            var numberKey = key;
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
            var timingElement = timing[numberKey];
            result[numberKey] = timingElement === 0 ? 0 : Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["getRelativeTime"])(timingElement);
        }
    }
    return result;
}
function handlePerformanceEntries(lifeCycle, configuration, entries) {
    entries.forEach(function (entry) {
        if (entry.entryType === 'resource' ||
            entry.entryType === 'navigation' ||
            entry.entryType === 'paint' ||
            entry.entryType === 'longtask' ||
            entry.entryType === 'largest-contentful-paint' ||
            entry.entryType === 'first-input' ||
            entry.entryType === 'layout-shift') {
            handleRumPerformanceEntry(lifeCycle, configuration, entry);
        }
    });
}
function handleRumPerformanceEntry(lifeCycle, configuration, entry) {
    if (isIncompleteNavigation(entry) || isForbiddenResource(configuration, entry)) {
        return;
    }
    lifeCycle.notify(_domain_lifeCycle__WEBPACK_IMPORTED_MODULE_2__["LifeCycleEventType"].PERFORMANCE_ENTRY_COLLECTED, entry);
}
function isIncompleteNavigation(entry) {
    return entry.entryType === 'navigation' && entry.loadEventEnd <= 0;
}
function isForbiddenResource(configuration, entry) {
    return entry.entryType === 'resource' && !Object(_domain_rumEventsCollection_resource_resourceUtils__WEBPACK_IMPORTED_MODULE_3__["isAllowedRequestUrl"])(configuration, entry.name);
}
//# sourceMappingURL=performanceCollection.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/assembly.js":
/*!*************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/assembly.js ***!
  \*************************************************************************************************************************************************/
/*! exports provided: startRumAssembly */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startRumAssembly", function() { return startRumAssembly; });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");
/* harmony import */ var _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rawRumEvent.types */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/rawRumEvent.types.js");
/* harmony import */ var _lifeCycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lifeCycle */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js");



var SessionType;
(function (SessionType) {
    SessionType["SYNTHETICS"] = "synthetics";
    SessionType["USER"] = "user";
})(SessionType || (SessionType = {}));
var FIELDS_WITH_SENSITIVE_DATA = [
    'view.url',
    'view.referrer',
    'action.target.name',
    'error.message',
    'error.stack',
    'error.resource.url',
    'resource.url',
];
function startRumAssembly(applicationId, configuration, lifeCycle, session, parentContexts, getCommonContext) {
    lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_2__["LifeCycleEventType"].RAW_RUM_EVENT_COLLECTED, function (_a) {
        var startTime = _a.startTime, rawRumEvent = _a.rawRumEvent, savedCommonContext = _a.savedCommonContext, customerContext = _a.customerContext;
        var viewContext = parentContexts.findView(startTime);
        if (session.isTracked() && viewContext && viewContext.session.id) {
            var actionContext = parentContexts.findAction(startTime);
            var commonContext = savedCommonContext || getCommonContext();
            var rumContext = {
                _dd: {
                    format_version: 2,
                },
                application: {
                    id: applicationId,
                },
                date: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["timeStampNow"])(),
                service: configuration.service,
                session: {
                    // must be computed on each event because synthetics instrumentation can be done after sdk execution
                    // cf https://github.com/puppeteer/puppeteer/issues/3667
                    type: getSessionType(),
                },
            };
            var serverRumEvent = (needToAssembleWithAction(rawRumEvent)
                ? Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["combine"])(rumContext, viewContext, actionContext, rawRumEvent)
                : Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["combine"])(rumContext, viewContext, rawRumEvent));
            var context = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["combine"])(commonContext.context, customerContext);
            if (!Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["isEmptyObject"])(context)) {
                serverRumEvent.context = context;
            }
            if (!('has_replay' in serverRumEvent.session)) {
                ;
                serverRumEvent.session.has_replay = commonContext.hasReplay;
            }
            if (!Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["isEmptyObject"])(commonContext.user)) {
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
                ;
                serverRumEvent.usr = commonContext.user;
            }
            if (shouldSend(serverRumEvent, configuration.beforeSend)) {
                lifeCycle.notify(_lifeCycle__WEBPACK_IMPORTED_MODULE_2__["LifeCycleEventType"].RUM_EVENT_COLLECTED, serverRumEvent);
            }
        }
    });
}
function shouldSend(event, beforeSend) {
    if (beforeSend) {
        var result = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["limitModification"])(event, FIELDS_WITH_SENSITIVE_DATA, beforeSend);
        if (result === false && event.type !== _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_1__["RumEventType"].VIEW) {
            return false;
        }
        if (result === false) {
            console.warn("Can't dismiss view events using beforeSend!");
        }
    }
    return true;
}
function needToAssembleWithAction(event) {
    return [_rawRumEvent_types__WEBPACK_IMPORTED_MODULE_1__["RumEventType"].ERROR, _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_1__["RumEventType"].RESOURCE, _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_1__["RumEventType"].LONG_TASK].indexOf(event.type) !== -1;
}
function getSessionType() {
    // eslint-disable-next-line no-underscore-dangle
    return window._DATADOG_SYNTHETICS_BROWSER === undefined ? SessionType.USER : SessionType.SYNTHETICS;
}
//# sourceMappingURL=assembly.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/internalContext.js":
/*!********************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/internalContext.js ***!
  \********************************************************************************************************************************************************/
/*! exports provided: startInternalContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startInternalContext", function() { return startInternalContext; });
/**
 * Internal context keep returning v1 format
 * to not break compatibility with logs data format
 */
function startInternalContext(applicationId, session, parentContexts) {
    return {
        get: function (startTime) {
            var viewContext = parentContexts.findView(startTime);
            if (session.isTracked() && viewContext && viewContext.session.id) {
                var actionContext = parentContexts.findAction(startTime);
                return {
                    application_id: applicationId,
                    session_id: viewContext.session.id,
                    user_action: actionContext
                        ? {
                            id: actionContext.action.id,
                        }
                        : undefined,
                    view: viewContext.view,
                };
            }
        },
    };
}
//# sourceMappingURL=internalContext.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js ***!
  \**************************************************************************************************************************************************/
/*! exports provided: LifeCycleEventType, LifeCycle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LifeCycleEventType", function() { return LifeCycleEventType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LifeCycle", function() { return LifeCycle; });
var LifeCycleEventType;
(function (LifeCycleEventType) {
    LifeCycleEventType[LifeCycleEventType["PERFORMANCE_ENTRY_COLLECTED"] = 0] = "PERFORMANCE_ENTRY_COLLECTED";
    LifeCycleEventType[LifeCycleEventType["AUTO_ACTION_CREATED"] = 1] = "AUTO_ACTION_CREATED";
    LifeCycleEventType[LifeCycleEventType["AUTO_ACTION_COMPLETED"] = 2] = "AUTO_ACTION_COMPLETED";
    LifeCycleEventType[LifeCycleEventType["AUTO_ACTION_DISCARDED"] = 3] = "AUTO_ACTION_DISCARDED";
    LifeCycleEventType[LifeCycleEventType["VIEW_CREATED"] = 4] = "VIEW_CREATED";
    LifeCycleEventType[LifeCycleEventType["VIEW_UPDATED"] = 5] = "VIEW_UPDATED";
    LifeCycleEventType[LifeCycleEventType["VIEW_ENDED"] = 6] = "VIEW_ENDED";
    LifeCycleEventType[LifeCycleEventType["REQUEST_STARTED"] = 7] = "REQUEST_STARTED";
    LifeCycleEventType[LifeCycleEventType["REQUEST_COMPLETED"] = 8] = "REQUEST_COMPLETED";
    LifeCycleEventType[LifeCycleEventType["SESSION_RENEWED"] = 9] = "SESSION_RENEWED";
    LifeCycleEventType[LifeCycleEventType["DOM_MUTATED"] = 10] = "DOM_MUTATED";
    LifeCycleEventType[LifeCycleEventType["BEFORE_UNLOAD"] = 11] = "BEFORE_UNLOAD";
    LifeCycleEventType[LifeCycleEventType["RAW_RUM_EVENT_COLLECTED"] = 12] = "RAW_RUM_EVENT_COLLECTED";
    LifeCycleEventType[LifeCycleEventType["RUM_EVENT_COLLECTED"] = 13] = "RUM_EVENT_COLLECTED";
    LifeCycleEventType[LifeCycleEventType["RECORD_STARTED"] = 14] = "RECORD_STARTED";
    LifeCycleEventType[LifeCycleEventType["RECORD_STOPPED"] = 15] = "RECORD_STOPPED";
})(LifeCycleEventType || (LifeCycleEventType = {}));
var LifeCycle = /** @class */ (function () {
    function LifeCycle() {
        this.callbacks = {};
    }
    LifeCycle.prototype.notify = function (eventType, data) {
        var eventCallbacks = this.callbacks[eventType];
        if (eventCallbacks) {
            eventCallbacks.forEach(function (callback) { return callback(data); });
        }
    };
    LifeCycle.prototype.subscribe = function (eventType, callback) {
        var _this = this;
        if (!this.callbacks[eventType]) {
            this.callbacks[eventType] = [];
        }
        this.callbacks[eventType].push(callback);
        return {
            unsubscribe: function () {
                _this.callbacks[eventType] = _this.callbacks[eventType].filter(function (other) { return callback !== other; });
            },
        };
    };
    return LifeCycle;
}());

//# sourceMappingURL=lifeCycle.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/parentContexts.js":
/*!*******************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/parentContexts.js ***!
  \*******************************************************************************************************************************************************/
/*! exports provided: VIEW_CONTEXT_TIME_OUT_DELAY, ACTION_CONTEXT_TIME_OUT_DELAY, CLEAR_OLD_CONTEXTS_INTERVAL, startParentContexts */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VIEW_CONTEXT_TIME_OUT_DELAY", function() { return VIEW_CONTEXT_TIME_OUT_DELAY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ACTION_CONTEXT_TIME_OUT_DELAY", function() { return ACTION_CONTEXT_TIME_OUT_DELAY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLEAR_OLD_CONTEXTS_INTERVAL", function() { return CLEAR_OLD_CONTEXTS_INTERVAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startParentContexts", function() { return startParentContexts; });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");
/* harmony import */ var _lifeCycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lifeCycle */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js");


var VIEW_CONTEXT_TIME_OUT_DELAY = _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["SESSION_TIME_OUT_DELAY"];
var ACTION_CONTEXT_TIME_OUT_DELAY = 5 * _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["ONE_MINUTE"]; // arbitrary
var CLEAR_OLD_CONTEXTS_INTERVAL = _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["ONE_MINUTE"];
function startParentContexts(lifeCycle, session) {
    var currentView;
    var currentAction;
    var currentSessionId;
    var previousViews = [];
    var previousActions = [];
    lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_1__["LifeCycleEventType"].VIEW_CREATED, function (currentContext) {
        if (currentView) {
            previousViews.unshift({
                context: buildCurrentViewContext(),
                endTime: currentContext.startTime,
                startTime: currentView.startTime,
            });
        }
        currentView = currentContext;
        currentSessionId = session.getId();
    });
    lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_1__["LifeCycleEventType"].VIEW_UPDATED, function (currentContext) {
        // A view can be updated after its end.  We have to ensure that the view being updated is the
        // most recently created.
        if (currentView.id === currentContext.id) {
            currentView = currentContext;
        }
    });
    lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_1__["LifeCycleEventType"].AUTO_ACTION_CREATED, function (currentContext) {
        currentAction = currentContext;
    });
    lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_1__["LifeCycleEventType"].AUTO_ACTION_COMPLETED, function (action) {
        if (currentAction) {
            previousActions.unshift({
                context: buildCurrentActionContext(),
                // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
                endTime: (currentAction.startTime + action.duration),
                startTime: currentAction.startTime,
            });
        }
        currentAction = undefined;
    });
    lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_1__["LifeCycleEventType"].AUTO_ACTION_DISCARDED, function () {
        currentAction = undefined;
    });
    lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_1__["LifeCycleEventType"].SESSION_RENEWED, function () {
        previousViews = [];
        previousActions = [];
        currentView = undefined;
        currentAction = undefined;
    });
    var clearOldContextsInterval = setInterval(Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["monitor"])(function () {
        clearOldContexts(previousViews, VIEW_CONTEXT_TIME_OUT_DELAY);
        clearOldContexts(previousActions, ACTION_CONTEXT_TIME_OUT_DELAY);
    }), CLEAR_OLD_CONTEXTS_INTERVAL);
    function clearOldContexts(previousContexts, timeOutDelay) {
        var oldTimeThreshold = performance.now() - timeOutDelay;
        while (previousContexts.length > 0 && previousContexts[previousContexts.length - 1].startTime < oldTimeThreshold) {
            previousContexts.pop();
        }
    }
    function buildCurrentViewContext() {
        return {
            session: {
                id: currentSessionId,
            },
            view: {
                id: currentView.id,
                name: currentView.name,
                referrer: currentView.referrer,
                url: currentView.location.href,
            },
        };
    }
    function buildCurrentActionContext() {
        return { action: { id: currentAction.id } };
    }
    function findContext(buildContext, previousContexts, currentContext, startTime) {
        if (startTime === undefined) {
            return currentContext ? buildContext() : undefined;
        }
        if (currentContext && startTime >= currentContext.startTime) {
            return buildContext();
        }
        for (var _i = 0, previousContexts_1 = previousContexts; _i < previousContexts_1.length; _i++) {
            var previousContext = previousContexts_1[_i];
            if (startTime > previousContext.endTime) {
                break;
            }
            if (startTime >= previousContext.startTime) {
                return previousContext.context;
            }
        }
        return undefined;
    }
    return {
        findAction: function (startTime) { return findContext(buildCurrentActionContext, previousActions, currentAction, startTime); },
        findView: function (startTime) { return findContext(buildCurrentViewContext, previousViews, currentView, startTime); },
        stop: function () {
            clearInterval(clearOldContextsInterval);
        },
    };
}
//# sourceMappingURL=parentContexts.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/requestCollection.js":
/*!**********************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/requestCollection.js ***!
  \**********************************************************************************************************************************************************/
/*! exports provided: startRequestCollection, trackXhr, trackFetch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startRequestCollection", function() { return startRequestCollection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackXhr", function() { return trackXhr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackFetch", function() { return trackFetch; });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");
/* harmony import */ var _lifeCycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lifeCycle */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js");
/* harmony import */ var _rumEventsCollection_resource_resourceUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rumEventsCollection/resource/resourceUtils */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/resource/resourceUtils.js");
/* harmony import */ var _tracing_tracer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tracing/tracer */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/tracing/tracer.js");




var nextRequestIndex = 1;
function startRequestCollection(lifeCycle, configuration) {
    var tracer = Object(_tracing_tracer__WEBPACK_IMPORTED_MODULE_3__["startTracer"])(configuration);
    trackXhr(lifeCycle, configuration, tracer);
    trackFetch(lifeCycle, configuration, tracer);
}
function trackXhr(lifeCycle, configuration, tracer) {
    var xhrProxy = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["startXhrProxy"])();
    xhrProxy.beforeSend(function (context, xhr) {
        if (Object(_rumEventsCollection_resource_resourceUtils__WEBPACK_IMPORTED_MODULE_2__["isAllowedRequestUrl"])(configuration, context.url)) {
            tracer.traceXhr(context, xhr);
            context.requestIndex = getNextRequestIndex();
            lifeCycle.notify(_lifeCycle__WEBPACK_IMPORTED_MODULE_1__["LifeCycleEventType"].REQUEST_STARTED, {
                requestIndex: context.requestIndex,
            });
        }
    });
    xhrProxy.onRequestComplete(function (context) {
        if (Object(_rumEventsCollection_resource_resourceUtils__WEBPACK_IMPORTED_MODULE_2__["isAllowedRequestUrl"])(configuration, context.url)) {
            tracer.clearTracingIfCancelled(context);
            lifeCycle.notify(_lifeCycle__WEBPACK_IMPORTED_MODULE_1__["LifeCycleEventType"].REQUEST_COMPLETED, {
                duration: context.duration,
                method: context.method,
                requestIndex: context.requestIndex,
                response: context.response,
                spanId: context.spanId,
                startTime: context.startTime,
                status: context.status,
                traceId: context.traceId,
                type: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["RequestType"].XHR,
                url: context.url,
            });
        }
    });
    return xhrProxy;
}
function trackFetch(lifeCycle, configuration, tracer) {
    var fetchProxy = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["startFetchProxy"])();
    fetchProxy.beforeSend(function (context) {
        if (Object(_rumEventsCollection_resource_resourceUtils__WEBPACK_IMPORTED_MODULE_2__["isAllowedRequestUrl"])(configuration, context.url)) {
            tracer.traceFetch(context);
            context.requestIndex = getNextRequestIndex();
            lifeCycle.notify(_lifeCycle__WEBPACK_IMPORTED_MODULE_1__["LifeCycleEventType"].REQUEST_STARTED, {
                requestIndex: context.requestIndex,
            });
        }
    });
    fetchProxy.onRequestComplete(function (context) {
        if (Object(_rumEventsCollection_resource_resourceUtils__WEBPACK_IMPORTED_MODULE_2__["isAllowedRequestUrl"])(configuration, context.url)) {
            tracer.clearTracingIfCancelled(context);
            lifeCycle.notify(_lifeCycle__WEBPACK_IMPORTED_MODULE_1__["LifeCycleEventType"].REQUEST_COMPLETED, {
                duration: context.duration,
                method: context.method,
                requestIndex: context.requestIndex,
                response: context.response,
                responseType: context.responseType,
                spanId: context.spanId,
                startTime: context.startTime,
                status: context.status,
                traceId: context.traceId,
                type: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["RequestType"].FETCH,
                url: context.url,
            });
        }
    });
    return fetchProxy;
}
function getNextRequestIndex() {
    var result = nextRequestIndex;
    nextRequestIndex += 1;
    return result;
}
//# sourceMappingURL=requestCollection.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/action/actionCollection.js":
/*!************************************************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/action/actionCollection.js ***!
  \************************************************************************************************************************************************************************************/
/*! exports provided: startActionCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startActionCollection", function() { return startActionCollection; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./.yarn/cache/tslib-npm-1.14.1-102499115e-dbe628ef87.zip/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");
/* harmony import */ var _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../rawRumEvent.types */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/rawRumEvent.types.js");
/* harmony import */ var _lifeCycle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lifeCycle */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js");
/* harmony import */ var _trackActions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./trackActions */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/action/trackActions.js");





function startActionCollection(lifeCycle, configuration) {
    lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_3__["LifeCycleEventType"].AUTO_ACTION_COMPLETED, function (action) {
        return lifeCycle.notify(_lifeCycle__WEBPACK_IMPORTED_MODULE_3__["LifeCycleEventType"].RAW_RUM_EVENT_COLLECTED, processAction(action));
    });
    if (configuration.trackInteractions) {
        Object(_trackActions__WEBPACK_IMPORTED_MODULE_4__["trackActions"])(lifeCycle);
    }
    return {
        addAction: function (action, savedCommonContext) {
            lifeCycle.notify(_lifeCycle__WEBPACK_IMPORTED_MODULE_3__["LifeCycleEventType"].RAW_RUM_EVENT_COLLECTED, Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({ savedCommonContext: savedCommonContext }, processAction(action)));
        },
    };
}
function processAction(action) {
    var autoActionProperties = isAutoAction(action)
        ? {
            action: {
                error: {
                    count: action.counts.errorCount,
                },
                id: action.id,
                loading_time: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["toServerDuration"])(action.duration),
                long_task: {
                    count: action.counts.longTaskCount,
                },
                resource: {
                    count: action.counts.resourceCount,
                },
            },
        }
        : undefined;
    var customerContext = !isAutoAction(action) ? action.context : undefined;
    var actionEvent = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["combine"])({
        action: {
            target: {
                name: action.name,
            },
            type: action.type,
        },
        date: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["getTimeStamp"])(action.startTime),
        type: _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_2__["RumEventType"].ACTION,
    }, autoActionProperties);
    return {
        customerContext: customerContext,
        rawRumEvent: actionEvent,
        startTime: action.startTime,
    };
}
function isAutoAction(action) {
    return action.type !== _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_2__["ActionType"].CUSTOM;
}
//# sourceMappingURL=actionCollection.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/action/getActionNameFromElement.js":
/*!********************************************************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/action/getActionNameFromElement.js ***!
  \********************************************************************************************************************************************************************************************/
/*! exports provided: getActionNameFromElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getActionNameFromElement", function() { return getActionNameFromElement; });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");

function getActionNameFromElement(element) {
    // Proceed to get the action name in two steps:
    // * first, get the name programmatically, explicitly defined by the user.
    // * then, use strategies that are known to return good results. Those strategies will be used on
    //   the element and a few parents, but it's likely that they won't succeed at all.
    // * if no name is found this way, use strategies returning less accurate names as a fallback.
    //   Those are much likely to succeed.
    return (getActionNameFromElementProgrammatically(element) ||
        getActionNameFromElementForStrategies(element, priorityStrategies) ||
        getActionNameFromElementForStrategies(element, fallbackStrategies) ||
        '');
}
/**
 * Get the action name from the attribute 'data-dd-action-name' on the element or any of its parent.
 */
var PROGRAMMATIC_ATTRIBUTE = 'data-dd-action-name';
function getActionNameFromElementProgrammatically(targetElement) {
    var elementWithAttribute;
    // We don't use getActionNameFromElementForStrategies here, because we want to consider all parents,
    // without limit. It is up to the user to declare a relevant naming strategy.
    // If available, use element.closest() to match get the attribute from the element or any of its
    // parent.  Else fallback to a more traditional implementation.
    if (supportsElementClosest()) {
        elementWithAttribute = targetElement.closest("[" + PROGRAMMATIC_ATTRIBUTE + "]");
    }
    else {
        var element = targetElement;
        while (element) {
            if (element.hasAttribute(PROGRAMMATIC_ATTRIBUTE)) {
                elementWithAttribute = element;
                break;
            }
            element = element.parentElement;
        }
    }
    if (!elementWithAttribute) {
        return;
    }
    var name = elementWithAttribute.getAttribute(PROGRAMMATIC_ATTRIBUTE);
    return truncate(normalizeWhitespace(name.trim()));
}
var priorityStrategies = [
    // associated LABEL text
    function (element) {
        // IE does not support element.labels, so we fallback to a CSS selector based on the element id
        // instead
        if (supportsLabelProperty()) {
            if ('labels' in element && element.labels && element.labels.length > 0) {
                return getTextualContent(element.labels[0]);
            }
        }
        else if (element.id) {
            var label = element.ownerDocument && element.ownerDocument.querySelector("label[for=\"" + element.id.replace('"', '\\"') + "\"]");
            return label && getTextualContent(label);
        }
    },
    // INPUT button (and associated) value
    function (element) {
        if (element.nodeName === 'INPUT') {
            var input = element;
            var type = input.getAttribute('type');
            if (type === 'button' || type === 'submit' || type === 'reset') {
                return input.value;
            }
        }
    },
    // BUTTON, LABEL or button-like element text
    function (element) {
        if (element.nodeName === 'BUTTON' || element.nodeName === 'LABEL' || element.getAttribute('role') === 'button') {
            return getTextualContent(element);
        }
    },
    function (element) { return element.getAttribute('aria-label'); },
    // associated element text designated by the aria-labelledby attribute
    function (element) {
        var labelledByAttribute = element.getAttribute('aria-labelledby');
        if (labelledByAttribute) {
            return labelledByAttribute
                .split(/\s+/)
                .map(function (id) { return getElementById(element, id); })
                .filter(function (label) { return Boolean(label); })
                .map(getTextualContent)
                .join(' ');
        }
    },
    function (element) { return element.getAttribute('alt'); },
    function (element) { return element.getAttribute('name'); },
    function (element) { return element.getAttribute('title'); },
    function (element) { return element.getAttribute('placeholder'); },
    // SELECT first OPTION text
    function (element) {
        if ('options' in element && element.options.length > 0) {
            return getTextualContent(element.options[0]);
        }
    },
];
var fallbackStrategies = [function (element) { return getTextualContent(element); }];
/**
 * Iterates over the target element and its parent, using the strategies list to get an action name.
 * Each strategies are applied on each element, stopping as soon as a non-empty value is returned.
 */
var MAX_PARENTS_TO_CONSIDER = 10;
function getActionNameFromElementForStrategies(targetElement, strategies) {
    var element = targetElement;
    var recursionCounter = 0;
    while (recursionCounter <= MAX_PARENTS_TO_CONSIDER &&
        element &&
        element.nodeName !== 'BODY' &&
        element.nodeName !== 'HTML' &&
        element.nodeName !== 'HEAD') {
        for (var _i = 0, strategies_1 = strategies; _i < strategies_1.length; _i++) {
            var strategy = strategies_1[_i];
            var name_1 = strategy(element);
            if (typeof name_1 === 'string') {
                var trimmedName = name_1.trim();
                if (trimmedName) {
                    return truncate(normalizeWhitespace(trimmedName));
                }
            }
        }
        // Consider a FORM as a contextual limit to get the action name.  This is experimental and may
        // be reconsidered in the future.
        if (element.nodeName === 'FORM') {
            break;
        }
        element = element.parentElement;
        recursionCounter += 1;
    }
}
function normalizeWhitespace(s) {
    return s.replace(/\s+/g, ' ');
}
function truncate(s) {
    return s.length > 100 ? Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["safeTruncate"])(s, 100) + " [...]" : s;
}
function getElementById(refElement, id) {
    // Use the element ownerDocument here, because tests are executed in an iframe, so
    // document.getElementById won't work.
    return refElement.ownerDocument ? refElement.ownerDocument.getElementById(id) : null;
}
function getTextualContent(element) {
    if (element.isContentEditable) {
        return;
    }
    if ('innerText' in element) {
        var text = element.innerText;
        if (!supportsInnerTextScriptAndStyleRemoval()) {
            // remove the inner text of SCRIPT and STYLES from the result. This is a bit dirty, but should
            // be relatively fast and work in most cases.
            var elementsTextToRemove = element.querySelectorAll('script, style');
            // eslint-disable-next-line @typescript-eslint/prefer-for-of
            for (var i = 0; i < elementsTextToRemove.length; i += 1) {
                var innerText = elementsTextToRemove[i].innerText;
                if (innerText.trim().length > 0) {
                    text = text.replace(innerText, '');
                }
            }
        }
        return text;
    }
    return element.textContent;
}
/**
 * Returns true if element.innerText excludes the text from inline SCRIPT and STYLE element.  This
 * should be the case everywhere except on some version of Internet Explorer.
 * See http://perfectionkills.com/the-poor-misunderstood-innerText/#diff-with-textContent
 */
var supportsInnerTextScriptAndStyleRemovalResult;
function supportsInnerTextScriptAndStyleRemoval() {
    if (supportsInnerTextScriptAndStyleRemovalResult === undefined) {
        var style = document.createElement('style');
        style.textContent = '*';
        var div = document.createElement('div');
        div.appendChild(style);
        document.body.appendChild(div);
        supportsInnerTextScriptAndStyleRemovalResult = div.innerText === '';
        document.body.removeChild(div);
    }
    return supportsInnerTextScriptAndStyleRemovalResult;
}
/**
 * Returns true if the browser supports the element.labels property.  This should be the case
 * everywhere except on Internet Explorer.
 * Note: The result is computed lazily, because we don't want any DOM access when the SDK is
 * evaluated.
 */
var supportsLabelPropertyResult;
function supportsLabelProperty() {
    if (supportsLabelPropertyResult === undefined) {
        supportsLabelPropertyResult = 'labels' in HTMLInputElement.prototype;
    }
    return supportsLabelPropertyResult;
}
/**
 * Returns true if the browser supports the element.closest method.  This should be the case
 * everywhere except on Internet Explorer.
 * Note: The result is computed lazily, because we don't want any DOM access when the SDK is
 * evaluated.
 */
var supportsElementClosestResult;
function supportsElementClosest() {
    if (supportsElementClosestResult === undefined) {
        supportsElementClosestResult = 'closest' in HTMLElement.prototype;
    }
    return supportsElementClosestResult;
}
//# sourceMappingURL=getActionNameFromElement.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/action/trackActions.js":
/*!********************************************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/action/trackActions.js ***!
  \********************************************************************************************************************************************************************************/
/*! exports provided: trackActions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackActions", function() { return trackActions; });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");
/* harmony import */ var _lifeCycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lifeCycle */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js");
/* harmony import */ var _trackEventCounts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../trackEventCounts */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/trackEventCounts.js");
/* harmony import */ var _trackPageActivities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../trackPageActivities */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/trackPageActivities.js");
/* harmony import */ var _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../rawRumEvent.types */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/rawRumEvent.types.js");
/* harmony import */ var _getActionNameFromElement__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getActionNameFromElement */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/action/getActionNameFromElement.js");






function trackActions(lifeCycle) {
    var action = startActionManagement(lifeCycle);
    // New views trigger the discard of the current pending Action
    lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_1__["LifeCycleEventType"].VIEW_CREATED, function () {
        action.discardCurrent();
    });
    var stopListener = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["addEventListener"])(window, "click" /* CLICK */, function (event) {
        if (!(event.target instanceof Element)) {
            return;
        }
        var name = Object(_getActionNameFromElement__WEBPACK_IMPORTED_MODULE_5__["getActionNameFromElement"])(event.target);
        if (!name) {
            return;
        }
        action.create(_rawRumEvent_types__WEBPACK_IMPORTED_MODULE_4__["ActionType"].CLICK, name);
    }, { capture: true }).stop;
    return {
        stop: function () {
            action.discardCurrent();
            stopListener();
        },
    };
}
function startActionManagement(lifeCycle) {
    var currentAction;
    var currentIdlePageActivitySubscription;
    return {
        create: function (type, name) {
            if (currentAction) {
                // Ignore any new action if another one is already occurring.
                return;
            }
            var pendingAutoAction = new PendingAutoAction(lifeCycle, type, name);
            currentAction = pendingAutoAction;
            currentIdlePageActivitySubscription = Object(_trackPageActivities__WEBPACK_IMPORTED_MODULE_3__["waitIdlePageActivity"])(lifeCycle, function (hadActivity, endTime) {
                if (hadActivity) {
                    pendingAutoAction.complete(endTime);
                }
                else {
                    pendingAutoAction.discard();
                }
                currentAction = undefined;
            });
        },
        discardCurrent: function () {
            if (currentAction) {
                currentIdlePageActivitySubscription.stop();
                currentAction.discard();
                currentAction = undefined;
            }
        },
    };
}
var PendingAutoAction = /** @class */ (function () {
    function PendingAutoAction(lifeCycle, type, name) {
        this.lifeCycle = lifeCycle;
        this.type = type;
        this.name = name;
        this.id = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["generateUUID"])();
        this.startTime = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["relativeNow"])();
        this.eventCountsSubscription = Object(_trackEventCounts__WEBPACK_IMPORTED_MODULE_2__["trackEventCounts"])(lifeCycle);
        this.lifeCycle.notify(_lifeCycle__WEBPACK_IMPORTED_MODULE_1__["LifeCycleEventType"].AUTO_ACTION_CREATED, { id: this.id, startTime: this.startTime });
    }
    PendingAutoAction.prototype.complete = function (endTime) {
        var eventCounts = this.eventCountsSubscription.eventCounts;
        this.lifeCycle.notify(_lifeCycle__WEBPACK_IMPORTED_MODULE_1__["LifeCycleEventType"].AUTO_ACTION_COMPLETED, {
            counts: {
                errorCount: eventCounts.errorCount,
                longTaskCount: eventCounts.longTaskCount,
                resourceCount: eventCounts.resourceCount,
            },
            duration: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["elapsed"])(this.startTime, endTime),
            id: this.id,
            name: this.name,
            startTime: this.startTime,
            type: this.type,
        });
        this.eventCountsSubscription.stop();
    };
    PendingAutoAction.prototype.discard = function () {
        this.lifeCycle.notify(_lifeCycle__WEBPACK_IMPORTED_MODULE_1__["LifeCycleEventType"].AUTO_ACTION_DISCARDED);
        this.eventCountsSubscription.stop();
    };
    return PendingAutoAction;
}());
//# sourceMappingURL=trackActions.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/error/errorCollection.js":
/*!**********************************************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/error/errorCollection.js ***!
  \**********************************************************************************************************************************************************************************/
/*! exports provided: startErrorCollection, doStartErrorCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startErrorCollection", function() { return startErrorCollection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "doStartErrorCollection", function() { return doStartErrorCollection; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./.yarn/cache/tslib-npm-1.14.1-102499115e-dbe628ef87.zip/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");
/* harmony import */ var _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../rawRumEvent.types */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/rawRumEvent.types.js");
/* harmony import */ var _lifeCycle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lifeCycle */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js");




function startErrorCollection(lifeCycle, configuration) {
    return doStartErrorCollection(lifeCycle, Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["startAutomaticErrorCollection"])(configuration));
}
function doStartErrorCollection(lifeCycle, observable) {
    observable.subscribe(function (error) { return lifeCycle.notify(_lifeCycle__WEBPACK_IMPORTED_MODULE_3__["LifeCycleEventType"].RAW_RUM_EVENT_COLLECTED, processError(error)); });
    return {
        addError: function (_a, savedCommonContext) {
            var error = _a.error, startTime = _a.startTime, customerContext = _a.context, source = _a.source;
            var rawError = computeRawError(error, startTime, source);
            lifeCycle.notify(_lifeCycle__WEBPACK_IMPORTED_MODULE_3__["LifeCycleEventType"].RAW_RUM_EVENT_COLLECTED, Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({ customerContext: customerContext,
                savedCommonContext: savedCommonContext }, processError(rawError)));
        },
    };
}
function computeRawError(error, startTime, source) {
    var stackTrace = error instanceof Error ? Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["computeStackTrace"])(error) : undefined;
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({ startTime: startTime, source: source }, Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["formatUnknownError"])(stackTrace, error, 'Provided'));
}
function processError(error) {
    var rawRumEvent = {
        date: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["getTimeStamp"])(error.startTime),
        error: {
            message: error.message,
            resource: error.resource
                ? {
                    method: error.resource.method,
                    status_code: error.resource.statusCode,
                    url: error.resource.url,
                }
                : undefined,
            source: error.source,
            stack: error.stack,
            type: error.type,
        },
        type: _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_2__["RumEventType"].ERROR,
    };
    return {
        rawRumEvent: rawRumEvent,
        startTime: error.startTime,
    };
}
//# sourceMappingURL=errorCollection.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/longTask/longTaskCollection.js":
/*!****************************************************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/longTask/longTaskCollection.js ***!
  \****************************************************************************************************************************************************************************************/
/*! exports provided: startLongTaskCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startLongTaskCollection", function() { return startLongTaskCollection; });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");
/* harmony import */ var _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../rawRumEvent.types */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/rawRumEvent.types.js");
/* harmony import */ var _lifeCycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lifeCycle */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js");



function startLongTaskCollection(lifeCycle) {
    lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_2__["LifeCycleEventType"].PERFORMANCE_ENTRY_COLLECTED, function (entry) {
        if (entry.entryType !== 'longtask') {
            return;
        }
        var rawRumEvent = {
            date: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["getTimeStamp"])(entry.startTime),
            long_task: {
                duration: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["toServerDuration"])(entry.duration),
            },
            type: _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_1__["RumEventType"].LONG_TASK,
        };
        lifeCycle.notify(_lifeCycle__WEBPACK_IMPORTED_MODULE_2__["LifeCycleEventType"].RAW_RUM_EVENT_COLLECTED, {
            rawRumEvent: rawRumEvent,
            startTime: entry.startTime,
        });
    });
}
//# sourceMappingURL=longTaskCollection.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/resource/matchRequestTiming.js":
/*!****************************************************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/resource/matchRequestTiming.js ***!
  \****************************************************************************************************************************************************************************************/
/*! exports provided: matchRequestTiming */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matchRequestTiming", function() { return matchRequestTiming; });
/* harmony import */ var _resourceUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./resourceUtils */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/resource/resourceUtils.js");

/**
 * Look for corresponding timing in resource timing buffer
 *
 * Observations:
 * - Timing (start, end) are nested inside the request (start, end)
 * - Browsers generate a timing entry for OPTIONS request
 *
 * Strategy:
 * - from valid nested entries
 * - if a single timing match, return the timing
 * - if two following timings match (OPTIONS request), return the timing for the actual request
 * - otherwise we can't decide, return undefined
 */
function matchRequestTiming(request) {
    if (!performance || !('getEntriesByName' in performance)) {
        return;
    }
    var sameNameEntries = performance.getEntriesByName(request.url, 'resource');
    if (!sameNameEntries.length || !('toJSON' in sameNameEntries[0])) {
        return;
    }
    var candidates = sameNameEntries
        .map(function (entry) { return entry.toJSON(); })
        .filter(_resourceUtils__WEBPACK_IMPORTED_MODULE_0__["toValidEntry"])
        .filter(function (entry) { return isBetween(entry, request.startTime, endTime(request)); });
    if (candidates.length === 1) {
        return candidates[0];
    }
    if (candidates.length === 2 && firstCanBeOptionRequest(candidates)) {
        return candidates[1];
    }
    return;
}
function firstCanBeOptionRequest(correspondingEntries) {
    return endTime(correspondingEntries[0]) <= correspondingEntries[1].startTime;
}
function endTime(timing) {
    // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
    return (timing.startTime + timing.duration);
}
function isBetween(timing, start, end) {
    return timing.startTime >= start && endTime(timing) <= end;
}
//# sourceMappingURL=matchRequestTiming.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/resource/resourceCollection.js":
/*!****************************************************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/resource/resourceCollection.js ***!
  \****************************************************************************************************************************************************************************************/
/*! exports provided: startResourceCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startResourceCollection", function() { return startResourceCollection; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./.yarn/cache/tslib-npm-1.14.1-102499115e-dbe628ef87.zip/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");
/* harmony import */ var _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../rawRumEvent.types */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/rawRumEvent.types.js");
/* harmony import */ var _lifeCycle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lifeCycle */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js");
/* harmony import */ var _matchRequestTiming__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./matchRequestTiming */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/resource/matchRequestTiming.js");
/* harmony import */ var _resourceUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./resourceUtils */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/resource/resourceUtils.js");






function startResourceCollection(lifeCycle, session) {
    lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_3__["LifeCycleEventType"].REQUEST_COMPLETED, function (request) {
        if (session.isTrackedWithResource()) {
            lifeCycle.notify(_lifeCycle__WEBPACK_IMPORTED_MODULE_3__["LifeCycleEventType"].RAW_RUM_EVENT_COLLECTED, processRequest(request));
        }
    });
    lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_3__["LifeCycleEventType"].PERFORMANCE_ENTRY_COLLECTED, function (entry) {
        if (session.isTrackedWithResource() && entry.entryType === 'resource' && !Object(_resourceUtils__WEBPACK_IMPORTED_MODULE_5__["isRequestKind"])(entry)) {
            lifeCycle.notify(_lifeCycle__WEBPACK_IMPORTED_MODULE_3__["LifeCycleEventType"].RAW_RUM_EVENT_COLLECTED, processResourceEntry(entry));
        }
    });
}
function processRequest(request) {
    var type = request.type === _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["RequestType"].XHR ? _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["ResourceType"].XHR : _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["ResourceType"].FETCH;
    var matchingTiming = Object(_matchRequestTiming__WEBPACK_IMPORTED_MODULE_4__["matchRequestTiming"])(request);
    var startTime = matchingTiming ? matchingTiming.startTime : request.startTime;
    var correspondingTimingOverrides = matchingTiming ? computePerformanceEntryMetrics(matchingTiming) : undefined;
    var tracingInfo = computeRequestTracingInfo(request);
    var resourceEvent = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["combine"])({
        date: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["getTimeStamp"])(startTime),
        resource: {
            type: type,
            duration: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["toServerDuration"])(request.duration),
            method: request.method,
            status_code: request.status,
            url: request.url,
        },
        type: _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_2__["RumEventType"].RESOURCE,
    }, tracingInfo, correspondingTimingOverrides);
    return { startTime: startTime, rawRumEvent: resourceEvent };
}
function processResourceEntry(entry) {
    var type = Object(_resourceUtils__WEBPACK_IMPORTED_MODULE_5__["computeResourceKind"])(entry);
    var entryMetrics = computePerformanceEntryMetrics(entry);
    var tracingInfo = computeEntryTracingInfo(entry);
    var resourceEvent = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["combine"])({
        date: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["getTimeStamp"])(entry.startTime),
        resource: {
            type: type,
            url: entry.name,
        },
        type: _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_2__["RumEventType"].RESOURCE,
    }, tracingInfo, entryMetrics);
    return { startTime: entry.startTime, rawRumEvent: resourceEvent };
}
function computePerformanceEntryMetrics(timing) {
    return {
        resource: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({ duration: Object(_resourceUtils__WEBPACK_IMPORTED_MODULE_5__["computePerformanceResourceDuration"])(timing), size: Object(_resourceUtils__WEBPACK_IMPORTED_MODULE_5__["computeSize"])(timing) }, Object(_resourceUtils__WEBPACK_IMPORTED_MODULE_5__["computePerformanceResourceDetails"])(timing)),
    };
}
function computeRequestTracingInfo(request) {
    var hasBeenTraced = request.traceId && request.spanId;
    if (!hasBeenTraced) {
        return undefined;
    }
    return {
        _dd: {
            span_id: request.spanId.toDecimalString(),
            trace_id: request.traceId.toDecimalString(),
        },
        resource: { id: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["generateUUID"])() },
    };
}
function computeEntryTracingInfo(entry) {
    return entry.traceId ? { _dd: { trace_id: entry.traceId } } : undefined;
}
//# sourceMappingURL=resourceCollection.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/resource/resourceUtils.js":
/*!***********************************************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/resource/resourceUtils.js ***!
  \***********************************************************************************************************************************************************************************/
/*! exports provided: FAKE_INITIAL_DOCUMENT, computeResourceKind, isRequestKind, computePerformanceResourceDuration, computePerformanceResourceDetails, toValidEntry, computeSize, isAllowedRequestUrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FAKE_INITIAL_DOCUMENT", function() { return FAKE_INITIAL_DOCUMENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeResourceKind", function() { return computeResourceKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isRequestKind", function() { return isRequestKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computePerformanceResourceDuration", function() { return computePerformanceResourceDuration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computePerformanceResourceDetails", function() { return computePerformanceResourceDetails; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toValidEntry", function() { return toValidEntry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeSize", function() { return computeSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAllowedRequestUrl", function() { return isAllowedRequestUrl; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./.yarn/cache/tslib-npm-1.14.1-102499115e-dbe628ef87.zip/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");


var FAKE_INITIAL_DOCUMENT = 'initial_document';
var RESOURCE_TYPES = [
    [_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["ResourceType"].DOCUMENT, function (initiatorType) { return FAKE_INITIAL_DOCUMENT === initiatorType; }],
    [_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["ResourceType"].XHR, function (initiatorType) { return 'xmlhttprequest' === initiatorType; }],
    [_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["ResourceType"].FETCH, function (initiatorType) { return 'fetch' === initiatorType; }],
    [_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["ResourceType"].BEACON, function (initiatorType) { return 'beacon' === initiatorType; }],
    [_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["ResourceType"].CSS, function (_, path) { return /\.css$/i.test(path); }],
    [_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["ResourceType"].JS, function (_, path) { return /\.js$/i.test(path); }],
    [
        _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["ResourceType"].IMAGE,
        function (initiatorType, path) {
            return Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["includes"])(['image', 'img', 'icon'], initiatorType) || /\.(gif|jpg|jpeg|tiff|png|svg|ico)$/i.exec(path) !== null;
        },
    ],
    [_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["ResourceType"].FONT, function (_, path) { return /\.(woff|eot|woff2|ttf)$/i.exec(path) !== null; }],
    [
        _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["ResourceType"].MEDIA,
        function (initiatorType, path) {
            return Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["includes"])(['audio', 'video'], initiatorType) || /\.(mp3|mp4)$/i.exec(path) !== null;
        },
    ],
];
function computeResourceKind(timing) {
    var url = timing.name;
    if (!Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["isValidUrl"])(url)) {
        Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["addMonitoringMessage"])("Failed to construct URL for \"" + timing.name + "\"");
        return _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["ResourceType"].OTHER;
    }
    var path = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["getPathName"])(url);
    for (var _i = 0, RESOURCE_TYPES_1 = RESOURCE_TYPES; _i < RESOURCE_TYPES_1.length; _i++) {
        var _a = RESOURCE_TYPES_1[_i], type = _a[0], isType = _a[1];
        if (isType(timing.initiatorType, path)) {
            return type;
        }
    }
    return _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["ResourceType"].OTHER;
}
function areInOrder() {
    var numbers = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        numbers[_i] = arguments[_i];
    }
    for (var i = 1; i < numbers.length; i += 1) {
        if (numbers[i - 1] > numbers[i]) {
            return false;
        }
    }
    return true;
}
function isRequestKind(timing) {
    return timing.initiatorType === 'xmlhttprequest' || timing.initiatorType === 'fetch';
}
function computePerformanceResourceDuration(entry) {
    var duration = entry.duration, startTime = entry.startTime, responseEnd = entry.responseEnd;
    // Safari duration is always 0 on timings blocked by cross origin policies.
    if (duration === 0 && startTime < responseEnd) {
        return Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["toServerDuration"])(Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["elapsed"])(startTime, responseEnd));
    }
    return Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["toServerDuration"])(duration);
}
function computePerformanceResourceDetails(entry) {
    var validEntry = toValidEntry(entry);
    if (!validEntry) {
        return undefined;
    }
    var startTime = validEntry.startTime, fetchStart = validEntry.fetchStart, redirectStart = validEntry.redirectStart, redirectEnd = validEntry.redirectEnd, domainLookupStart = validEntry.domainLookupStart, domainLookupEnd = validEntry.domainLookupEnd, connectStart = validEntry.connectStart, secureConnectionStart = validEntry.secureConnectionStart, connectEnd = validEntry.connectEnd, requestStart = validEntry.requestStart, responseStart = validEntry.responseStart, responseEnd = validEntry.responseEnd;
    var details = {
        download: formatTiming(startTime, responseStart, responseEnd),
        first_byte: formatTiming(startTime, requestStart, responseStart),
    };
    // Make sure a connection occurred
    if (connectEnd !== fetchStart) {
        details.connect = formatTiming(startTime, connectStart, connectEnd);
        // Make sure a secure connection occurred
        if (areInOrder(connectStart, secureConnectionStart, connectEnd)) {
            details.ssl = formatTiming(startTime, secureConnectionStart, connectEnd);
        }
    }
    // Make sure a domain lookup occurred
    if (domainLookupEnd !== fetchStart) {
        details.dns = formatTiming(startTime, domainLookupStart, domainLookupEnd);
    }
    if (hasRedirection(entry)) {
        details.redirect = formatTiming(startTime, redirectStart, redirectEnd);
    }
    return details;
}
function toValidEntry(entry) {
    // Ensure timings are in the right order. On top of filtering out potential invalid
    // RumPerformanceResourceTiming, it will ignore entries from requests where timings cannot be
    // collected, for example cross origin requests without a "Timing-Allow-Origin" header allowing
    // it.
    if (!areInOrder(entry.startTime, entry.fetchStart, entry.domainLookupStart, entry.domainLookupEnd, entry.connectStart, entry.connectEnd, entry.requestStart, entry.responseStart, entry.responseEnd)) {
        return undefined;
    }
    if (!hasRedirection(entry)) {
        return entry;
    }
    var redirectStart = entry.redirectStart, redirectEnd = entry.redirectEnd;
    // Firefox doesn't provide redirect timings on cross origin requests.
    // Provide a default for those.
    if (redirectStart < entry.startTime) {
        redirectStart = entry.startTime;
    }
    if (redirectEnd < entry.startTime) {
        redirectEnd = entry.fetchStart;
    }
    // Make sure redirect timings are in order
    if (!areInOrder(entry.startTime, redirectStart, redirectEnd, entry.fetchStart)) {
        return undefined;
    }
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, entry), { redirectEnd: redirectEnd,
        redirectStart: redirectStart });
}
function hasRedirection(entry) {
    // The only time fetchStart is different than startTime is if a redirection occurred.
    return entry.fetchStart !== entry.startTime;
}
function formatTiming(origin, start, end) {
    return {
        duration: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["toServerDuration"])(Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["elapsed"])(start, end)),
        start: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["toServerDuration"])(Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["elapsed"])(origin, start)),
    };
}
function computeSize(entry) {
    // Make sure a request actually occurred
    if (entry.startTime < entry.responseStart) {
        return entry.decodedBodySize;
    }
    return undefined;
}
function isAllowedRequestUrl(configuration, url) {
    return url && !configuration.isIntakeUrl(url);
}
//# sourceMappingURL=resourceUtils.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/view/trackFirstHidden.js":
/*!**********************************************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/view/trackFirstHidden.js ***!
  \**********************************************************************************************************************************************************************************/
/*! exports provided: trackFirstHidden, resetFirstHidden */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackFirstHidden", function() { return trackFirstHidden; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetFirstHidden", function() { return resetFirstHidden; });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");

var trackFirstHiddenSingleton;
var stopListeners;
function trackFirstHidden(emitter) {
    if (emitter === void 0) { emitter = window; }
    if (!trackFirstHiddenSingleton) {
        if (document.visibilityState === 'hidden') {
            trackFirstHiddenSingleton = { timeStamp: 0 };
        }
        else {
            trackFirstHiddenSingleton = {
                timeStamp: Infinity,
            };
            (stopListeners = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["addEventListener"])(emitter, "pagehide" /* PAGE_HIDE */, function (_a) {
                var timeStamp = _a.timeStamp;
                trackFirstHiddenSingleton.timeStamp = timeStamp;
            }, { capture: true, once: true }).stop);
        }
    }
    return trackFirstHiddenSingleton;
}
function resetFirstHidden() {
    if (stopListeners) {
        stopListeners();
    }
    trackFirstHiddenSingleton = undefined;
}
//# sourceMappingURL=trackFirstHidden.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/view/trackInitialViewTimings.js":
/*!*****************************************************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/view/trackInitialViewTimings.js ***!
  \*****************************************************************************************************************************************************************************************/
/*! exports provided: trackInitialViewTimings, trackNavigationTimings, trackFirstContentfulPaint, trackLargestContentfulPaint, trackFirstInputTimings */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackInitialViewTimings", function() { return trackInitialViewTimings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackNavigationTimings", function() { return trackNavigationTimings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackFirstContentfulPaint", function() { return trackFirstContentfulPaint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackLargestContentfulPaint", function() { return trackLargestContentfulPaint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackFirstInputTimings", function() { return trackFirstInputTimings; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./.yarn/cache/tslib-npm-1.14.1-102499115e-dbe628ef87.zip/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");
/* harmony import */ var _lifeCycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lifeCycle */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js");
/* harmony import */ var _trackFirstHidden__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./trackFirstHidden */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/view/trackFirstHidden.js");




function trackInitialViewTimings(lifeCycle, callback) {
    var timings;
    function setTimings(newTimings) {
        timings = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, timings), newTimings);
        callback(timings);
    }
    var stopNavigationTracking = trackNavigationTimings(lifeCycle, setTimings).stop;
    var stopFCPTracking = trackFirstContentfulPaint(lifeCycle, function (firstContentfulPaint) {
        return setTimings({ firstContentfulPaint: firstContentfulPaint });
    }).stop;
    var stopLCPTracking = trackLargestContentfulPaint(lifeCycle, window, function (largestContentfulPaint) {
        setTimings({
            largestContentfulPaint: largestContentfulPaint,
        });
    }).stop;
    var stopFIDTracking = trackFirstInputTimings(lifeCycle, function (_a) {
        var firstInputDelay = _a.firstInputDelay, firstInputTime = _a.firstInputTime;
        setTimings({
            firstInputDelay: firstInputDelay,
            firstInputTime: firstInputTime,
        });
    }).stop;
    return {
        stop: function () {
            stopNavigationTracking();
            stopFCPTracking();
            stopLCPTracking();
            stopFIDTracking();
        },
    };
}
function trackNavigationTimings(lifeCycle, callback) {
    var stop = lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_2__["LifeCycleEventType"].PERFORMANCE_ENTRY_COLLECTED, function (entry) {
        if (entry.entryType === 'navigation') {
            callback({
                domComplete: entry.domComplete,
                domContentLoaded: entry.domContentLoadedEventEnd,
                domInteractive: entry.domInteractive,
                loadEvent: entry.loadEventEnd,
            });
        }
    }).unsubscribe;
    return { stop: stop };
}
function trackFirstContentfulPaint(lifeCycle, callback) {
    var firstHidden = Object(_trackFirstHidden__WEBPACK_IMPORTED_MODULE_3__["trackFirstHidden"])();
    var stop = lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_2__["LifeCycleEventType"].PERFORMANCE_ENTRY_COLLECTED, function (entry) {
        if (entry.entryType === 'paint' &&
            entry.name === 'first-contentful-paint' &&
            entry.startTime < firstHidden.timeStamp) {
            callback(entry.startTime);
        }
    }).unsubscribe;
    return { stop: stop };
}
/**
 * Track the largest contentful paint (LCP) occurring during the initial View.  This can yield
 * multiple values, only the most recent one should be used.
 * Documentation: https://web.dev/lcp/
 * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getLCP.ts
 */
function trackLargestContentfulPaint(lifeCycle, emitter, callback) {
    var firstHidden = Object(_trackFirstHidden__WEBPACK_IMPORTED_MODULE_3__["trackFirstHidden"])();
    // Ignore entries that come after the first user interaction.  According to the documentation, the
    // browser should not send largest-contentful-paint entries after a user interact with the page,
    // but the web-vitals reference implementation uses this as a safeguard.
    var firstInteractionTimestamp = Infinity;
    var stopEventListener = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["addEventListeners"])(emitter, ["pointerdown" /* POINTER_DOWN */, "keydown" /* KEY_DOWN */], function (event) {
        firstInteractionTimestamp = event.timeStamp;
    }, { capture: true, once: true }).stop;
    var unsubscribeLifeCycle = lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_2__["LifeCycleEventType"].PERFORMANCE_ENTRY_COLLECTED, function (entry) {
        if (entry.entryType === 'largest-contentful-paint' &&
            entry.startTime < firstInteractionTimestamp &&
            entry.startTime < firstHidden.timeStamp) {
            callback(entry.startTime);
        }
    }).unsubscribe;
    return {
        stop: function () {
            stopEventListener();
            unsubscribeLifeCycle();
        },
    };
}
/**
 * Track the first input occurring during the initial View to return:
 * - First Input Delay
 * - First Input Time
 * Callback is called at most one time.
 * Documentation: https://web.dev/fid/
 * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getFID.ts
 */
function trackFirstInputTimings(lifeCycle, callback) {
    var firstHidden = Object(_trackFirstHidden__WEBPACK_IMPORTED_MODULE_3__["trackFirstHidden"])();
    var stop = lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_2__["LifeCycleEventType"].PERFORMANCE_ENTRY_COLLECTED, function (entry) {
        if (entry.entryType === 'first-input' && entry.startTime < firstHidden.timeStamp) {
            var firstInputDelay = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["elapsed"])(entry.startTime, entry.processingStart);
            callback({
                // Ensure firstInputDelay to be positive, see
                // https://bugs.chromium.org/p/chromium/issues/detail?id=1185815
                firstInputDelay: firstInputDelay >= 0 ? firstInputDelay : 0,
                firstInputTime: entry.startTime,
            });
        }
    }).unsubscribe;
    return {
        stop: stop,
    };
}
//# sourceMappingURL=trackInitialViewTimings.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/view/trackLocationChanges.js":
/*!**************************************************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/view/trackLocationChanges.js ***!
  \**************************************************************************************************************************************************************************************/
/*! exports provided: trackLocationChanges, areDifferentLocation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackLocationChanges", function() { return trackLocationChanges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areDifferentLocation", function() { return areDifferentLocation; });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");

function trackLocationChanges(onLocationChange) {
    var stopHistoryTracking = trackHistory(onLocationChange).stop;
    var stopHashTracking = trackHash(onLocationChange).stop;
    return {
        stop: function () {
            stopHistoryTracking();
            stopHashTracking();
        },
    };
}
function areDifferentLocation(currentLocation, otherLocation) {
    return (currentLocation.pathname !== otherLocation.pathname ||
        (!isHashAnAnchor(otherLocation.hash) &&
            getPathFromHash(otherLocation.hash) !== getPathFromHash(currentLocation.hash)));
}
function trackHistory(onHistoryChange) {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    var originalPushState = history.pushState;
    history.pushState = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["monitor"])(function () {
        originalPushState.apply(this, arguments);
        onHistoryChange();
    });
    // eslint-disable-next-line @typescript-eslint/unbound-method
    var originalReplaceState = history.replaceState;
    history.replaceState = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["monitor"])(function () {
        originalReplaceState.apply(this, arguments);
        onHistoryChange();
    });
    var removeListener = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["addEventListener"])(window, "popstate" /* POP_STATE */, onHistoryChange).stop;
    var stop = function () {
        removeListener();
        history.pushState = originalPushState;
        history.replaceState = originalReplaceState;
    };
    return { stop: stop };
}
function trackHash(onHashChange) {
    return Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["addEventListener"])(window, "hashchange" /* HASH_CHANGE */, onHashChange);
}
function isHashAnAnchor(hash) {
    var correspondingId = hash.substr(1);
    return !!document.getElementById(correspondingId);
}
function getPathFromHash(hash) {
    var index = hash.indexOf('?');
    return index < 0 ? hash : hash.slice(0, index);
}
//# sourceMappingURL=trackLocationChanges.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/view/trackViewMetrics.js":
/*!**********************************************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/view/trackViewMetrics.js ***!
  \**********************************************************************************************************************************************************************************/
/*! exports provided: trackViewMetrics */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackViewMetrics", function() { return trackViewMetrics; });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");
/* harmony import */ var _trackEventCounts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../trackEventCounts */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/trackEventCounts.js");
/* harmony import */ var _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../rawRumEvent.types */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/rawRumEvent.types.js");
/* harmony import */ var _trackPageActivities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../trackPageActivities */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/trackPageActivities.js");
/* harmony import */ var _browser_performanceCollection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../browser/performanceCollection */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/browser/performanceCollection.js");
/* harmony import */ var _lifeCycle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../lifeCycle */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js");






function trackViewMetrics(lifeCycle, scheduleViewUpdate, loadingType) {
    var viewMetrics = {
        eventCounts: {
            errorCount: 0,
            longTaskCount: 0,
            resourceCount: 0,
            userActionCount: 0,
        },
    };
    var stopEventCountsTracking = Object(_trackEventCounts__WEBPACK_IMPORTED_MODULE_1__["trackEventCounts"])(lifeCycle, function (newEventCounts) {
        viewMetrics.eventCounts = newEventCounts;
        scheduleViewUpdate();
    }).stop;
    var _a = trackLoadingTime(loadingType, function (newLoadingTime) {
        viewMetrics.loadingTime = newLoadingTime;
        scheduleViewUpdate();
    }), setActivityLoadingTime = _a.setActivityLoadingTime, setLoadEvent = _a.setLoadEvent;
    var stopActivityLoadingTimeTracking = trackActivityLoadingTime(lifeCycle, setActivityLoadingTime).stop;
    var stopCLSTracking;
    if (isLayoutShiftSupported()) {
        viewMetrics.cumulativeLayoutShift = 0;
        (stopCLSTracking = trackLayoutShift(lifeCycle, function (layoutShift) {
            viewMetrics.cumulativeLayoutShift = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["round"])(viewMetrics.cumulativeLayoutShift + layoutShift, 4);
            scheduleViewUpdate();
        }).stop);
    }
    else {
        stopCLSTracking = _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["noop"];
    }
    return {
        stop: function () {
            stopEventCountsTracking();
            stopActivityLoadingTimeTracking();
            stopCLSTracking();
        },
        setLoadEvent: setLoadEvent,
        viewMetrics: viewMetrics,
    };
}
function trackLoadingTime(loadType, callback) {
    var isWaitingForLoadEvent = loadType === _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_2__["ViewLoadingType"].INITIAL_LOAD;
    var isWaitingForActivityLoadingTime = true;
    var loadingTimeCandidates = [];
    function invokeCallbackIfAllCandidatesAreReceived() {
        if (!isWaitingForActivityLoadingTime && !isWaitingForLoadEvent && loadingTimeCandidates.length > 0) {
            callback(Math.max.apply(Math, loadingTimeCandidates));
        }
    }
    return {
        setLoadEvent: function (loadEvent) {
            if (isWaitingForLoadEvent) {
                isWaitingForLoadEvent = false;
                loadingTimeCandidates.push(loadEvent);
                invokeCallbackIfAllCandidatesAreReceived();
            }
        },
        setActivityLoadingTime: function (activityLoadingTime) {
            if (isWaitingForActivityLoadingTime) {
                isWaitingForActivityLoadingTime = false;
                if (activityLoadingTime !== undefined) {
                    loadingTimeCandidates.push(activityLoadingTime);
                }
                invokeCallbackIfAllCandidatesAreReceived();
            }
        },
    };
}
function trackActivityLoadingTime(lifeCycle, callback) {
    var startTime = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["relativeNow"])();
    var stopWaitIdlePageActivity = Object(_trackPageActivities__WEBPACK_IMPORTED_MODULE_3__["waitIdlePageActivity"])(lifeCycle, function (hadActivity, endTime) {
        if (hadActivity) {
            callback(Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["elapsed"])(startTime, endTime));
        }
        else {
            callback(undefined);
        }
    }).stop;
    return { stop: stopWaitIdlePageActivity };
}
/**
 * Track layout shifts (LS) occurring during the Views.  This yields multiple values that can be
 * added up to compute the cumulated layout shift (CLS).
 *
 * See isLayoutShiftSupported to check for browser support.
 *
 * Documentation: https://web.dev/cls/
 * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getCLS.ts
 */
function trackLayoutShift(lifeCycle, callback) {
    var stop = lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_5__["LifeCycleEventType"].PERFORMANCE_ENTRY_COLLECTED, function (entry) {
        if (entry.entryType === 'layout-shift' && !entry.hadRecentInput) {
            callback(entry.value);
        }
    }).unsubscribe;
    return {
        stop: stop,
    };
}
/**
 * Check whether `layout-shift` is supported by the browser.
 */
function isLayoutShiftSupported() {
    return Object(_browser_performanceCollection__WEBPACK_IMPORTED_MODULE_4__["supportPerformanceTimingEvent"])('layout-shift');
}
//# sourceMappingURL=trackViewMetrics.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/view/trackViews.js":
/*!****************************************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/view/trackViews.js ***!
  \****************************************************************************************************************************************************************************/
/*! exports provided: THROTTLE_VIEW_UPDATE_PERIOD, SESSION_KEEP_ALIVE_INTERVAL, trackViews */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "THROTTLE_VIEW_UPDATE_PERIOD", function() { return THROTTLE_VIEW_UPDATE_PERIOD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SESSION_KEEP_ALIVE_INTERVAL", function() { return SESSION_KEEP_ALIVE_INTERVAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackViews", function() { return trackViews; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./.yarn/cache/tslib-npm-1.14.1-102499115e-dbe628ef87.zip/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");
/* harmony import */ var _lifeCycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lifeCycle */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js");
/* harmony import */ var _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../rawRumEvent.types */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/rawRumEvent.types.js");
/* harmony import */ var _trackInitialViewTimings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./trackInitialViewTimings */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/view/trackInitialViewTimings.js");
/* harmony import */ var _trackViewMetrics__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./trackViewMetrics */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/view/trackViewMetrics.js");
/* harmony import */ var _trackLocationChanges__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./trackLocationChanges */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/view/trackLocationChanges.js");







var THROTTLE_VIEW_UPDATE_PERIOD = 3000;
var SESSION_KEEP_ALIVE_INTERVAL = 5 * _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["ONE_MINUTE"];
function trackViews(location, lifeCycle) {
    var isRecording = false;
    // eslint-disable-next-line prefer-const
    var _a = trackInitialView(), stopInitialViewTracking = _a.stop, currentView = _a.initialView;
    var stopLocationChangesTracking = Object(_trackLocationChanges__WEBPACK_IMPORTED_MODULE_6__["trackLocationChanges"])(function () {
        if (Object(_trackLocationChanges__WEBPACK_IMPORTED_MODULE_6__["areDifferentLocation"])(currentView.getLocation(), location)) {
            // Renew view on location changes
            currentView.end();
            currentView.triggerUpdate();
            currentView = trackViewChange();
            return;
        }
        currentView.updateLocation(location);
        currentView.triggerUpdate();
    }).stop;
    // Renew view on session renewal
    lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_2__["LifeCycleEventType"].SESSION_RENEWED, function () {
        // do not trigger view update to avoid wrong data
        currentView.end();
        currentView = trackViewChange();
    });
    // End the current view on page unload
    lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_2__["LifeCycleEventType"].BEFORE_UNLOAD, function () {
        currentView.end();
        currentView.triggerUpdate();
    });
    lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_2__["LifeCycleEventType"].RECORD_STARTED, function () {
        isRecording = true;
        currentView.updateHasReplay(true);
    });
    lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_2__["LifeCycleEventType"].RECORD_STOPPED, function () {
        isRecording = false;
    });
    // Session keep alive
    var keepAliveInterval = window.setInterval(Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["monitor"])(function () {
        currentView.triggerUpdate();
    }), SESSION_KEEP_ALIVE_INTERVAL);
    function trackInitialView() {
        var startOrigin = 0;
        var initialView = newView(lifeCycle, location, isRecording, _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_3__["ViewLoadingType"].INITIAL_LOAD, document.referrer, startOrigin);
        var stop = Object(_trackInitialViewTimings__WEBPACK_IMPORTED_MODULE_4__["trackInitialViewTimings"])(lifeCycle, function (timings) {
            initialView.updateTimings(timings);
            initialView.scheduleUpdate();
        }).stop;
        return { initialView: initialView, stop: stop };
    }
    function trackViewChange() {
        return newView(lifeCycle, location, isRecording, _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_3__["ViewLoadingType"].ROUTE_CHANGE, currentView.url);
    }
    return {
        addTiming: function (name, time) {
            if (time === void 0) { time = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["relativeNow"])(); }
            currentView.addTiming(name, time);
            currentView.triggerUpdate();
        },
        stop: function () {
            stopInitialViewTracking();
            stopLocationChangesTracking();
            currentView.end();
            clearInterval(keepAliveInterval);
        },
    };
}
function newView(lifeCycle, initialLocation, initialHasReplay, loadingType, referrer, startTime, name) {
    if (startTime === void 0) { startTime = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["relativeNow"])(); }
    // Setup initial values
    var id = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["generateUUID"])();
    var timings = {};
    var customTimings = {};
    var documentVersion = 0;
    var endTime;
    var location = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, initialLocation);
    var hasReplay = initialHasReplay;
    lifeCycle.notify(_lifeCycle__WEBPACK_IMPORTED_MODULE_2__["LifeCycleEventType"].VIEW_CREATED, { id: id, startTime: startTime, location: location, referrer: referrer });
    // Update the view every time the measures are changing
    var _a = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["throttle"])(Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["monitor"])(triggerViewUpdate), THROTTLE_VIEW_UPDATE_PERIOD, {
        leading: false,
    }), scheduleViewUpdate = _a.throttled, cancelScheduleViewUpdate = _a.cancel;
    var _b = Object(_trackViewMetrics__WEBPACK_IMPORTED_MODULE_5__["trackViewMetrics"])(lifeCycle, scheduleViewUpdate, loadingType), setLoadEvent = _b.setLoadEvent, stopViewMetricsTracking = _b.stop, viewMetrics = _b.viewMetrics;
    // Initial view update
    triggerViewUpdate();
    function triggerViewUpdate() {
        documentVersion += 1;
        lifeCycle.notify(_lifeCycle__WEBPACK_IMPORTED_MODULE_2__["LifeCycleEventType"].VIEW_UPDATED, Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, viewMetrics), { customTimings: customTimings,
            documentVersion: documentVersion,
            id: id,
            name: name,
            loadingType: loadingType,
            location: location,
            hasReplay: hasReplay,
            referrer: referrer,
            startTime: startTime,
            timings: timings, duration: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["elapsed"])(startTime, endTime === undefined ? Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["relativeNow"])() : endTime), isActive: endTime === undefined }));
    }
    return {
        scheduleUpdate: scheduleViewUpdate,
        end: function () {
            endTime = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["relativeNow"])();
            stopViewMetricsTracking();
            lifeCycle.notify(_lifeCycle__WEBPACK_IMPORTED_MODULE_2__["LifeCycleEventType"].VIEW_ENDED);
        },
        getLocation: function () {
            return location;
        },
        triggerUpdate: function () {
            // cancel any pending view updates execution
            cancelScheduleViewUpdate();
            triggerViewUpdate();
        },
        updateTimings: function (newTimings) {
            timings = newTimings;
            if (newTimings.loadEvent !== undefined) {
                setLoadEvent(newTimings.loadEvent);
            }
        },
        addTiming: function (name, endTime) {
            customTimings[sanitizeTiming(name)] = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["elapsed"])(startTime, endTime);
        },
        updateLocation: function (newLocation) {
            location = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, newLocation);
        },
        updateHasReplay: function (newHasReplay) {
            hasReplay = newHasReplay;
        },
        get url() {
            return location.href;
        },
    };
}
/**
 * Timing name is used as facet path that must contain only letters, digits, or the characters - _ . @ $
 */
function sanitizeTiming(name) {
    var sanitized = name.replace(/[^a-zA-Z0-9-_.@$]/g, '_');
    if (sanitized !== name) {
        console.warn("Invalid timing name: " + name + ", sanitized to: " + sanitized);
    }
    return sanitized;
}
//# sourceMappingURL=trackViews.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/view/viewCollection.js":
/*!********************************************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/view/viewCollection.js ***!
  \********************************************************************************************************************************************************************************/
/*! exports provided: startViewCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startViewCollection", function() { return startViewCollection; });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");
/* harmony import */ var _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../rawRumEvent.types */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/rawRumEvent.types.js");
/* harmony import */ var _lifeCycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lifeCycle */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js");
/* harmony import */ var _trackViews__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./trackViews */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/view/trackViews.js");




function startViewCollection(lifeCycle, location) {
    lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_2__["LifeCycleEventType"].VIEW_UPDATED, function (view) {
        return lifeCycle.notify(_lifeCycle__WEBPACK_IMPORTED_MODULE_2__["LifeCycleEventType"].RAW_RUM_EVENT_COLLECTED, processViewUpdate(view));
    });
    return Object(_trackViews__WEBPACK_IMPORTED_MODULE_3__["trackViews"])(location, lifeCycle);
}
function processViewUpdate(view) {
    var viewEvent = {
        _dd: {
            document_version: view.documentVersion,
        },
        date: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["getTimeStamp"])(view.startTime),
        type: _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_1__["RumEventType"].VIEW,
        view: {
            action: {
                count: view.eventCounts.userActionCount,
            },
            cumulative_layout_shift: view.cumulativeLayoutShift,
            dom_complete: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["toServerDuration"])(view.timings.domComplete),
            dom_content_loaded: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["toServerDuration"])(view.timings.domContentLoaded),
            dom_interactive: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["toServerDuration"])(view.timings.domInteractive),
            error: {
                count: view.eventCounts.errorCount,
            },
            first_contentful_paint: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["toServerDuration"])(view.timings.firstContentfulPaint),
            first_input_delay: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["toServerDuration"])(view.timings.firstInputDelay),
            first_input_time: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["toServerDuration"])(view.timings.firstInputTime),
            is_active: view.isActive,
            name: view.name,
            largest_contentful_paint: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["toServerDuration"])(view.timings.largestContentfulPaint),
            load_event: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["toServerDuration"])(view.timings.loadEvent),
            loading_time: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["toServerDuration"])(view.loadingTime),
            loading_type: view.loadingType,
            long_task: {
                count: view.eventCounts.longTaskCount,
            },
            resource: {
                count: view.eventCounts.resourceCount,
            },
            time_spent: Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["toServerDuration"])(view.duration),
        },
        session: {
            has_replay: view.hasReplay || undefined,
        },
    };
    if (!Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["isEmptyObject"])(view.customTimings)) {
        viewEvent.view.custom_timings = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["mapValues"])(view.customTimings, _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["toServerDuration"]);
    }
    return {
        rawRumEvent: viewEvent,
        startTime: view.startTime,
    };
}
//# sourceMappingURL=viewCollection.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumSession.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/rumSession.js ***!
  \***************************************************************************************************************************************************/
/*! exports provided: RUM_SESSION_KEY, RumTrackingType, startRumSession */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RUM_SESSION_KEY", function() { return RUM_SESSION_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RumTrackingType", function() { return RumTrackingType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startRumSession", function() { return startRumSession; });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");
/* harmony import */ var _lifeCycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lifeCycle */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js");


var RUM_SESSION_KEY = 'rum';
var RumTrackingType;
(function (RumTrackingType) {
    RumTrackingType["NOT_TRACKED"] = "0";
    RumTrackingType["TRACKED_WITH_RESOURCES"] = "1";
    RumTrackingType["TRACKED_WITHOUT_RESOURCES"] = "2";
})(RumTrackingType || (RumTrackingType = {}));
function startRumSession(configuration, lifeCycle) {
    var session = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["startSessionManagement"])(configuration.cookieOptions, RUM_SESSION_KEY, function (rawTrackingType) {
        return computeSessionState(configuration, rawTrackingType);
    });
    session.renewObservable.subscribe(function () {
        lifeCycle.notify(_lifeCycle__WEBPACK_IMPORTED_MODULE_1__["LifeCycleEventType"].SESSION_RENEWED);
    });
    return {
        getId: session.getId,
        isTracked: function () { return session.getId() !== undefined && isTracked(session.getTrackingType()); },
        isTrackedWithResource: function () {
            return session.getId() !== undefined && session.getTrackingType() === RumTrackingType.TRACKED_WITH_RESOURCES;
        },
    };
}
function computeSessionState(configuration, rawTrackingType) {
    var trackingType;
    if (hasValidRumSession(rawTrackingType)) {
        trackingType = rawTrackingType;
    }
    else if (!Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["performDraw"])(configuration.sampleRate)) {
        trackingType = RumTrackingType.NOT_TRACKED;
    }
    else if (!Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["performDraw"])(configuration.resourceSampleRate)) {
        trackingType = RumTrackingType.TRACKED_WITHOUT_RESOURCES;
    }
    else {
        trackingType = RumTrackingType.TRACKED_WITH_RESOURCES;
    }
    return {
        trackingType: trackingType,
        isTracked: isTracked(trackingType),
    };
}
function hasValidRumSession(trackingType) {
    return (trackingType === RumTrackingType.NOT_TRACKED ||
        trackingType === RumTrackingType.TRACKED_WITH_RESOURCES ||
        trackingType === RumTrackingType.TRACKED_WITHOUT_RESOURCES);
}
function isTracked(rumSessionType) {
    return (rumSessionType === RumTrackingType.TRACKED_WITH_RESOURCES ||
        rumSessionType === RumTrackingType.TRACKED_WITHOUT_RESOURCES);
}
//# sourceMappingURL=rumSession.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/tracing/getDocumentTraceId.js":
/*!*******************************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/tracing/getDocumentTraceId.js ***!
  \*******************************************************************************************************************************************************************/
/*! exports provided: INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD, getDocumentTraceId, getDocumentTraceDataFromMeta, getDocumentTraceDataFromComment, createDocumentTraceData, findTraceComment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD", function() { return INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDocumentTraceId", function() { return getDocumentTraceId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDocumentTraceDataFromMeta", function() { return getDocumentTraceDataFromMeta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDocumentTraceDataFromComment", function() { return getDocumentTraceDataFromComment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createDocumentTraceData", function() { return createDocumentTraceData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findTraceComment", function() { return findTraceComment; });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");

var INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD = 2 * _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["ONE_MINUTE"];
function getDocumentTraceId(document) {
    var data = getDocumentTraceDataFromMeta(document) || getDocumentTraceDataFromComment(document);
    if (!data || data.traceTime <= Date.now() - INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD) {
        return undefined;
    }
    return data.traceId;
}
function getDocumentTraceDataFromMeta(document) {
    var traceIdMeta = document.querySelector('meta[name=dd-trace-id]');
    var traceTimeMeta = document.querySelector('meta[name=dd-trace-time]');
    return createDocumentTraceData(traceIdMeta && traceIdMeta.content, traceTimeMeta && traceTimeMeta.content);
}
function getDocumentTraceDataFromComment(document) {
    var comment = findTraceComment(document);
    if (!comment) {
        return undefined;
    }
    return createDocumentTraceData(Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["findCommaSeparatedValue"])(comment, 'trace-id'), Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["findCommaSeparatedValue"])(comment, 'trace-time'));
}
function createDocumentTraceData(traceId, rawTraceTime) {
    var traceTime = rawTraceTime && Number(rawTraceTime);
    if (!traceId || !traceTime) {
        return undefined;
    }
    return {
        traceId: traceId,
        traceTime: traceTime,
    };
}
function findTraceComment(document) {
    // 1. Try to find the comment as a direct child of the document
    // Note: TSLint advises to use a 'for of', but TS doesn't allow to use 'for of' if the iterated
    // value is not an array or string (here, a NodeList).
    // eslint-disable-next-line @typescript-eslint/prefer-for-of
    for (var i = 0; i < document.childNodes.length; i += 1) {
        var comment = getTraceCommentFromNode(document.childNodes[i]);
        if (comment) {
            return comment;
        }
    }
    // 2. If the comment is placed after the </html> tag, but have some space or new lines before or
    // after, the DOM parser will lift it (and the surrounding text) at the end of the <body> tag.
    // Try to look for the comment at the end of the <body> by by iterating over its child nodes in
    // reverse order, stopping if we come across a non-text node.
    if (document.body) {
        for (var i = document.body.childNodes.length - 1; i >= 0; i -= 1) {
            var node = document.body.childNodes[i];
            var comment = getTraceCommentFromNode(node);
            if (comment) {
                return comment;
            }
            if (!isTextNode(node)) {
                break;
            }
        }
    }
}
function getTraceCommentFromNode(node) {
    if (node && isCommentNode(node)) {
        var match = /^\s*DATADOG;(.*?)\s*$/.exec(node.data);
        if (match) {
            return match[1];
        }
    }
}
function isCommentNode(node) {
    return node.nodeName === '#comment';
}
function isTextNode(node) {
    return node.nodeName === '#text';
}
//# sourceMappingURL=getDocumentTraceId.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/tracing/tracer.js":
/*!*******************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/tracing/tracer.js ***!
  \*******************************************************************************************************************************************************/
/*! exports provided: clearTracingIfCancelled, startTracer, isTracingSupported, TraceIdentifier */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearTracingIfCancelled", function() { return clearTracingIfCancelled; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startTracer", function() { return startTracer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTracingSupported", function() { return isTracingSupported; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TraceIdentifier", function() { return TraceIdentifier; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./.yarn/cache/tslib-npm-1.14.1-102499115e-dbe628ef87.zip/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");


function clearTracingIfCancelled(context) {
    if (context.status === 0) {
        context.traceId = undefined;
        context.spanId = undefined;
    }
}
function startTracer(configuration) {
    return {
        clearTracingIfCancelled: clearTracingIfCancelled,
        traceFetch: function (context) {
            return injectHeadersIfTracingAllowed(configuration, context, function (tracingHeaders) {
                var _a;
                if (context.input instanceof Request && !((_a = context.init) === null || _a === void 0 ? void 0 : _a.headers)) {
                    context.input = new Request(context.input);
                    Object.keys(tracingHeaders).forEach(function (key) {
                        ;
                        context.input.headers.append(key, tracingHeaders[key]);
                    });
                }
                else {
                    context.init = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, context.init);
                    var headers_1 = [];
                    if (context.init.headers instanceof Headers) {
                        context.init.headers.forEach(function (value, key) {
                            headers_1.push([key, value]);
                        });
                    }
                    else if (Array.isArray(context.init.headers)) {
                        context.init.headers.forEach(function (header) {
                            headers_1.push(header);
                        });
                    }
                    else if (context.init.headers) {
                        Object.keys(context.init.headers).forEach(function (key) {
                            headers_1.push([key, context.init.headers[key]]);
                        });
                    }
                    context.init.headers = headers_1.concat(Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["objectEntries"])(tracingHeaders));
                }
            });
        },
        traceXhr: function (context, xhr) {
            return injectHeadersIfTracingAllowed(configuration, context, function (tracingHeaders) {
                Object.keys(tracingHeaders).forEach(function (name) {
                    xhr.setRequestHeader(name, tracingHeaders[name]);
                });
            });
        },
    };
}
function injectHeadersIfTracingAllowed(configuration, context, inject) {
    if (!isTracingSupported() || !isAllowedUrl(configuration, context.url)) {
        return;
    }
    context.traceId = new TraceIdentifier();
    context.spanId = new TraceIdentifier();
    inject(makeTracingHeaders(context.traceId, context.spanId));
}
function isAllowedUrl(configuration, requestUrl) {
    var requestOrigin = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__["getOrigin"])(requestUrl);
    for (var _i = 0, _a = configuration.allowedTracingOrigins; _i < _a.length; _i++) {
        var allowedOrigin = _a[_i];
        if (requestOrigin === allowedOrigin || (allowedOrigin instanceof RegExp && allowedOrigin.test(requestOrigin))) {
            return true;
        }
    }
    return false;
}
function isTracingSupported() {
    return getCrypto() !== undefined;
}
function getCrypto() {
    return window.crypto || window.msCrypto;
}
function makeTracingHeaders(traceId, spanId) {
    return {
        'x-datadog-origin': 'rum',
        'x-datadog-parent-id': spanId.toDecimalString(),
        'x-datadog-sampled': '1',
        'x-datadog-sampling-priority': '1',
        'x-datadog-trace-id': traceId.toDecimalString(),
    };
}
/* eslint-disable no-bitwise */
var TraceIdentifier = /** @class */ (function () {
    function TraceIdentifier() {
        this.buffer = new Uint8Array(8);
        getCrypto().getRandomValues(this.buffer);
        this.buffer[0] = this.buffer[0] & 0x7f; // force 63-bit
    }
    TraceIdentifier.prototype.toString = function (radix) {
        var high = this.readInt32(0);
        var low = this.readInt32(4);
        var str = '';
        while (1) {
            var mod = (high % radix) * 4294967296 + low;
            high = Math.floor(high / radix);
            low = Math.floor(mod / radix);
            str = (mod % radix).toString(radix) + str;
            if (!high && !low) {
                break;
            }
        }
        return str;
    };
    /**
     * Format used everywhere except the trace intake
     */
    TraceIdentifier.prototype.toDecimalString = function () {
        return this.toString(10);
    };
    TraceIdentifier.prototype.readInt32 = function (offset) {
        return (this.buffer[offset] * 16777216 +
            (this.buffer[offset + 1] << 16) +
            (this.buffer[offset + 2] << 8) +
            this.buffer[offset + 3]);
    };
    return TraceIdentifier;
}());

/* eslint-enable no-bitwise */
//# sourceMappingURL=tracer.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/trackEventCounts.js":
/*!*********************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/trackEventCounts.js ***!
  \*********************************************************************************************************************************************************/
/*! exports provided: trackEventCounts */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackEventCounts", function() { return trackEventCounts; });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");
/* harmony import */ var _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rawRumEvent.types */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/rawRumEvent.types.js");
/* harmony import */ var _lifeCycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lifeCycle */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js");



function trackEventCounts(lifeCycle, callback) {
    if (callback === void 0) { callback = _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["noop"]; }
    var eventCounts = {
        errorCount: 0,
        longTaskCount: 0,
        resourceCount: 0,
        userActionCount: 0,
    };
    var subscription = lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_2__["LifeCycleEventType"].RUM_EVENT_COLLECTED, function (_a) {
        var type = _a.type;
        switch (type) {
            case _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_1__["RumEventType"].ERROR:
                eventCounts.errorCount += 1;
                callback(eventCounts);
                break;
            case _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_1__["RumEventType"].ACTION:
                eventCounts.userActionCount += 1;
                callback(eventCounts);
                break;
            case _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_1__["RumEventType"].LONG_TASK:
                eventCounts.longTaskCount += 1;
                callback(eventCounts);
                break;
            case _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_1__["RumEventType"].RESOURCE:
                eventCounts.resourceCount += 1;
                callback(eventCounts);
                break;
        }
    });
    return {
        stop: function () {
            subscription.unsubscribe();
        },
        eventCounts: eventCounts,
    };
}
//# sourceMappingURL=trackEventCounts.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/trackPageActivities.js":
/*!************************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/trackPageActivities.js ***!
  \************************************************************************************************************************************************************/
/*! exports provided: PAGE_ACTIVITY_VALIDATION_DELAY, PAGE_ACTIVITY_END_DELAY, PAGE_ACTIVITY_MAX_DURATION, waitIdlePageActivity, trackPageActivities, waitPageActivitiesCompletion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PAGE_ACTIVITY_VALIDATION_DELAY", function() { return PAGE_ACTIVITY_VALIDATION_DELAY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PAGE_ACTIVITY_END_DELAY", function() { return PAGE_ACTIVITY_END_DELAY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PAGE_ACTIVITY_MAX_DURATION", function() { return PAGE_ACTIVITY_MAX_DURATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "waitIdlePageActivity", function() { return waitIdlePageActivity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackPageActivities", function() { return trackPageActivities; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "waitPageActivitiesCompletion", function() { return waitPageActivitiesCompletion; });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");
/* harmony import */ var _lifeCycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lifeCycle */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js");


// Delay to wait for a page activity to validate the tracking process
var PAGE_ACTIVITY_VALIDATION_DELAY = 100;
// Delay to wait after a page activity to end the tracking process
var PAGE_ACTIVITY_END_DELAY = 100;
// Maximum duration of the tracking process
var PAGE_ACTIVITY_MAX_DURATION = 10000;
function waitIdlePageActivity(lifeCycle, completionCallback) {
    var _a = trackPageActivities(lifeCycle), pageActivitiesObservable = _a.observable, stopPageActivitiesTracking = _a.stop;
    var stopWaitPageActivitiesCompletion = waitPageActivitiesCompletion(pageActivitiesObservable, stopPageActivitiesTracking, completionCallback).stop;
    var stop = function () {
        stopWaitPageActivitiesCompletion();
        stopPageActivitiesTracking();
    };
    return { stop: stop };
}
// Automatic action collection lifecycle overview:
//                      (Start new trackPageActivities)
//              .-------------------'--------------------.
//              v                                        v
//     [Wait for a page activity ]          [Wait for a maximum duration]
//     [timeout: VALIDATION_DELAY]          [  timeout: MAX_DURATION    ]
//          /                  \                           |
//         v                    v                          |
//  [No page activity]   [Page activity]                   |
//         |                   |,----------------------.   |
//         v                   v                       |   |
//     (Discard)     [Wait for a page activity]        |   |
//                   [   timeout: END_DELAY   ]        |   |
//                       /                \            |   |
//                      v                  v           |   |
//             [No page activity]    [Page activity]   |   |
//                      |                 |            |   |
//                      |                 '------------'   |
//                      '-----------. ,--------------------'
//                                   v
//                                 (End)
//
// Note: because MAX_DURATION > VALIDATION_DELAY, we are sure that if the process is still alive
// after MAX_DURATION, it has been validated.
function trackPageActivities(lifeCycle) {
    var observable = new _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["Observable"]();
    var subscriptions = [];
    var firstRequestIndex;
    var pendingRequestsCount = 0;
    subscriptions.push(lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_1__["LifeCycleEventType"].DOM_MUTATED, function () { return notifyPageActivity(); }));
    subscriptions.push(lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_1__["LifeCycleEventType"].PERFORMANCE_ENTRY_COLLECTED, function (entry) {
        if (entry.entryType !== 'resource') {
            return;
        }
        notifyPageActivity();
    }));
    subscriptions.push(lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_1__["LifeCycleEventType"].REQUEST_STARTED, function (startEvent) {
        if (firstRequestIndex === undefined) {
            firstRequestIndex = startEvent.requestIndex;
        }
        pendingRequestsCount += 1;
        notifyPageActivity();
    }));
    subscriptions.push(lifeCycle.subscribe(_lifeCycle__WEBPACK_IMPORTED_MODULE_1__["LifeCycleEventType"].REQUEST_COMPLETED, function (request) {
        // If the request started before the tracking start, ignore it
        if (firstRequestIndex === undefined || request.requestIndex < firstRequestIndex) {
            return;
        }
        pendingRequestsCount -= 1;
        notifyPageActivity();
    }));
    function notifyPageActivity() {
        observable.notify({ isBusy: pendingRequestsCount > 0 });
    }
    return {
        observable: observable,
        stop: function () {
            subscriptions.forEach(function (s) { return s.unsubscribe(); });
        },
    };
}
function waitPageActivitiesCompletion(pageActivitiesObservable, stopPageActivitiesTracking, completionCallback) {
    var idleTimeoutId;
    var hasCompleted = false;
    var validationTimeoutId = setTimeout(Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["monitor"])(function () { return complete(false, 0); }), PAGE_ACTIVITY_VALIDATION_DELAY);
    var maxDurationTimeoutId = setTimeout(Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["monitor"])(function () { return complete(true, Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["relativeNow"])()); }), PAGE_ACTIVITY_MAX_DURATION);
    pageActivitiesObservable.subscribe(function (_a) {
        var isBusy = _a.isBusy;
        clearTimeout(validationTimeoutId);
        clearTimeout(idleTimeoutId);
        var lastChangeTime = Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["relativeNow"])();
        if (!isBusy) {
            idleTimeoutId = setTimeout(Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["monitor"])(function () { return complete(true, lastChangeTime); }), PAGE_ACTIVITY_END_DELAY);
        }
    });
    var stop = function () {
        hasCompleted = true;
        clearTimeout(validationTimeoutId);
        clearTimeout(idleTimeoutId);
        clearTimeout(maxDurationTimeoutId);
        stopPageActivitiesTracking();
    };
    function complete(hadActivity, endTime) {
        if (hasCompleted) {
            return;
        }
        stop();
        completionCallback(hadActivity, endTime);
    }
    return { stop: stop };
}
//# sourceMappingURL=trackPageActivities.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/index.js":
/*!***************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/index.js ***!
  \***************************************************************************************************************************************/
/*! exports provided: makeRumPublicApi, startRum, LifeCycle, LifeCycleEventType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _boot_rumPublicApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot/rumPublicApi */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/boot/rumPublicApi.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "makeRumPublicApi", function() { return _boot_rumPublicApi__WEBPACK_IMPORTED_MODULE_0__["makeRumPublicApi"]; });

/* harmony import */ var _boot_rum__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./boot/rum */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/boot/rum.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "startRum", function() { return _boot_rum__WEBPACK_IMPORTED_MODULE_1__["startRum"]; });

/* harmony import */ var _domain_lifeCycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./domain/lifeCycle */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LifeCycle", function() { return _domain_lifeCycle__WEBPACK_IMPORTED_MODULE_2__["LifeCycle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LifeCycleEventType", function() { return _domain_lifeCycle__WEBPACK_IMPORTED_MODULE_2__["LifeCycleEventType"]; });




//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/rawRumEvent.types.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/rawRumEvent.types.js ***!
  \***************************************************************************************************************************************************/
/*! exports provided: RumEventType, ViewLoadingType, ActionType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RumEventType", function() { return RumEventType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ViewLoadingType", function() { return ViewLoadingType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActionType", function() { return ActionType; });
var RumEventType;
(function (RumEventType) {
    RumEventType["ACTION"] = "action";
    RumEventType["ERROR"] = "error";
    RumEventType["LONG_TASK"] = "long_task";
    RumEventType["VIEW"] = "view";
    RumEventType["RESOURCE"] = "resource";
})(RumEventType || (RumEventType = {}));
var ViewLoadingType;
(function (ViewLoadingType) {
    ViewLoadingType["INITIAL_LOAD"] = "initial_load";
    ViewLoadingType["ROUTE_CHANGE"] = "route_change";
})(ViewLoadingType || (ViewLoadingType = {}));
var ActionType;
(function (ActionType) {
    ActionType["CLICK"] = "click";
    ActionType["CUSTOM"] = "custom";
})(ActionType || (ActionType = {}));
//# sourceMappingURL=rawRumEvent.types.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/transport/batch.js":
/*!*************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/transport/batch.js ***!
  \*************************************************************************************************************************************************/
/*! exports provided: startRumBatch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startRumBatch", function() { return startRumBatch; });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");
/* harmony import */ var _domain_lifeCycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../domain/lifeCycle */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js");
/* harmony import */ var _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rawRumEvent.types */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/rawRumEvent.types.js");



function startRumBatch(configuration, lifeCycle) {
    var batch = makeRumBatch(configuration, lifeCycle);
    lifeCycle.subscribe(_domain_lifeCycle__WEBPACK_IMPORTED_MODULE_1__["LifeCycleEventType"].RUM_EVENT_COLLECTED, function (serverRumEvent) {
        if (serverRumEvent.type === _rawRumEvent_types__WEBPACK_IMPORTED_MODULE_2__["RumEventType"].VIEW) {
            batch.upsert(serverRumEvent, serverRumEvent.view.id);
        }
        else {
            batch.add(serverRumEvent);
        }
    });
    return {
        stop: function () {
            batch.stop();
        },
    };
}
function makeRumBatch(configuration, lifeCycle) {
    var primaryBatch = createRumBatch(configuration.rumEndpoint, function () {
        return lifeCycle.notify(_domain_lifeCycle__WEBPACK_IMPORTED_MODULE_1__["LifeCycleEventType"].BEFORE_UNLOAD);
    });
    var replicaBatch;
    var replica = configuration.replica;
    if (replica !== undefined) {
        replicaBatch = createRumBatch(replica.rumEndpoint);
    }
    function createRumBatch(endpointUrl, unloadCallback) {
        return new _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["Batch"](new _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["HttpRequest"](endpointUrl, configuration.batchBytesLimit, true), configuration.maxBatchSize, configuration.batchBytesLimit, configuration.maxMessageSize, configuration.flushTimeout, unloadCallback);
    }
    function withReplicaApplicationId(message) {
        return Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["combine"])(message, { application: { id: replica.applicationId } });
    }
    var stopped = false;
    return {
        add: function (message) {
            if (stopped) {
                return;
            }
            primaryBatch.add(message);
            if (replicaBatch) {
                replicaBatch.add(withReplicaApplicationId(message));
            }
        },
        stop: function () {
            stopped = true;
        },
        upsert: function (message, key) {
            if (stopped) {
                return;
            }
            primaryBatch.upsert(message, key);
            if (replicaBatch) {
                replicaBatch.upsert(withReplicaApplicationId(message), key);
            }
        },
    };
}
//# sourceMappingURL=batch.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-npm-2.7.4-f7ffa3056a-23d29cbd7d.zip/node_modules/@datadog/browser-rum/esm/boot/rum.entry.js":
/*!**************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-npm-2.7.4-f7ffa3056a-23d29cbd7d.zip/node_modules/@datadog/browser-rum/esm/boot/rum.entry.js ***!
  \**************************************************************************************************************************************/
/*! exports provided: datadogRum */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "datadogRum", function() { return datadogRum; });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ "./.yarn/cache/@datadog-browser-core-npm-2.7.4-0ab34ac338-58b45bfa81.zip/node_modules/@datadog/browser-core/esm/index.js");
/* harmony import */ var _datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-rum-core */ "./.yarn/cache/@datadog-browser-rum-core-npm-2.7.4-cc52360ef1-6d002a16e0.zip/node_modules/@datadog/browser-rum-core/esm/index.js");


var datadogRum = Object(_datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_1__["makeRumPublicApi"])(_datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_1__["startRum"]);
Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["defineGlobal"])(Object(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__["getGlobalObject"])(), 'DD_RUM', datadogRum);
//# sourceMappingURL=rum.entry.js.map

/***/ }),

/***/ "./.yarn/cache/@datadog-browser-rum-npm-2.7.4-f7ffa3056a-23d29cbd7d.zip/node_modules/@datadog/browser-rum/esm/index.js":
/*!*****************************************************************************************************************************!*\
  !*** ./.yarn/cache/@datadog-browser-rum-npm-2.7.4-f7ffa3056a-23d29cbd7d.zip/node_modules/@datadog/browser-rum/esm/index.js ***!
  \*****************************************************************************************************************************/
/*! exports provided: datadogRum */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _boot_rum_entry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot/rum.entry */ "./.yarn/cache/@datadog-browser-rum-npm-2.7.4-f7ffa3056a-23d29cbd7d.zip/node_modules/@datadog/browser-rum/esm/boot/rum.entry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "datadogRum", function() { return _boot_rum_entry__WEBPACK_IMPORTED_MODULE_0__["datadogRum"]; });

// Keep the following in sync with packages/rum-recorder/src/index.ts

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./.yarn/cache/react-is-npm-16.13.1-a9b9382b4f-f7a19ac349.zip/node_modules/react-is/cjs/react-is.development.js":
/*!**********************************************************************************************************************!*\
  !*** ./.yarn/cache/react-is-npm-16.13.1-a9b9382b4f-f7a19ac349.zip/node_modules/react-is/cjs/react-is.development.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./.yarn/cache/react-is-npm-16.13.1-a9b9382b4f-f7a19ac349.zip/node_modules/react-is/index.js":
/*!***************************************************************************************************!*\
  !*** ./.yarn/cache/react-is-npm-16.13.1-a9b9382b4f-f7a19ac349.zip/node_modules/react-is/index.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./.yarn/cache/react-is-npm-16.13.1-a9b9382b4f-f7a19ac349.zip/node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./.yarn/cache/react-npm-17.0.1-98658812fc-83b9df9529.zip/node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************************************************!*\
  !*** ./.yarn/cache/react-npm-17.0.1-98658812fc-83b9df9529.zip/node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.1
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var React = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.1-98658812fc-83b9df9529.zip/node_modules/react/index.js");
var _assign = __webpack_require__(/*! object-assign */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/build/polyfills/object-assign.js");

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
var REACT_STRICT_MODE_TYPE = 0xeacc;
var REACT_PROFILER_TYPE = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
var REACT_SUSPENSE_TYPE = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return 'Profiler';

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown;
var specialPropRefWarningShown;
var didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function warnIfStringRefCannotBeAutoConverted(config, self) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}

function defineKeyPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingKey = function () {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingKey.isReactWarning = true;
    Object.defineProperty(props, 'key', {
      get: warnAboutAccessingKey,
      configurable: true
    });
  }
}

function defineRefPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingRef = function () {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingRef.isReactWarning = true;
    Object.defineProperty(props, 'ref', {
      get: warnAboutAccessingRef,
      configurable: true
    });
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */

function jsxDEV(type, config, maybeKey, source, self) {
  {
    var propName; // Reserved names are extracted

    var props = {};
    var key = null;
    var ref = null; // Currently, key can be spread in as a prop. This causes a potential
    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
    // but as an intermediary step, we will use jsxDEV for everything except
    // <div {...props} key="Hi" />, because we aren't currently able to tell if
    // key is explicitly declared to be undefined or not.

    if (maybeKey !== undefined) {
      key = '' + maybeKey;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    if (hasValidRef(config)) {
      ref = config.ref;
      warnIfStringRefCannotBeAutoConverted(config, self);
    } // Remaining properties are added to a new props object


    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    } // Resolve default props


    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;

      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }

    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }

    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  }
}

var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }
}

function getDeclarationErrorAddendum() {
  {
    if (ReactCurrentOwner$1.current) {
      var name = getComponentName(ReactCurrentOwner$1.current.type);

      if (name) {
        return '\n\nCheck the render method of `' + name + '`.';
      }
    }

    return '';
  }
}

function getSourceInfoErrorAddendum(source) {
  {
    if (source !== undefined) {
      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
      var lineNumber = source.lineNumber;
      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
    }

    return '';
  }
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  {
    var info = getDeclarationErrorAddendum();

    if (!info) {
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

      if (parentName) {
        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
      }
    }

    return info;
  }
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  {
    if (!element._store || element._store.validated || element.key != null) {
      return;
    }

    element._store.validated = true;
    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }

    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
    // property, it may be the creator of the child that's responsible for
    // assigning it a key.

    var childOwner = '';

    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
      // Give the component that originally created this child.
      childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
    }

    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  {
    if (typeof node !== 'object') {
      return;
    }

    if (Array.isArray(node)) {
      for (var i = 0; i < node.length; i++) {
        var child = node[i];

        if (isValidElement(child)) {
          validateExplicitKey(child, parentType);
        }
      }
    } else if (isValidElement(node)) {
      // This element was passed in a valid location.
      if (node._store) {
        node._store.validated = true;
      }
    } else if (node) {
      var iteratorFn = getIteratorFn(node);

      if (typeof iteratorFn === 'function') {
        // Entry iterators used to provide implicit keys,
        // but now we print a separate warning for them later.
        if (iteratorFn !== node.entries) {
          var iterator = iteratorFn.call(node);
          var step;

          while (!(step = iterator.next()).done) {
            if (isValidElement(step.value)) {
              validateExplicitKey(step.value, parentType);
            }
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}

function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
  {
    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.

    if (!validType) {
      var info = '';

      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }

      var sourceInfo = getSourceInfoErrorAddendum(source);

      if (sourceInfo) {
        info += sourceInfo;
      } else {
        info += getDeclarationErrorAddendum();
      }

      var typeString;

      if (type === null) {
        typeString = 'null';
      } else if (Array.isArray(type)) {
        typeString = 'array';
      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
        typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
        info = ' Did you accidentally export a JSX literal instead of a component?';
      } else {
        typeString = typeof type;
      }

      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }

    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.

    if (element == null) {
      return element;
    } // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)


    if (validType) {
      var children = props.children;

      if (children !== undefined) {
        if (isStaticChildren) {
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              validateChildKeys(children[i], type);
            }

            if (Object.freeze) {
              Object.freeze(children);
            }
          } else {
            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
          }
        } else {
          validateChildKeys(children, type);
        }
      }
    }

    if (type === exports.Fragment) {
      validateFragmentProps(element);
    } else {
      validatePropTypes(element);
    }

    return element;
  }
} // These two functions exist to still get child warnings in dev

var jsxDEV$1 =  jsxWithValidation ;

exports.jsxDEV = jsxDEV$1;
  })();
}


/***/ }),

/***/ "./.yarn/cache/react-npm-17.0.1-98658812fc-83b9df9529.zip/node_modules/react/cjs/react.development.js":
/*!************************************************************************************************************!*\
  !*** ./.yarn/cache/react-npm-17.0.1-98658812fc-83b9df9529.zip/node_modules/react/cjs/react.development.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.1
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var _assign = __webpack_require__(/*! object-assign */ "./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/build/polyfills/object-assign.js");

// TODO: this is special because it gets imported during build.
var ReactVersion = '17.0.1';

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
exports.StrictMode = 0xeacc;
exports.Profiler = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
exports.Suspense = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  exports.StrictMode = symbolFor('react.strict_mode');
  exports.Profiler = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  exports.Suspense = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

/**
 * Keeps track of the current dispatcher.
 */
var ReactCurrentDispatcher = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

/**
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
 */
var ReactCurrentBatchConfig = {
  transition: 0
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var ReactDebugCurrentFrame = {};
var currentExtraStackFrame = null;
function setExtraStackFrame(stack) {
  {
    currentExtraStackFrame = stack;
  }
}

{
  ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {
    {
      currentExtraStackFrame = stack;
    }
  }; // Stack implementation injected by the current renderer.


  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var stack = ''; // Add an extra top frame while an element is being validated

    if (currentExtraStackFrame) {
      stack += currentExtraStackFrame;
    } // Delegate to the injected renderer-specific implementation


    var impl = ReactDebugCurrentFrame.getCurrentStack;

    if (impl) {
      stack += impl() || '';
    }

    return stack;
  };
}

/**
 * Used by act() to track whether you're inside an act() scope.
 */
var IsSomeRendererActing = {
  current: false
};

var ReactSharedInternals = {
  ReactCurrentDispatcher: ReactCurrentDispatcher,
  ReactCurrentBatchConfig: ReactCurrentBatchConfig,
  ReactCurrentOwner: ReactCurrentOwner,
  IsSomeRendererActing: IsSomeRendererActing,
  // Used by renderers to avoid bundling object-assign twice in UMD bundles:
  assign: _assign
};

{
  ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
}

// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.

function warn(format) {
  {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    printWarning('warn', format, args);
  }
}
function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
    var warningKey = componentName + "." + callerName;

    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }

    error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);

    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}
/**
 * This is the abstract API for an update queue.
 */


var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

var emptyObject = {};

{
  Object.freeze(emptyObject);
}
/**
 * Base class helpers for the updating state of a component.
 */


function Component(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
  // renderer.

  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};
/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */

Component.prototype.setState = function (partialState, callback) {
  if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {
    {
      throw Error( "setState(...): takes an object of state variables to update or a function which returns an object of state variables." );
    }
  }

  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */


Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};
/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */


{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };

  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);

        return undefined;
      }
    });
  };

  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

function ComponentDummy() {}

ComponentDummy.prototype = Component.prototype;
/**
 * Convenience component with default shallow equality check for sCU.
 */

function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

_assign(pureComponentPrototype, Component.prototype);

pureComponentPrototype.isPureReactComponent = true;

// an immutable object with a single mutable value
function createRef() {
  var refObject = {
    current: null
  };

  {
    Object.seal(refObject);
  }

  return refObject;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case exports.Profiler:
      return 'Profiler';

    case exports.StrictMode:
      return 'StrictMode';

    case exports.Suspense:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

function warnIfStringRefCannotBeAutoConverted(config) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */

function createElement(type, config, children) {
  var propName; // Reserved names are extracted

  var props = {};
  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;

      {
        warnIfStringRefCannotBeAutoConverted(config);
      }
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }

    props.children = childArray;
  } // Resolve default props


  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;

    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }

  {
    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}
function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
  return newElement;
}
/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */

function cloneElement(element, config, children) {
  if (!!(element === null || element === undefined)) {
    {
      throw Error( "React.cloneElement(...): The argument must be a React element, but you passed " + element + "." );
    }
  }

  var propName; // Original props are copied

  var props = _assign({}, element.props); // Reserved names are extracted


  var key = element.key;
  var ref = element.ref; // Self is preserved since the owner is preserved.

  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.

  var source = element._source; // Owner will be preserved, unless ref is overridden

  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    } // Remaining properties override existing props


    var defaultProps;

    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';
/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = key.replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });
  return '$' + escapedString;
}
/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */


var didWarnAboutMaps = false;
var userProvidedKeyEscapeRegex = /\/+/g;

function escapeUserProvidedKey(text) {
  return text.replace(userProvidedKeyEscapeRegex, '$&/');
}
/**
 * Generate a key string that identifies a element within a set.
 *
 * @param {*} element A element that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */


function getElementKey(element, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof element === 'object' && element !== null && element.key != null) {
    // Explicit key
    return escape('' + element.key);
  } // Implicit key determined by the index in the set


  return index.toString(36);
}

function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;

      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }

    }
  }

  if (invokeCallback) {
    var _child = children;
    var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows:

    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;

    if (Array.isArray(mappedChild)) {
      var escapedChildKey = '';

      if (childKey != null) {
        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
      }

      mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {
        return c;
      });
    } else if (mappedChild != null) {
      if (isValidElement(mappedChild)) {
        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
        // traverseAllChildren used to do for objects as children
        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
        mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
        escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
      }

      array.push(mappedChild);
    }

    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.

  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getElementKey(child, i);
      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
    }
  } else {
    var iteratorFn = getIteratorFn(children);

    if (typeof iteratorFn === 'function') {
      var iterableChildren = children;

      {
        // Warn about using Maps as children
        if (iteratorFn === iterableChildren.entries) {
          if (!didWarnAboutMaps) {
            warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
          }

          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(iterableChildren);
      var step;
      var ii = 0;

      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getElementKey(child, ii++);
        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
      }
    } else if (type === 'object') {
      var childrenString = '' + children;

      {
        {
          throw Error( "Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). If you meant to render a collection of children, use an array instead." );
        }
      }
    }
  }

  return subtreeCount;
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }

  var result = [];
  var count = 0;
  mapIntoArray(children, result, '', '', function (child) {
    return func.call(context, child, count++);
  });
  return result;
}
/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */


function countChildren(children) {
  var n = 0;
  mapChildren(children, function () {
    n++; // Don't return anything
  });
  return n;
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  mapChildren(children, function () {
    forEachFunc.apply(this, arguments); // Don't return anything.
  }, forEachContext);
}
/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */


function toArray(children) {
  return mapChildren(children, function (child) {
    return child;
  }) || [];
}
/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */


function onlyChild(children) {
  if (!isValidElement(children)) {
    {
      throw Error( "React.Children.only expected to receive a single React element child." );
    }
  }

  return children;
}

function createContext(defaultValue, calculateChangedBits) {
  if (calculateChangedBits === undefined) {
    calculateChangedBits = null;
  } else {
    {
      if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') {
        error('createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits);
      }
    }
  }

  var context = {
    $$typeof: REACT_CONTEXT_TYPE,
    _calculateChangedBits: calculateChangedBits,
    // As a workaround to support multiple concurrent renderers, we categorize
    // some renderers as primary and others as secondary. We only expect
    // there to be two concurrent renderers at most: React Native (primary) and
    // Fabric (secondary); React DOM (primary) and React ART (secondary).
    // Secondary renderers store their context values on separate fields.
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    // Used to track how many concurrent renderers this context currently
    // supports within in a single renderer. Such as parallel server rendering.
    _threadCount: 0,
    // These are circular
    Provider: null,
    Consumer: null
  };
  context.Provider = {
    $$typeof: REACT_PROVIDER_TYPE,
    _context: context
  };
  var hasWarnedAboutUsingNestedContextConsumers = false;
  var hasWarnedAboutUsingConsumerProvider = false;
  var hasWarnedAboutDisplayNameOnConsumer = false;

  {
    // A separate object, but proxies back to the original context object for
    // backwards compatibility. It has a different $$typeof, so we can properly
    // warn for the incorrect usage of Context as a Consumer.
    var Consumer = {
      $$typeof: REACT_CONTEXT_TYPE,
      _context: context,
      _calculateChangedBits: context._calculateChangedBits
    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

    Object.defineProperties(Consumer, {
      Provider: {
        get: function () {
          if (!hasWarnedAboutUsingConsumerProvider) {
            hasWarnedAboutUsingConsumerProvider = true;

            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
          }

          return context.Provider;
        },
        set: function (_Provider) {
          context.Provider = _Provider;
        }
      },
      _currentValue: {
        get: function () {
          return context._currentValue;
        },
        set: function (_currentValue) {
          context._currentValue = _currentValue;
        }
      },
      _currentValue2: {
        get: function () {
          return context._currentValue2;
        },
        set: function (_currentValue2) {
          context._currentValue2 = _currentValue2;
        }
      },
      _threadCount: {
        get: function () {
          return context._threadCount;
        },
        set: function (_threadCount) {
          context._threadCount = _threadCount;
        }
      },
      Consumer: {
        get: function () {
          if (!hasWarnedAboutUsingNestedContextConsumers) {
            hasWarnedAboutUsingNestedContextConsumers = true;

            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
          }

          return context.Consumer;
        }
      },
      displayName: {
        get: function () {
          return context.displayName;
        },
        set: function (displayName) {
          if (!hasWarnedAboutDisplayNameOnConsumer) {
            warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);

            hasWarnedAboutDisplayNameOnConsumer = true;
          }
        }
      }
    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

    context.Consumer = Consumer;
  }

  {
    context._currentRenderer = null;
    context._currentRenderer2 = null;
  }

  return context;
}

var Uninitialized = -1;
var Pending = 0;
var Resolved = 1;
var Rejected = 2;

function lazyInitializer(payload) {
  if (payload._status === Uninitialized) {
    var ctor = payload._result;
    var thenable = ctor(); // Transition to the next state.

    var pending = payload;
    pending._status = Pending;
    pending._result = thenable;
    thenable.then(function (moduleObject) {
      if (payload._status === Pending) {
        var defaultExport = moduleObject.default;

        {
          if (defaultExport === undefined) {
            error('lazy: Expected the result of a dynamic import() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + // Break up imports to avoid accidentally parsing them as dependencies.
            'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
          }
        } // Transition to the next state.


        var resolved = payload;
        resolved._status = Resolved;
        resolved._result = defaultExport;
      }
    }, function (error) {
      if (payload._status === Pending) {
        // Transition to the next state.
        var rejected = payload;
        rejected._status = Rejected;
        rejected._result = error;
      }
    });
  }

  if (payload._status === Resolved) {
    return payload._result;
  } else {
    throw payload._result;
  }
}

function lazy(ctor) {
  var payload = {
    // We use these fields to store the result.
    _status: -1,
    _result: ctor
  };
  var lazyType = {
    $$typeof: REACT_LAZY_TYPE,
    _payload: payload,
    _init: lazyInitializer
  };

  {
    // In production, this would just set it on the object.
    var defaultProps;
    var propTypes; // $FlowFixMe

    Object.defineProperties(lazyType, {
      defaultProps: {
        configurable: true,
        get: function () {
          return defaultProps;
        },
        set: function (newDefaultProps) {
          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          defaultProps = newDefaultProps; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'defaultProps', {
            enumerable: true
          });
        }
      },
      propTypes: {
        configurable: true,
        get: function () {
          return propTypes;
        },
        set: function (newPropTypes) {
          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          propTypes = newPropTypes; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'propTypes', {
            enumerable: true
          });
        }
      }
    });
  }

  return lazyType;
}

function forwardRef(render) {
  {
    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
    } else if (typeof render !== 'function') {
      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
    } else {
      if (render.length !== 0 && render.length !== 2) {
        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
      }
    }

    if (render != null) {
      if (render.defaultProps != null || render.propTypes != null) {
        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
      }
    }
  }

  var elementType = {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (render.displayName == null) {
          render.displayName = name;
        }
      }
    });
  }

  return elementType;
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function memo(type, compare) {
  {
    if (!isValidElementType(type)) {
      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
    }
  }

  var elementType = {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: compare === undefined ? null : compare
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (type.displayName == null) {
          type.displayName = name;
        }
      }
    });
  }

  return elementType;
}

function resolveDispatcher() {
  var dispatcher = ReactCurrentDispatcher.current;

  if (!(dispatcher !== null)) {
    {
      throw Error( "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem." );
    }
  }

  return dispatcher;
}

function useContext(Context, unstable_observedBits) {
  var dispatcher = resolveDispatcher();

  {
    if (unstable_observedBits !== undefined) {
      error('useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://reactjs.org/link/rules-of-hooks' : '');
    } // TODO: add a more generic warning for invalid values.


    if (Context._context !== undefined) {
      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
      // and nobody should be using this in existing code.

      if (realContext.Consumer === Context) {
        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
      } else if (realContext.Provider === Context) {
        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
      }
    }
  }

  return dispatcher.useContext(Context, unstable_observedBits);
}
function useState(initialState) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}
function useReducer(reducer, initialArg, init) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}
function useRef(initialValue) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
function useEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}
function useLayoutEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, deps);
}
function useCallback(callback, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useCallback(callback, deps);
}
function useMemo(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useMemo(create, deps);
}
function useImperativeHandle(ref, create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useImperativeHandle(ref, create, deps);
}
function useDebugValue(value, formatterFn) {
  {
    var dispatcher = resolveDispatcher();
    return dispatcher.useDebugValue(value, formatterFn);
  }
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher$1.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher$1.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case exports.Suspense:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      setExtraStackFrame(stack);
    } else {
      setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current.type);

    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }

  return '';
}

function getSourceInfoErrorAddendum(source) {
  if (source !== undefined) {
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }

  return '';
}

function getSourceInfoErrorAddendumForProps(elementProps) {
  if (elementProps !== null && elementProps !== undefined) {
    return getSourceInfoErrorAddendum(elementProps.__source);
  }

  return '';
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

    if (parentName) {
      info = "\n\nCheck the top-level render call using <" + parentName + ">.";
    }
  }

  return info;
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }

  element._store.validated = true;
  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }

  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.

  var childOwner = '';

  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
  }

  {
    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }

  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];

      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);

    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;

        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}
function createElementWithValidation(type, props, children) {
  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.

  if (!validType) {
    var info = '';

    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendumForProps(props);

    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    var typeString;

    if (type === null) {
      typeString = 'null';
    } else if (Array.isArray(type)) {
      typeString = 'array';
    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
      typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
      info = ' Did you accidentally export a JSX literal instead of a component?';
    } else {
      typeString = typeof type;
    }

    {
      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }
  }

  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.

  if (element == null) {
    return element;
  } // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)


  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (type === exports.Fragment) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}
var didWarnAboutDeprecatedCreateFactory = false;
function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  validatedFactory.type = type;

  {
    if (!didWarnAboutDeprecatedCreateFactory) {
      didWarnAboutDeprecatedCreateFactory = true;

      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
    } // Legacy hook: remove it


    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');

        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}
function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);

  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }

  validatePropTypes(newElement);
  return newElement;
}

{

  try {
    var frozenObject = Object.freeze({});
    /* eslint-disable no-new */

    new Map([[frozenObject, null]]);
    new Set([frozenObject]);
    /* eslint-enable no-new */
  } catch (e) {
  }
}

var createElement$1 =  createElementWithValidation ;
var cloneElement$1 =  cloneElementWithValidation ;
var createFactory =  createFactoryWithValidation ;
var Children = {
  map: mapChildren,
  forEach: forEachChildren,
  count: countChildren,
  toArray: toArray,
  only: onlyChild
};

exports.Children = Children;
exports.Component = Component;
exports.PureComponent = PureComponent;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
exports.cloneElement = cloneElement$1;
exports.createContext = createContext;
exports.createElement = createElement$1;
exports.createFactory = createFactory;
exports.createRef = createRef;
exports.forwardRef = forwardRef;
exports.isValidElement = isValidElement;
exports.lazy = lazy;
exports.memo = memo;
exports.useCallback = useCallback;
exports.useContext = useContext;
exports.useDebugValue = useDebugValue;
exports.useEffect = useEffect;
exports.useImperativeHandle = useImperativeHandle;
exports.useLayoutEffect = useLayoutEffect;
exports.useMemo = useMemo;
exports.useReducer = useReducer;
exports.useRef = useRef;
exports.useState = useState;
exports.version = ReactVersion;
  })();
}


/***/ }),

/***/ "./.yarn/cache/react-npm-17.0.1-98658812fc-83b9df9529.zip/node_modules/react/index.js":
/*!********************************************************************************************!*\
  !*** ./.yarn/cache/react-npm-17.0.1-98658812fc-83b9df9529.zip/node_modules/react/index.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./.yarn/cache/react-npm-17.0.1-98658812fc-83b9df9529.zip/node_modules/react/cjs/react.development.js");
}


/***/ }),

/***/ "./.yarn/cache/react-npm-17.0.1-98658812fc-83b9df9529.zip/node_modules/react/jsx-dev-runtime.js":
/*!******************************************************************************************************!*\
  !*** ./.yarn/cache/react-npm-17.0.1-98658812fc-83b9df9529.zip/node_modules/react/jsx-dev-runtime.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ "./.yarn/cache/react-npm-17.0.1-98658812fc-83b9df9529.zip/node_modules/react/cjs/react-jsx-dev-runtime.development.js");
}


/***/ }),

/***/ "./.yarn/cache/regenerator-runtime-npm-0.13.7-41bcbe64ea-52b66e6669.zip/node_modules/regenerator-runtime/runtime.js":
/*!**************************************************************************************************************************!*\
  !*** ./.yarn/cache/regenerator-runtime-npm-0.13.7-41bcbe64ea-52b66e6669.zip/node_modules/regenerator-runtime/runtime.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./.yarn/cache/tslib-npm-1.14.1-102499115e-dbe628ef87.zip/node_modules/tslib/tslib.es6.js":
/*!************************************************************************************************!*\
  !*** ./.yarn/cache/tslib-npm-1.14.1-102499115e-dbe628ef87.zip/node_modules/tslib/tslib.es6.js ***!
  \************************************************************************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__createBinding", function() { return __createBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),

/***/ "./lib/context.tsx":
/*!*************************!*\
  !*** ./lib/context.tsx ***!
  \*************************/
/*! exports provided: AppWrapper, UseAppContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AppWrapper", function() { return AppWrapper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UseAppContext", function() { return UseAppContext; });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.1-98658812fc-83b9df9529.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.1-98658812fc-83b9df9529.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);


var _jsxFileName = "C:\\Users\\alari\\code\\internet-simple\\lib\\context.tsx",
    _this = undefined,
    _s = $RefreshSig$(),
    _s2 = $RefreshSig$();


var AppContext = /*#__PURE__*/Object(react__WEBPACK_IMPORTED_MODULE_1__["createContext"])(null);
var AppWrapper = function AppWrapper(_ref) {
  _s();

  var children = _ref.children;

  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_1__["useState"])(null),
      selectedTag = _useState[0],
      setSelectedTag = _useState[1];

  var theme = {
    yellow: '#FDFFB6',
    blue: '#9BF6FF',
    pink: '#FFADAD',
    green: '#CAFFBF',
    gray: '#ADB5BD',
    black: '#212529',
    white: '#FFFFFC'
  };
  var sharedState = {
    selectedTag: selectedTag,
    setSelectedTag: setSelectedTag,
    theme: theme
  };
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(AppContext.Provider, {
    value: sharedState,
    children: children
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 25,
    columnNumber: 9
  }, _this);
};

_s(AppWrapper, "CkVuf3cGeg7aNypXq6cMJG5ZDz8=");

_c = AppWrapper;
var UseAppContext = function UseAppContext() {
  _s2();

  // eslint-disable-next-line @typescript-eslint/no-unsafe-return
  return Object(react__WEBPACK_IMPORTED_MODULE_1__["useContext"])(AppContext);
};

_s2(UseAppContext, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

_c2 = UseAppContext;

var _c, _c2;

$RefreshReg$(_c, "AppWrapper");
$RefreshReg$(_c2, "UseAppContext");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/harmony-module.js */ "./.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./lib/styles/styles.css":
/*!*******************************!*\
  !*** ./lib/styles/styles.css ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../.yarn/__virtual__/style-loader-virtual-501e82968d/0/cache/style-loader-npm-1.2.1-d2e298addc-cd30484665.zip/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./.yarn/__virtual__/style-loader-virtual-501e82968d/0/cache/style-loader-npm-1.2.1-d2e298addc-cd30484665.zip/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../.yarn/__virtual__/css-loader-virtual-c914f70651/0/cache/css-loader-npm-4.3.0-33464197c9-697a8838f0.zip/node_modules/css-loader/dist/cjs.js??ref--5-oneOf-6-1!../../.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-6-2!./styles.css */ "./.yarn/__virtual__/css-loader-virtual-c914f70651/0/cache/css-loader-npm-4.3.0-33464197c9-697a8838f0.zip/node_modules/css-loader/dist/cjs.js?!./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/compiled/postcss-loader/cjs.js?!./lib/styles/styles.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a, b) {
  if (!a && b || a && !b) {
    return false;
  }

  var p;

  for (p in a) {
    if (a[p] !== b[p]) {
      return false;
    }
  }

  for (p in b) {
    if (!a[p]) {
      return false;
    }
  }

  return true;
};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../.yarn/__virtual__/css-loader-virtual-c914f70651/0/cache/css-loader-npm-4.3.0-33464197c9-697a8838f0.zip/node_modules/css-loader/dist/cjs.js??ref--5-oneOf-6-1!../../.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-6-2!./styles.css */ "./.yarn/__virtual__/css-loader-virtual-c914f70651/0/cache/css-loader-npm-4.3.0-33464197c9-697a8838f0.zip/node_modules/css-loader/dist/cjs.js?!./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/compiled/postcss-loader/cjs.js?!./lib/styles/styles.css",
      function () {
        content = __webpack_require__(/*! !../../.yarn/__virtual__/css-loader-virtual-c914f70651/0/cache/css-loader-npm-4.3.0-33464197c9-697a8838f0.zip/node_modules/css-loader/dist/cjs.js??ref--5-oneOf-6-1!../../.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-6-2!./styles.css */ "./.yarn/__virtual__/css-loader-virtual-c914f70651/0/cache/css-loader-npm-4.3.0-33464197c9-697a8838f0.zip/node_modules/css-loader/dist/cjs.js?!./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/compiled/postcss-loader/cjs.js?!./lib/styles/styles.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./pages/_app.tsx":
/*!************************!*\
  !*** ./pages/_app.tsx ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MyApp; });
/* harmony import */ var C_Users_alari_code_internet_simple_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.1-98658812fc-83b9df9529.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lib_styles_styles_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/styles/styles.css */ "./lib/styles/styles.css");
/* harmony import */ var _lib_styles_styles_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lib_styles_styles_css__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _lib_context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/context */ "./lib/context.tsx");
/* harmony import */ var _datadog_browser_rum__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-rum */ "./.yarn/cache/@datadog-browser-rum-npm-2.7.4-f7ffa3056a-23d29cbd7d.zip/node_modules/@datadog/browser-rum/esm/index.js");


var _jsxFileName = "C:\\Users\\alari\\code\\internet-simple\\pages\\_app.tsx";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(C_Users_alari_code_internet_simple_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




_datadog_browser_rum__WEBPACK_IMPORTED_MODULE_4__["datadogRum"].init({
  applicationId: '70e3ecc2-f37f-4f60-ab24-34caec6be13d',
  clientToken: 'pub7307cfaa602d6e95b1376500ce8de2fb',
  site: 'datadoghq.eu',
  service: 'netlify-internet-blog',
  // Specify a version number to identify the deployed version of your application in Datadog 
  // version: '1.0.0',
  sampleRate: 100,
  trackInteractions: true
});
function MyApp(_ref) {
  var Component = _ref.Component,
      pageProps = _ref.pageProps;
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_lib_context__WEBPACK_IMPORTED_MODULE_3__["AppWrapper"], {
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(Component, _objectSpread({}, pageProps), void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 19,
      columnNumber: 13
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 18,
    columnNumber: 9
  }, this);
}
_c = MyApp;

var _c;

$RefreshReg$(_c, "MyApp");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/harmony-module.js */ "./.yarn/__virtual__/webpack-virtual-f63881a47a/0/cache/webpack-npm-4.44.1-977bccfd33-486b66f03b.zip/node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ 0:
/*!****************************************************************************************************************************************************************************************************************************************!*\
  !*** multi next-client-pages-loader?page=%2F_app&absolutePagePath=private-next-pages%2F_app.tsx ./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/client/router.js ***!
  \****************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! next-client-pages-loader?page=%2F_app&absolutePagePath=private-next-pages%2F_app.tsx! */"./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F_app&absolutePagePath=private-next-pages%2F_app.tsx!./");
module.exports = __webpack_require__(/*! C:\Users\alari\code\internet-simple\.yarn\__virtual__\next-virtual-35d5897357\0\cache\next-npm-10.0.3-642cd45c09-47b1b3e47a.zip\node_modules\next\dist\client\router.js */"./.yarn/__virtual__/next-virtual-35d5897357/0/cache/next-npm-10.0.3-642cd45c09-47b1b3e47a.zip/node_modules/next/dist/client/router.js");


/***/ })

},[[0,"webpack"]]]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3N0eWxlcy9zdHlsZXMuY3NzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9fX3ZpcnR1YWxfXy9jc3MtbG9hZGVyLXZpcnR1YWwtYzkxNGY3MDY1MS8wL2NhY2hlL2Nzcy1sb2FkZXItbnBtLTQuMy4wLTMzNDY0MTk3YzktNjk3YTg4MzhmMC56aXAvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vX192aXJ0dWFsX18vbmV4dC12aXJ0dWFsLTM1ZDU4OTczNTcvMC9jYWNoZS9uZXh0LW5wbS0xMC4wLjMtNjQyY2Q0NWMwOS00N2IxYjNlNDdhLnppcC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9vYmplY3QtYXNzaWduLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtMzVkNTg5NzM1Ny8wL2NhY2hlL25leHQtbnBtLTEwLjAuMy02NDJjZDQ1YzA5LTQ3YjFiM2U0N2EuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtY2xpZW50LXBhZ2VzLWxvYWRlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2gudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvcmVxdWVzdC1pZGxlLWNhbGxiYWNrLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vY2xpZW50L3JvdXRlLWxvYWRlci50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC9yb3V0ZXIudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvd2l0aC1yb3V0ZXIudHN4Iiwid2VicGFjazovL19OX0UvLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtMzVkNTg5NzM1Ny8wL2NhY2hlL25leHQtbnBtLTEwLjAuMy02NDJjZDQ1YzA5LTQ3YjFiM2U0N2EuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcGF0aC10by1yZWdleHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGgudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvbWl0dC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXItY29udGV4dC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvcm91dGVyLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9lc2NhcGUtcGF0aC1kZWxpbWl0ZXJzLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9nZXQtYXNzZXQtcGF0aC1mcm9tLXJvdXRlLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9wYXJzZS1yZWxhdGl2ZS11cmwudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3BhdGgtbWF0Y2gudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3ByZXBhcmUtZGVzdGluYXRpb24udHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9yZXNvbHZlLXJld3JpdGVzLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9yb3V0ZS1tYXRjaGVyLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9yb3V0ZS1yZWdleC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi91dGlscy50cyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vX192aXJ0dWFsX18vbmV4dC12aXJ0dWFsLTM1ZDU4OTczNTcvMC9jYWNoZS9uZXh0LW5wbS0xMC4wLjMtNjQyY2Q0NWMwOS00N2IxYjNlNDdhLnppcC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L25leHQtc2VydmVyL3NlcnZlci9kZW5vcm1hbGl6ZS1wYWdlLXBhdGguanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL19fdmlydHVhbF9fL3N0eWxlLWxvYWRlci12aXJ0dWFsLTUwMWU4Mjk2OGQvMC9jYWNoZS9zdHlsZS1sb2FkZXItbnBtLTEuMi4xLWQyZTI5OGFkZGMtY2QzMDQ4NDY2NS56aXAvbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzIiwid2VicGFjazovL19OX0UvKHdlYnBhY2spL2J1aWxkaW4vaGFybW9ueS1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BiYWJlbC1ydW50aW1lLW5wbS03LjEyLjUtYjNlZGI4ZWU4ZS02NDk2NGEwZmQxLnppcC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AYmFiZWwtcnVudGltZS1ucG0tNy4xMi41LWIzZWRiOGVlOGUtNjQ5NjRhMGZkMS56aXAvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRoSG9sZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BiYWJlbC1ydW50aW1lLW5wbS03LjEyLjUtYjNlZGI4ZWU4ZS02NDk2NGEwZmQxLnppcC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AYmFiZWwtcnVudGltZS1ucG0tNy4xMi41LWIzZWRiOGVlOGUtNjQ5NjRhMGZkMS56aXAvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BiYWJlbC1ydW50aW1lLW5wbS03LjEyLjUtYjNlZGI4ZWU4ZS02NDk2NGEwZmQxLnppcC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jb25zdHJ1Y3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BiYWJlbC1ydW50aW1lLW5wbS03LjEyLjUtYjNlZGI4ZWU4ZS02NDk2NGEwZmQxLnppcC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGJhYmVsLXJ1bnRpbWUtbnBtLTcuMTIuNS1iM2VkYjhlZThlLTY0OTY0YTBmZDEuemlwL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AYmFiZWwtcnVudGltZS1ucG0tNy4xMi41LWIzZWRiOGVlOGUtNjQ5NjRhMGZkMS56aXAvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AYmFiZWwtcnVudGltZS1ucG0tNy4xMi41LWIzZWRiOGVlOGUtNjQ5NjRhMGZkMS56aXAvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AYmFiZWwtcnVudGltZS1ucG0tNy4xMi41LWIzZWRiOGVlOGUtNjQ5NjRhMGZkMS56aXAvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVXaWxkY2FyZC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGJhYmVsLXJ1bnRpbWUtbnBtLTcuMTIuNS1iM2VkYjhlZThlLTY0OTY0YTBmZDEuemlwL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGJhYmVsLXJ1bnRpbWUtbnBtLTcuMTIuNS1iM2VkYjhlZThlLTY0OTY0YTBmZDEuemlwL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AYmFiZWwtcnVudGltZS1ucG0tNy4xMi41LWIzZWRiOGVlOGUtNjQ5NjRhMGZkMS56aXAvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVSZXN0LmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AYmFiZWwtcnVudGltZS1ucG0tNy4xMi41LWIzZWRiOGVlOGUtNjQ5NjRhMGZkMS56aXAvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BiYWJlbC1ydW50aW1lLW5wbS03LjEyLjUtYjNlZGI4ZWU4ZS02NDk2NGEwZmQxLnppcC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AYmFiZWwtcnVudGltZS1ucG0tNy4xMi41LWIzZWRiOGVlOGUtNjQ5NjRhMGZkMS56aXAvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AYmFiZWwtcnVudGltZS1ucG0tNy4xMi41LWIzZWRiOGVlOGUtNjQ5NjRhMGZkMS56aXAvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BiYWJlbC1ydW50aW1lLW5wbS03LjEyLjUtYjNlZGI4ZWU4ZS02NDk2NGEwZmQxLnppcC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BkYXRhZG9nLWJyb3dzZXItY29yZS1ucG0tMi43LjQtMGFiMzRhYzMzOC01OGI0NWJmYTgxLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1jb3JlL2VzbS9ib290L2luaXQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BkYXRhZG9nLWJyb3dzZXItY29yZS1ucG0tMi43LjQtMGFiMzRhYzMzOC01OGI0NWJmYTgxLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1jb3JlL2VzbS9icm93c2VyL2Nvb2tpZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGRhdGFkb2ctYnJvd3Nlci1jb3JlLW5wbS0yLjcuNC0wYWIzNGFjMzM4LTU4YjQ1YmZhODEuemlwL25vZGVfbW9kdWxlcy9AZGF0YWRvZy9icm93c2VyLWNvcmUvZXNtL2Jyb3dzZXIvZmV0Y2hQcm94eS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGRhdGFkb2ctYnJvd3Nlci1jb3JlLW5wbS0yLjcuNC0wYWIzNGFjMzM4LTU4YjQ1YmZhODEuemlwL25vZGVfbW9kdWxlcy9AZGF0YWRvZy9icm93c2VyLWNvcmUvZXNtL2Jyb3dzZXIveGhyUHJveHkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BkYXRhZG9nLWJyb3dzZXItY29yZS1ucG0tMi43LjQtMGFiMzRhYzMzOC01OGI0NWJmYTgxLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1jb3JlL2VzbS9kb21haW4vYXV0b21hdGljRXJyb3JDb2xsZWN0aW9uLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AZGF0YWRvZy1icm93c2VyLWNvcmUtbnBtLTIuNy40LTBhYjM0YWMzMzgtNThiNDViZmE4MS56aXAvbm9kZV9tb2R1bGVzL0BkYXRhZG9nL2Jyb3dzZXItY29yZS9lc20vZG9tYWluL2NvbmZpZ3VyYXRpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BkYXRhZG9nLWJyb3dzZXItY29yZS1ucG0tMi43LjQtMGFiMzRhYzMzOC01OGI0NWJmYTgxLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1jb3JlL2VzbS9kb21haW4vaW50ZXJuYWxNb25pdG9yaW5nLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AZGF0YWRvZy1icm93c2VyLWNvcmUtbnBtLTIuNy40LTBhYjM0YWMzMzgtNThiNDViZmE4MS56aXAvbm9kZV9tb2R1bGVzL0BkYXRhZG9nL2Jyb3dzZXItY29yZS9lc20vZG9tYWluL29sZENvb2tpZXNNaWdyYXRpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BkYXRhZG9nLWJyb3dzZXItY29yZS1ucG0tMi43LjQtMGFiMzRhYzMzOC01OGI0NWJmYTgxLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1jb3JlL2VzbS9kb21haW4vc2Vzc2lvbk1hbmFnZW1lbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BkYXRhZG9nLWJyb3dzZXItY29yZS1ucG0tMi43LjQtMGFiMzRhYzMzOC01OGI0NWJmYTgxLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1jb3JlL2VzbS9kb21haW4vdHJhY2VraXQvY29tcHV0ZVN0YWNrVHJhY2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BkYXRhZG9nLWJyb3dzZXItY29yZS1ucG0tMi43LjQtMGFiMzRhYzMzOC01OGI0NWJmYTgxLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1jb3JlL2VzbS9kb21haW4vdHJhY2VraXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BkYXRhZG9nLWJyb3dzZXItY29yZS1ucG0tMi43LjQtMGFiMzRhYzMzOC01OGI0NWJmYTgxLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1jb3JlL2VzbS9kb21haW4vdHJhY2VraXQvcmVwb3J0LmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AZGF0YWRvZy1icm93c2VyLWNvcmUtbnBtLTIuNy40LTBhYjM0YWMzMzgtNThiNDViZmE4MS56aXAvbm9kZV9tb2R1bGVzL0BkYXRhZG9nL2Jyb3dzZXItY29yZS9lc20vZG9tYWluL3RyYW5zcG9ydENvbmZpZ3VyYXRpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BkYXRhZG9nLWJyb3dzZXItY29yZS1ucG0tMi43LjQtMGFiMzRhYzMzOC01OGI0NWJmYTgxLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1jb3JlL2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGRhdGFkb2ctYnJvd3Nlci1jb3JlLW5wbS0yLjcuNC0wYWIzNGFjMzM4LTU4YjQ1YmZhODEuemlwL25vZGVfbW9kdWxlcy9AZGF0YWRvZy9icm93c2VyLWNvcmUvZXNtL3Rvb2xzL2JvdW5kZWRCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BkYXRhZG9nLWJyb3dzZXItY29yZS1ucG0tMi43LjQtMGFiMzRhYzMzOC01OGI0NWJmYTgxLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1jb3JlL2VzbS90b29scy9jYXRjaFVzZXJFcnJvcnMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BkYXRhZG9nLWJyb3dzZXItY29yZS1ucG0tMi43LjQtMGFiMzRhYzMzOC01OGI0NWJmYTgxLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1jb3JlL2VzbS90b29scy9jb250ZXh0LmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AZGF0YWRvZy1icm93c2VyLWNvcmUtbnBtLTIuNy40LTBhYjM0YWMzMzgtNThiNDViZmE4MS56aXAvbm9kZV9tb2R1bGVzL0BkYXRhZG9nL2Jyb3dzZXItY29yZS9lc20vdG9vbHMvY29udGV4dE1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BkYXRhZG9nLWJyb3dzZXItY29yZS1ucG0tMi43LjQtMGFiMzRhYzMzOC01OGI0NWJmYTgxLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1jb3JlL2VzbS90b29scy9lcnJvci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGRhdGFkb2ctYnJvd3Nlci1jb3JlLW5wbS0yLjcuNC0wYWIzNGFjMzM4LTU4YjQ1YmZhODEuemlwL25vZGVfbW9kdWxlcy9AZGF0YWRvZy9icm93c2VyLWNvcmUvZXNtL3Rvb2xzL2xpbWl0TW9kaWZpY2F0aW9uLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AZGF0YWRvZy1icm93c2VyLWNvcmUtbnBtLTIuNy40LTBhYjM0YWMzMzgtNThiNDViZmE4MS56aXAvbm9kZV9tb2R1bGVzL0BkYXRhZG9nL2Jyb3dzZXItY29yZS9lc20vdG9vbHMvb2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGRhdGFkb2ctYnJvd3Nlci1jb3JlLW5wbS0yLjcuNC0wYWIzNGFjMzM4LTU4YjQ1YmZhODEuemlwL25vZGVfbW9kdWxlcy9AZGF0YWRvZy9icm93c2VyLWNvcmUvZXNtL3Rvb2xzL3NwZWNIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BkYXRhZG9nLWJyb3dzZXItY29yZS1ucG0tMi43LjQtMGFiMzRhYzMzOC01OGI0NWJmYTgxLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1jb3JlL2VzbS90b29scy90aW1lVXRpbHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BkYXRhZG9nLWJyb3dzZXItY29yZS1ucG0tMi43LjQtMGFiMzRhYzMzOC01OGI0NWJmYTgxLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1jb3JlL2VzbS90b29scy91cmxQb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGRhdGFkb2ctYnJvd3Nlci1jb3JlLW5wbS0yLjcuNC0wYWIzNGFjMzM4LTU4YjQ1YmZhODEuemlwL25vZGVfbW9kdWxlcy9AZGF0YWRvZy9icm93c2VyLWNvcmUvZXNtL3Rvb2xzL3V0aWxzLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AZGF0YWRvZy1icm93c2VyLWNvcmUtbnBtLTIuNy40LTBhYjM0YWMzMzgtNThiNDViZmE4MS56aXAvbm9kZV9tb2R1bGVzL0BkYXRhZG9nL2Jyb3dzZXItY29yZS9lc20vdHJhbnNwb3J0L3RyYW5zcG9ydC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGRhdGFkb2ctYnJvd3Nlci1ydW0tY29yZS1ucG0tMi43LjQtY2M1MjM2MGVmMS02ZDAwMmExNmUwLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1ydW0tY29yZS9lc20vYm9vdC9idWlsZEVudi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGRhdGFkb2ctYnJvd3Nlci1ydW0tY29yZS1ucG0tMi43LjQtY2M1MjM2MGVmMS02ZDAwMmExNmUwLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1ydW0tY29yZS9lc20vYm9vdC9ydW0uanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BkYXRhZG9nLWJyb3dzZXItcnVtLWNvcmUtbnBtLTIuNy40LWNjNTIzNjBlZjEtNmQwMDJhMTZlMC56aXAvbm9kZV9tb2R1bGVzL0BkYXRhZG9nL2Jyb3dzZXItcnVtLWNvcmUvZXNtL2Jvb3QvcnVtUHVibGljQXBpLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AZGF0YWRvZy1icm93c2VyLXJ1bS1jb3JlLW5wbS0yLjcuNC1jYzUyMzYwZWYxLTZkMDAyYTE2ZTAuemlwL25vZGVfbW9kdWxlcy9AZGF0YWRvZy9icm93c2VyLXJ1bS1jb3JlL2VzbS9icm93c2VyL2RvbU11dGF0aW9uQ29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGRhdGFkb2ctYnJvd3Nlci1ydW0tY29yZS1ucG0tMi43LjQtY2M1MjM2MGVmMS02ZDAwMmExNmUwLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1ydW0tY29yZS9lc20vYnJvd3Nlci9wZXJmb3JtYW5jZUNvbGxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BkYXRhZG9nLWJyb3dzZXItcnVtLWNvcmUtbnBtLTIuNy40LWNjNTIzNjBlZjEtNmQwMDJhMTZlMC56aXAvbm9kZV9tb2R1bGVzL0BkYXRhZG9nL2Jyb3dzZXItcnVtLWNvcmUvZXNtL2RvbWFpbi9hc3NlbWJseS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGRhdGFkb2ctYnJvd3Nlci1ydW0tY29yZS1ucG0tMi43LjQtY2M1MjM2MGVmMS02ZDAwMmExNmUwLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1ydW0tY29yZS9lc20vZG9tYWluL2ludGVybmFsQ29udGV4dC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGRhdGFkb2ctYnJvd3Nlci1ydW0tY29yZS1ucG0tMi43LjQtY2M1MjM2MGVmMS02ZDAwMmExNmUwLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1ydW0tY29yZS9lc20vZG9tYWluL2xpZmVDeWNsZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGRhdGFkb2ctYnJvd3Nlci1ydW0tY29yZS1ucG0tMi43LjQtY2M1MjM2MGVmMS02ZDAwMmExNmUwLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1ydW0tY29yZS9lc20vZG9tYWluL3BhcmVudENvbnRleHRzLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AZGF0YWRvZy1icm93c2VyLXJ1bS1jb3JlLW5wbS0yLjcuNC1jYzUyMzYwZWYxLTZkMDAyYTE2ZTAuemlwL25vZGVfbW9kdWxlcy9AZGF0YWRvZy9icm93c2VyLXJ1bS1jb3JlL2VzbS9kb21haW4vcmVxdWVzdENvbGxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BkYXRhZG9nLWJyb3dzZXItcnVtLWNvcmUtbnBtLTIuNy40LWNjNTIzNjBlZjEtNmQwMDJhMTZlMC56aXAvbm9kZV9tb2R1bGVzL0BkYXRhZG9nL2Jyb3dzZXItcnVtLWNvcmUvZXNtL2RvbWFpbi9ydW1FdmVudHNDb2xsZWN0aW9uL2FjdGlvbi9hY3Rpb25Db2xsZWN0aW9uLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AZGF0YWRvZy1icm93c2VyLXJ1bS1jb3JlLW5wbS0yLjcuNC1jYzUyMzYwZWYxLTZkMDAyYTE2ZTAuemlwL25vZGVfbW9kdWxlcy9AZGF0YWRvZy9icm93c2VyLXJ1bS1jb3JlL2VzbS9kb21haW4vcnVtRXZlbnRzQ29sbGVjdGlvbi9hY3Rpb24vZ2V0QWN0aW9uTmFtZUZyb21FbGVtZW50LmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AZGF0YWRvZy1icm93c2VyLXJ1bS1jb3JlLW5wbS0yLjcuNC1jYzUyMzYwZWYxLTZkMDAyYTE2ZTAuemlwL25vZGVfbW9kdWxlcy9AZGF0YWRvZy9icm93c2VyLXJ1bS1jb3JlL2VzbS9kb21haW4vcnVtRXZlbnRzQ29sbGVjdGlvbi9hY3Rpb24vdHJhY2tBY3Rpb25zLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AZGF0YWRvZy1icm93c2VyLXJ1bS1jb3JlLW5wbS0yLjcuNC1jYzUyMzYwZWYxLTZkMDAyYTE2ZTAuemlwL25vZGVfbW9kdWxlcy9AZGF0YWRvZy9icm93c2VyLXJ1bS1jb3JlL2VzbS9kb21haW4vcnVtRXZlbnRzQ29sbGVjdGlvbi9lcnJvci9lcnJvckNvbGxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BkYXRhZG9nLWJyb3dzZXItcnVtLWNvcmUtbnBtLTIuNy40LWNjNTIzNjBlZjEtNmQwMDJhMTZlMC56aXAvbm9kZV9tb2R1bGVzL0BkYXRhZG9nL2Jyb3dzZXItcnVtLWNvcmUvZXNtL2RvbWFpbi9ydW1FdmVudHNDb2xsZWN0aW9uL2xvbmdUYXNrL2xvbmdUYXNrQ29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGRhdGFkb2ctYnJvd3Nlci1ydW0tY29yZS1ucG0tMi43LjQtY2M1MjM2MGVmMS02ZDAwMmExNmUwLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1ydW0tY29yZS9lc20vZG9tYWluL3J1bUV2ZW50c0NvbGxlY3Rpb24vcmVzb3VyY2UvbWF0Y2hSZXF1ZXN0VGltaW5nLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AZGF0YWRvZy1icm93c2VyLXJ1bS1jb3JlLW5wbS0yLjcuNC1jYzUyMzYwZWYxLTZkMDAyYTE2ZTAuemlwL25vZGVfbW9kdWxlcy9AZGF0YWRvZy9icm93c2VyLXJ1bS1jb3JlL2VzbS9kb21haW4vcnVtRXZlbnRzQ29sbGVjdGlvbi9yZXNvdXJjZS9yZXNvdXJjZUNvbGxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BkYXRhZG9nLWJyb3dzZXItcnVtLWNvcmUtbnBtLTIuNy40LWNjNTIzNjBlZjEtNmQwMDJhMTZlMC56aXAvbm9kZV9tb2R1bGVzL0BkYXRhZG9nL2Jyb3dzZXItcnVtLWNvcmUvZXNtL2RvbWFpbi9ydW1FdmVudHNDb2xsZWN0aW9uL3Jlc291cmNlL3Jlc291cmNlVXRpbHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BkYXRhZG9nLWJyb3dzZXItcnVtLWNvcmUtbnBtLTIuNy40LWNjNTIzNjBlZjEtNmQwMDJhMTZlMC56aXAvbm9kZV9tb2R1bGVzL0BkYXRhZG9nL2Jyb3dzZXItcnVtLWNvcmUvZXNtL2RvbWFpbi9ydW1FdmVudHNDb2xsZWN0aW9uL3ZpZXcvdHJhY2tGaXJzdEhpZGRlbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGRhdGFkb2ctYnJvd3Nlci1ydW0tY29yZS1ucG0tMi43LjQtY2M1MjM2MGVmMS02ZDAwMmExNmUwLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1ydW0tY29yZS9lc20vZG9tYWluL3J1bUV2ZW50c0NvbGxlY3Rpb24vdmlldy90cmFja0luaXRpYWxWaWV3VGltaW5ncy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGRhdGFkb2ctYnJvd3Nlci1ydW0tY29yZS1ucG0tMi43LjQtY2M1MjM2MGVmMS02ZDAwMmExNmUwLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1ydW0tY29yZS9lc20vZG9tYWluL3J1bUV2ZW50c0NvbGxlY3Rpb24vdmlldy90cmFja0xvY2F0aW9uQ2hhbmdlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGRhdGFkb2ctYnJvd3Nlci1ydW0tY29yZS1ucG0tMi43LjQtY2M1MjM2MGVmMS02ZDAwMmExNmUwLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1ydW0tY29yZS9lc20vZG9tYWluL3J1bUV2ZW50c0NvbGxlY3Rpb24vdmlldy90cmFja1ZpZXdNZXRyaWNzLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AZGF0YWRvZy1icm93c2VyLXJ1bS1jb3JlLW5wbS0yLjcuNC1jYzUyMzYwZWYxLTZkMDAyYTE2ZTAuemlwL25vZGVfbW9kdWxlcy9AZGF0YWRvZy9icm93c2VyLXJ1bS1jb3JlL2VzbS9kb21haW4vcnVtRXZlbnRzQ29sbGVjdGlvbi92aWV3L3RyYWNrVmlld3MuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BkYXRhZG9nLWJyb3dzZXItcnVtLWNvcmUtbnBtLTIuNy40LWNjNTIzNjBlZjEtNmQwMDJhMTZlMC56aXAvbm9kZV9tb2R1bGVzL0BkYXRhZG9nL2Jyb3dzZXItcnVtLWNvcmUvZXNtL2RvbWFpbi9ydW1FdmVudHNDb2xsZWN0aW9uL3ZpZXcvdmlld0NvbGxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BkYXRhZG9nLWJyb3dzZXItcnVtLWNvcmUtbnBtLTIuNy40LWNjNTIzNjBlZjEtNmQwMDJhMTZlMC56aXAvbm9kZV9tb2R1bGVzL0BkYXRhZG9nL2Jyb3dzZXItcnVtLWNvcmUvZXNtL2RvbWFpbi9ydW1TZXNzaW9uLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AZGF0YWRvZy1icm93c2VyLXJ1bS1jb3JlLW5wbS0yLjcuNC1jYzUyMzYwZWYxLTZkMDAyYTE2ZTAuemlwL25vZGVfbW9kdWxlcy9AZGF0YWRvZy9icm93c2VyLXJ1bS1jb3JlL2VzbS9kb21haW4vdHJhY2luZy9nZXREb2N1bWVudFRyYWNlSWQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BkYXRhZG9nLWJyb3dzZXItcnVtLWNvcmUtbnBtLTIuNy40LWNjNTIzNjBlZjEtNmQwMDJhMTZlMC56aXAvbm9kZV9tb2R1bGVzL0BkYXRhZG9nL2Jyb3dzZXItcnVtLWNvcmUvZXNtL2RvbWFpbi90cmFjaW5nL3RyYWNlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGRhdGFkb2ctYnJvd3Nlci1ydW0tY29yZS1ucG0tMi43LjQtY2M1MjM2MGVmMS02ZDAwMmExNmUwLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1ydW0tY29yZS9lc20vZG9tYWluL3RyYWNrRXZlbnRDb3VudHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BkYXRhZG9nLWJyb3dzZXItcnVtLWNvcmUtbnBtLTIuNy40LWNjNTIzNjBlZjEtNmQwMDJhMTZlMC56aXAvbm9kZV9tb2R1bGVzL0BkYXRhZG9nL2Jyb3dzZXItcnVtLWNvcmUvZXNtL2RvbWFpbi90cmFja1BhZ2VBY3Rpdml0aWVzLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AZGF0YWRvZy1icm93c2VyLXJ1bS1jb3JlLW5wbS0yLjcuNC1jYzUyMzYwZWYxLTZkMDAyYTE2ZTAuemlwL25vZGVfbW9kdWxlcy9AZGF0YWRvZy9icm93c2VyLXJ1bS1jb3JlL2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGRhdGFkb2ctYnJvd3Nlci1ydW0tY29yZS1ucG0tMi43LjQtY2M1MjM2MGVmMS02ZDAwMmExNmUwLnppcC9ub2RlX21vZHVsZXMvQGRhdGFkb2cvYnJvd3Nlci1ydW0tY29yZS9lc20vcmF3UnVtRXZlbnQudHlwZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BkYXRhZG9nLWJyb3dzZXItcnVtLWNvcmUtbnBtLTIuNy40LWNjNTIzNjBlZjEtNmQwMDJhMTZlMC56aXAvbm9kZV9tb2R1bGVzL0BkYXRhZG9nL2Jyb3dzZXItcnVtLWNvcmUvZXNtL3RyYW5zcG9ydC9iYXRjaC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGRhdGFkb2ctYnJvd3Nlci1ydW0tbnBtLTIuNy40LWY3ZmZhMzA1NmEtMjNkMjljYmQ3ZC56aXAvbm9kZV9tb2R1bGVzL0BkYXRhZG9nL2Jyb3dzZXItcnVtL2VzbS9ib290L3J1bS5lbnRyeS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGRhdGFkb2ctYnJvd3Nlci1ydW0tbnBtLTIuNy40LWY3ZmZhMzA1NmEtMjNkMjljYmQ3ZC56aXAvbm9kZV9tb2R1bGVzL0BkYXRhZG9nL2Jyb3dzZXItcnVtL2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvcmVhY3QtaXMtbnBtLTE2LjEzLjEtYTliOTM4MmI0Zi1mN2ExOWFjMzQ5LnppcC9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9yZWFjdC1pcy1ucG0tMTYuMTMuMS1hOWI5MzgyYjRmLWY3YTE5YWMzNDkuemlwL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvcmVhY3QtbnBtLTE3LjAuMS05ODY1ODgxMmZjLTgzYjlkZjk1MjkuemlwL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9yZWFjdC1ucG0tMTcuMC4xLTk4NjU4ODEyZmMtODNiOWRmOTUyOS56aXAvbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvcmVhY3QtbnBtLTE3LjAuMS05ODY1ODgxMmZjLTgzYjlkZjk1MjkuemlwL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvcmVhY3QtbnBtLTE3LjAuMS05ODY1ODgxMmZjLTgzYjlkZjk1MjkuemlwL25vZGVfbW9kdWxlcy9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL3JlZ2VuZXJhdG9yLXJ1bnRpbWUtbnBtLTAuMTMuNy00MWJjYmU2NGVhLTUyYjY2ZTY2NjkuemlwL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL3RzbGliLW5wbS0xLjE0LjEtMTAyNDk5MTE1ZS1kYmU2MjhlZjg3LnppcC9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwid2VicGFjazovL19OX0UvLi9saWIvY29udGV4dC50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9zdHlsZXMvc3R5bGVzLmNzcz9lYzJhIiwid2VicGFjazovL19OX0UvLi9wYWdlcy9fYXBwLnRzeCJdLCJuYW1lcyI6WyJwYXRoIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJwcm9jZXNzIiwicmVxdWVzdElkbGVDYWxsYmFjayIsInNlbGYiLCJzdGFydCIsIkRhdGUiLCJzZXRUaW1lb3V0IiwiY2IiLCJkaWRUaW1lb3V0IiwidGltZVJlbWFpbmluZyIsIk1hdGgiLCJNU19NQVhfSURMRV9ERUxBWSIsImVudHJ5IiwibWFwIiwiUHJvbWlzZSIsInByb20iLCJyZXNvbHZlIiwicmVzb2x2ZXIiLCJmdXR1cmUiLCJnZW5lcmF0b3IiLCJ2YWx1ZSIsImxpbmsiLCJkb2N1bWVudCIsIndpbmRvdyIsImNhblByZWZldGNoIiwiaGFzUHJlZmV0Y2giLCJyZXMiLCJBU1NFVF9MT0FEX0VSUk9SIiwiU3ltYm9sIiwiT2JqZWN0IiwiZXJyIiwic2NyaXB0IiwicmVqZWN0IiwibWFya0Fzc2V0RXJyb3IiLCJvbkJ1aWxkTWFuaWZlc3QiLCJpZGxlVGltZW91dCIsInNjcmlwdHMiLCJhc3NldFByZWZpeCIsImVuY29kZVVSSSIsImNzcyIsImdldENsaWVudEJ1aWxkTWFuaWZlc3QiLCJtYW5pZmVzdCIsInJvdXRlIiwiYWxsRmlsZXMiLCJ2IiwiZW50cnlwb2ludHMiLCJsb2FkZWRTY3JpcHRzIiwic3R5bGVTaGVldHMiLCJyb3V0ZXMiLCJhcHBlbmRTY3JpcHQiLCJmZXRjaCIsInRleHQiLCJocmVmIiwiY29udGVudCIsIndoZW5FbnRyeXBvaW50Iiwid2l0aEZ1dHVyZSIsIm9uRW50cnlwb2ludCIsImZuIiwiZXhwb3J0cyIsImNvbXBvbmVudCIsImVycm9yIiwiaW5wdXQiLCJvbGQiLCJsb2FkUm91dGUiLCJnZXRGaWxlc0ZvclJvdXRlIiwiZW50cnlwb2ludCIsInN0eWxlcyIsInByZWZldGNoIiwiY24iLCJuYXZpZ2F0b3IiLCJvdXRwdXQiLCJwcmVmZXRjaFZpYURvbSIsImNyZWF0ZVJvdXRlTG9hZGVyIiwic2luZ2xldG9uUm91dGVyIiwicm91dGVyIiwicmVhZHlDYWxsYmFja3MiLCJyZWFkeSIsInVybFByb3BlcnR5RmllbGRzIiwicm91dGVyRXZlbnRzIiwiY29yZU1ldGhvZEZpZWxkcyIsImdldCIsIlJvdXRlciIsImZpZWxkIiwiZ2V0Um91dGVyIiwiZXZlbnQiLCJldmVudEZpZWxkIiwiX3NpbmdsZXRvblJvdXRlciIsImNvbnNvbGUiLCJtZXNzYWdlIiwiUmVhY3QiLCJSb3V0ZXJDb250ZXh0IiwiY3JlYXRlUm91dGVyIiwiX3JvdXRlciIsImluc3RhbmNlIiwiQXJyYXkiLCJDb21wb3NlZENvbXBvbmVudCIsImdldEluaXRpYWxQcm9wcyIsIldpdGhSb3V0ZXJXcmFwcGVyIiwibmFtZSIsInBhdGhuYW1lUGFydHMiLCJwYXRobmFtZSIsImxvY2FsZXMiLCJsb2NhbGUiLCJkZXRlY3RlZExvY2FsZSIsImFsbCIsIm9uIiwib2ZmIiwiZW1pdCIsImhhbmRsZXIiLCJiYXNlUGF0aCIsImNhbmNlbGxlZCIsInByZWZpeCIsImFkZFBhdGhQcmVmaXgiLCJ1cmwiLCJsb2NhdGlvbk9yaWdpbiIsInJlc29sdmVkIiwiaGFzQmFzZVBhdGgiLCJpbnRlcnBvbGF0ZWRSb3V0ZSIsImR5bmFtaWNSZWdleCIsImR5bmFtaWNHcm91cHMiLCJkeW5hbWljTWF0Y2hlcyIsImFzUGF0aG5hbWUiLCJwYXJhbXMiLCJwYXJhbSIsInJlcGxhY2VkIiwicmVwZWF0Iiwib3B0aW9uYWwiLCJlc2NhcGVQYXRoRGVsaW1pdGVycyIsInJlc3VsdCIsImZpbHRlcmVkUXVlcnkiLCJrZXkiLCJxdWVyeSIsImJhc2UiLCJ1cmxBc1N0cmluZyIsImlzTG9jYWxVUkwiLCJyZXNvbHZlQXMiLCJmaW5hbFVybCIsImludGVycG9sYXRlZEFzIiwiaW50ZXJwb2xhdGVBcyIsImhhc2giLCJvbWl0UGFybXNGcm9tUXVlcnkiLCJyZXNvbHZlZEhyZWYiLCJhZGRCYXNlUGF0aCIsInJlc29sdmVIcmVmIiwiYXMiLCJtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiIsIlNTR19EQVRBX05PVF9GT1VORF9FUlJPUiIsImNyZWRlbnRpYWxzIiwiYXR0ZW1wdHMiLCJmZXRjaFJldHJ5IiwiaXNTZXJ2ZXJSZW5kZXIiLCJjb25zdHJ1Y3RvciIsImFzUGF0aCIsImNvbXBvbmVudHMiLCJzZGMiLCJzdWIiLCJjbGMiLCJwYWdlTG9hZGVyIiwiX2JwcyIsImV2ZW50cyIsIl93cmFwQXBwIiwiaXNTc3IiLCJpc0ZhbGxiYWNrIiwiX2luRmxpZ2h0Um91dGUiLCJfc2hhbGxvdyIsImRlZmF1bHRMb2NhbGUiLCJlIiwic3RhdGUiLCJzaGFsbG93Iiwib3B0aW9ucyIsIkNvbXBvbmVudCIsImluaXRpYWwiLCJwcm9wcyIsIl9fTl9TU0ciLCJpbml0aWFsUHJvcHMiLCJfX05fU1NQIiwiX19ORVhUX0RBVEFfXyIsInJlbG9hZCIsInByZXBhcmVVcmxBcyIsImxvY2FsZUNoYW5nZSIsInJlcXVpcmUiLCJwYXJzZWRBcyIsImRlbEJhc2VQYXRoIiwibG9jYWxlUGF0aFJlc3VsdCIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJhZGRMb2NhbGUiLCJTVCIsInBlcmZvcm1hbmNlIiwiY2xlYW5lZEFzIiwiZGVsTG9jYWxlIiwicGFyc2VkIiwicGFnZXMiLCJfX3Jld3JpdGVzIiwibWV0aG9kIiwicmVzb2x2ZWRBcyIsInAiLCJwb3RlbnRpYWxIcmVmIiwicm91dGVSZWdleCIsInJvdXRlTWF0Y2giLCJzaG91bGRJbnRlcnBvbGF0ZSIsIm1pc3NpbmdQYXJhbXMiLCJyb3V0ZUluZm8iLCJkZXN0aW5hdGlvbiIsInBhcnNlZEhyZWYiLCJhcHBDb21wIiwiX19OIiwiYnVpbGRDYW5jZWxsYXRpb25FcnJvciIsInNzZzQwNCIsInBhZ2UiLCJtb2QiLCJleGlzdGluZ1JvdXRlSW5mbyIsImNhY2hlZFJvdXRlSW5mbyIsImlzVmFsaWRFbGVtZW50VHlwZSIsImRhdGFIcmVmIiwib25seUFIYXNoQ2hhbmdlIiwibmV3SGFzaCIsIm9sZFVybE5vSGFzaCIsIm9sZEhhc2giLCJzY3JvbGxUb0hhc2giLCJpZEVsIiwibmFtZUVsIiwidXJsSXNOZXciLCJfcmVzb2x2ZUhyZWYiLCJhcHBseUJhc2VQYXRoIiwiY2xlYW5QYXRobmFtZSIsImlzU3NnIiwiY2FuY2VsIiwiY29tcG9uZW50UmVzdWx0IiwiZGF0YSIsIl9nZXRTdGF0aWNEYXRhIiwiZmV0Y2hOZXh0RGF0YSIsIl9nZXRTZXJ2ZXJEYXRhIiwiQXBwVHJlZSIsImN0eCIsImFib3J0Q29tcG9uZW50TG9hZCIsIm5vdGlmeSIsInNlZ21lbnQiLCJjaGFyIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic2xhc2hlZFByb3RvY29scyIsInByb3RvY29sIiwidXJsT2JqIiwiaG9zdCIsImF1dGgiLCJob3N0bmFtZSIsIlN0cmluZyIsInF1ZXJ5c3RyaW5nIiwic2VhcmNoIiwiZXh0IiwiVEVTVF9ST1VURSIsImdsb2JhbEJhc2UiLCJyZXNvbHZlZEJhc2UiLCJvcmlnaW4iLCJtYXRjaGVyT3B0aW9ucyIsInNlbnNpdGl2ZSIsImRlbGltaXRlciIsImN1c3RvbVJvdXRlTWF0Y2hlck9wdGlvbnMiLCJzdHJpY3QiLCJjdXN0b21Sb3V0ZSIsImtleXMiLCJtYXRjaGVyUmVnZXgiLCJwYXRoVG9SZWdleHAiLCJtYXRjaGVyIiwidmFsaWRhdGUiLCJwYXJzZWREZXN0aW5hdGlvbiIsImhhZExvY2FsZSIsInBvcnQiLCJkZXN0UXVlcnkiLCJkZXN0UGF0aCIsImRlc3RQYXRoUGFyYW1LZXlzIiwiZGVzdFBhdGhQYXJhbXMiLCJkZXN0aW5hdGlvbkNvbXBpbGVyIiwic3RyT3JBcnJheSIsImNvbXBpbGVOb25QYXRoIiwicGFyYW1LZXlzIiwiYXBwZW5kUGFyYW1zVG9RdWVyeSIsInNob3VsZEFkZEJhc2VQYXRoIiwibmV3VXJsIiwic2VhcmNoUGFyYW1zIiwiaXNOYU4iLCJpdGVtIiwic3RyaW5naWZ5VXJsUXVlcnlQYXJhbSIsInNlYXJjaFBhcmFtc0xpc3QiLCJ0YXJnZXQiLCJjdXN0b21Sb3V0ZU1hdGNoZXIiLCJyZXdyaXRlIiwiZGVzdFJlcyIsInJlIiwiZGVjb2RlIiwiZGVjb2RlVVJJQ29tcG9uZW50Iiwic2x1Z05hbWUiLCJnIiwiZ3JvdXBzIiwibSIsInN0ciIsInNlZ21lbnRzIiwibm9ybWFsaXplZFJvdXRlIiwiZ3JvdXBJbmRleCIsInBhcmFtZXRlcml6ZWRSb3V0ZSIsInBhcnNlUGFyYW1ldGVyIiwicG9zIiwiZXNjYXBlUmVnZXgiLCJ1c2VkIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJBcHAiLCJnZXREaXNwbGF5TmFtZSIsImxvYWRHZXRJbml0aWFsUHJvcHMiLCJwYWdlUHJvcHMiLCJpc1Jlc1NlbnQiLCJ1cmxPYmplY3RLZXlzIiwiU1AiLCJBcHBDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsIkFwcFdyYXBwZXIiLCJjaGlsZHJlbiIsInVzZVN0YXRlIiwic2VsZWN0ZWRUYWciLCJzZXRTZWxlY3RlZFRhZyIsInRoZW1lIiwieWVsbG93IiwiYmx1ZSIsInBpbmsiLCJncmVlbiIsImdyYXkiLCJibGFjayIsIndoaXRlIiwic2hhcmVkU3RhdGUiLCJVc2VBcHBDb250ZXh0IiwidXNlQ29udGV4dCIsImRhdGFkb2dSdW0iLCJpbml0IiwiYXBwbGljYXRpb25JZCIsImNsaWVudFRva2VuIiwic2l0ZSIsInNlcnZpY2UiLCJzYW1wbGVSYXRlIiwidHJhY2tJbnRlcmFjdGlvbnMiLCJNeUFwcCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNtTTtBQUNuTSw4QkFBOEIscUxBQTJCO0FBQ3pEO0FBQ0EsOEJBQThCLFFBQVMsU0FBUyxjQUFjLDhCQUE4QixHQUFHLGFBQWEsa0JBQWtCLEdBQUcsU0FBUyxzRkFBc0YsVUFBVSxZQUFZLE9BQU8sS0FBSyxVQUFVLCtCQUErQixjQUFjLDhCQUE4QixHQUFHLGFBQWEsa0JBQWtCLEdBQUcscUJBQXFCO0FBQ2paO0FBQ2Usc0ZBQXVCLEVBQUM7Ozs7Ozs7Ozs7Ozs7QUNOMUI7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxxQkFBcUI7QUFDakU7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCOztBQUU5Qjs7QUFFQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEhBQTBIO0FBQzFIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUVBQW1FOztBQUVuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFdBQVcsY0FBYztBQUN6QixXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFB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QTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDs7QUFFbkQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QixZQUFZLGFBQWE7QUFDekI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEhBQTBIO0FBQzFIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUVBQW1FOztBQUVuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLEVBQUU7QUFDYjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMERBQTBEO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QixRQUF4QkEsU0FBd0I7QUFBQSxNQUFieUksU0FBYSxRQUFiQSxTQUFhO0FBQ3BELHNCQUNJLHFFQUFDLHVEQUFEO0FBQUEsMkJBQ0kscUVBQUMsU0FBRCxvQkFBZ0JBLFNBQWhCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFESjtBQUFBO0FBQUE7QUFBQTtBQUFBLFVBREo7QUFLSDtLQU51QjhCLEsiLCJmaWxlIjoic3RhdGljL2NodW5rcy9wYWdlcy9fYXBwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLnlhcm4vX192aXJ0dWFsX18vY3NzLWxvYWRlci12aXJ0dWFsLWM5MTRmNzA2NTEvMC9jYWNoZS9jc3MtbG9hZGVyLW5wbS00LjMuMC0zMzQ2NDE5N2M5LTY5N2E4ODM4ZjAuemlwL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcImJvZHkge1xcbiAgbWFyZ2luOiAwO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmY2RiMjtcXG59XFxuXFxuI19fbmV4dCB7XFxuICBoZWlnaHQ6IDEwMHZoO1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vbGliL3N0eWxlcy9zdHlsZXMuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0UsU0FBUztFQUNULHlCQUF5QjtBQUMzQjs7QUFFQTtFQUNFLGFBQWE7QUFDZlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJib2R5IHtcXG4gIG1hcmdpbjogMDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmNkYjI7XFxufVxcblxcbiNfX25leHQge1xcbiAgaGVpZ2h0OiAxMDB2aDtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGNvbnRlbnQsIFwifVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbignJyk7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSwgZGVkdXBlKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCAnJ11dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2ldKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsyXSA9IFwiXCIuY29uY2F0KG1lZGlhUXVlcnksIFwiIGFuZCBcIikuY29uY2F0KGl0ZW1bMl0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuXG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8ICcnKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcblxuXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICByZXR1cm4gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xufSIsIlwidXNlIHN0cmljdFwiO3ZhciBhc3NpZ249T2JqZWN0LmFzc2lnbi5iaW5kKE9iamVjdCk7bW9kdWxlLmV4cG9ydHM9YXNzaWduO21vZHVsZS5leHBvcnRzLmRlZmF1bHQ9bW9kdWxlLmV4cG9ydHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYmplY3QtYXNzaWduLmpzLm1hcCIsIlxuICAgICh3aW5kb3cuX19ORVhUX1AgPSB3aW5kb3cuX19ORVhUX1AgfHwgW10pLnB1c2goW1xuICAgICAgXCIvX2FwcFwiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZShcInByaXZhdGUtbmV4dC1wYWdlcy9fYXBwLnRzeFwiKTtcbiAgICAgIH1cbiAgICBdKTtcbiAgIiwiLyoqXG4gKiBSZW1vdmVzIHRoZSB0cmFpbGluZyBzbGFzaCBvZiBhIHBhdGggaWYgdGhlcmUgaXMgb25lLiBQcmVzZXJ2ZXMgdGhlIHJvb3QgcGF0aCBgL2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gcGF0aC5lbmRzV2l0aCgnLycpICYmIHBhdGggIT09ICcvJyA/IHBhdGguc2xpY2UoMCwgLTEpIDogcGF0aFxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZXMgdGhlIHRyYWlsaW5nIHNsYXNoIG9mIGEgcGF0aCBhY2NvcmRpbmcgdG8gdGhlIGB0cmFpbGluZ1NsYXNoYCBvcHRpb25cbiAqIGluIGBuZXh0LmNvbmZpZy5qc2AuXG4gKi9cbmV4cG9ydCBjb25zdCBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9UUkFJTElOR19TTEFTSFxuICA/IChwYXRoOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgICAgaWYgKC9cXC5bXi9dK1xcLz8kLy50ZXN0KHBhdGgpKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRoKVxuICAgICAgfSBlbHNlIGlmIChwYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXRoICsgJy8nXG4gICAgICB9XG4gICAgfVxuICA6IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoXG4iLCJ0eXBlIFJlcXVlc3RJZGxlQ2FsbGJhY2tIYW5kbGUgPSBhbnlcbnR5cGUgUmVxdWVzdElkbGVDYWxsYmFja09wdGlvbnMgPSB7XG4gIHRpbWVvdXQ6IG51bWJlclxufVxudHlwZSBSZXF1ZXN0SWRsZUNhbGxiYWNrRGVhZGxpbmUgPSB7XG4gIHJlYWRvbmx5IGRpZFRpbWVvdXQ6IGJvb2xlYW5cbiAgdGltZVJlbWFpbmluZzogKCkgPT4gbnVtYmVyXG59XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgcmVxdWVzdElkbGVDYWxsYmFjazogKFxuICAgICAgY2FsbGJhY2s6IChkZWFkbGluZTogUmVxdWVzdElkbGVDYWxsYmFja0RlYWRsaW5lKSA9PiB2b2lkLFxuICAgICAgb3B0cz86IFJlcXVlc3RJZGxlQ2FsbGJhY2tPcHRpb25zXG4gICAgKSA9PiBSZXF1ZXN0SWRsZUNhbGxiYWNrSGFuZGxlXG4gIH1cbn1cblxuY29uc3QgcmVxdWVzdElkbGVDYWxsYmFjayA9XG4gICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5yZXF1ZXN0SWRsZUNhbGxiYWNrKSB8fFxuICBmdW5jdGlvbiAoY2I6IChkZWFkbGluZTogUmVxdWVzdElkbGVDYWxsYmFja0RlYWRsaW5lKSA9PiB2b2lkKSB7XG4gICAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKVxuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiKHtcbiAgICAgICAgZGlkVGltZW91dDogZmFsc2UsXG4gICAgICAgIHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgNTAgLSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSlcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSwgMSlcbiAgfVxuXG5leHBvcnQgZGVmYXVsdCByZXF1ZXN0SWRsZUNhbGxiYWNrXG4iLCJpbXBvcnQgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgdHlwZSB7IENsaWVudEJ1aWxkTWFuaWZlc3QgfSBmcm9tICcuLi9idWlsZC93ZWJwYWNrL3BsdWdpbnMvYnVpbGQtbWFuaWZlc3QtcGx1Z2luJ1xuaW1wb3J0IGdldEFzc2V0UGF0aEZyb21Sb3V0ZSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2dldC1hc3NldC1wYXRoLWZyb20tcm91dGUnXG5pbXBvcnQgcmVxdWVzdElkbGVDYWxsYmFjayBmcm9tICcuL3JlcXVlc3QtaWRsZS1jYWxsYmFjaydcblxuLy8gMy44cyB3YXMgYXJiaXRyYXJpbHkgY2hvc2VuIGFzIGl0J3Mgd2hhdCBodHRwczovL3dlYi5kZXYvaW50ZXJhY3RpdmVcbi8vIGNvbnNpZGVycyBhcyBcIkdvb2RcIiB0aW1lLXRvLWludGVyYWN0aXZlLiBXZSBtdXN0IGFzc3VtZSBzb21ldGhpbmcgd2VudFxuLy8gd3JvbmcgYmV5b25kIHRoaXMgcG9pbnQsIGFuZCB0aGVuIGZhbGwtYmFjayB0byBhIGZ1bGwgcGFnZSB0cmFuc2l0aW9uIHRvXG4vLyBzaG93IHRoZSB1c2VyIHNvbWV0aGluZyBvZiB2YWx1ZS5cbmNvbnN0IE1TX01BWF9JRExFX0RFTEFZID0gMzgwMFxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIF9fQlVJTERfTUFOSUZFU1Q/OiBDbGllbnRCdWlsZE1hbmlmZXN0XG4gICAgX19CVUlMRF9NQU5JRkVTVF9DQj86IEZ1bmN0aW9uXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2FkZWRFbnRyeXBvaW50U3VjY2VzcyB7XG4gIGNvbXBvbmVudDogQ29tcG9uZW50VHlwZVxuICBleHBvcnRzOiBhbnlcbn1cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVkRW50cnlwb2ludEZhaWx1cmUge1xuICBlcnJvcjogdW5rbm93blxufVxuZXhwb3J0IHR5cGUgUm91dGVFbnRyeXBvaW50ID0gTG9hZGVkRW50cnlwb2ludFN1Y2Nlc3MgfCBMb2FkZWRFbnRyeXBvaW50RmFpbHVyZVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlU3R5bGVTaGVldCB7XG4gIGhyZWY6IHN0cmluZ1xuICBjb250ZW50OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2FkZWRSb3V0ZVN1Y2Nlc3MgZXh0ZW5kcyBMb2FkZWRFbnRyeXBvaW50U3VjY2VzcyB7XG4gIHN0eWxlczogUm91dGVTdHlsZVNoZWV0W11cbn1cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVkUm91dGVGYWlsdXJlIHtcbiAgZXJyb3I6IHVua25vd25cbn1cbmV4cG9ydCB0eXBlIFJvdXRlTG9hZGVyRW50cnkgPSBMb2FkZWRSb3V0ZVN1Y2Nlc3MgfCBMb2FkZWRSb3V0ZUZhaWx1cmVcblxuZXhwb3J0IHR5cGUgRnV0dXJlPFY+ID0ge1xuICByZXNvbHZlOiAoZW50cnlwb2ludDogVikgPT4gdm9pZFxuICBmdXR1cmU6IFByb21pc2U8Vj5cbn1cbmZ1bmN0aW9uIHdpdGhGdXR1cmU8VD4oXG4gIGtleTogc3RyaW5nLFxuICBtYXA6IE1hcDxzdHJpbmcsIEZ1dHVyZTxUPiB8IFQ+LFxuICBnZW5lcmF0b3I/OiAoKSA9PiBQcm9taXNlPFQ+XG4pOiBQcm9taXNlPFQ+IHtcbiAgbGV0IGVudHJ5OiBGdXR1cmU8VD4gfCBUIHwgdW5kZWZpbmVkID0gbWFwLmdldChrZXkpXG4gIGlmIChlbnRyeSkge1xuICAgIGlmICgnZnV0dXJlJyBpbiBlbnRyeSkge1xuICAgICAgcmV0dXJuIGVudHJ5LmZ1dHVyZVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGVudHJ5KVxuICB9XG4gIGxldCByZXNvbHZlcjogKGVudHJ5cG9pbnQ6IFQpID0+IHZvaWRcbiAgY29uc3QgcHJvbSA9IG5ldyBQcm9taXNlPFQ+KChyZXNvbHZlKSA9PiB7XG4gICAgcmVzb2x2ZXIgPSByZXNvbHZlXG4gIH0pXG4gIG1hcC5zZXQoa2V5LCAoZW50cnkgPSB7IHJlc29sdmU6IHJlc29sdmVyISwgZnV0dXJlOiBwcm9tIH0pKVxuICByZXR1cm4gZ2VuZXJhdG9yXG4gICAgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VxdWVuY2VzXG4gICAgICBnZW5lcmF0b3IoKS50aGVuKCh2YWx1ZSkgPT4gKHJlc29sdmVyKHZhbHVlKSwgdmFsdWUpKVxuICAgIDogcHJvbVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlTG9hZGVyIHtcbiAgd2hlbkVudHJ5cG9pbnQocm91dGU6IHN0cmluZyk6IFByb21pc2U8Um91dGVFbnRyeXBvaW50PlxuICBvbkVudHJ5cG9pbnQocm91dGU6IHN0cmluZywgZXhlY3V0ZTogKCkgPT4gdW5rbm93bik6IHZvaWRcbiAgbG9hZFJvdXRlKHJvdXRlOiBzdHJpbmcpOiBQcm9taXNlPFJvdXRlTG9hZGVyRW50cnk+XG4gIHByZWZldGNoKHJvdXRlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+XG59XG5cbmZ1bmN0aW9uIGhhc1ByZWZldGNoKGxpbms/OiBIVE1MTGlua0VsZW1lbnQpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpXG4gICAgcmV0dXJuIChcbiAgICAgIC8vIGRldGVjdCBJRTExIHNpbmNlIGl0IHN1cHBvcnRzIHByZWZldGNoIGJ1dCBpc24ndCBkZXRlY3RlZFxuICAgICAgLy8gd2l0aCByZWxMaXN0LnN1cHBvcnRcbiAgICAgICghIXdpbmRvdy5NU0lucHV0TWV0aG9kQ29udGV4dCAmJiAhIShkb2N1bWVudCBhcyBhbnkpLmRvY3VtZW50TW9kZSkgfHxcbiAgICAgIGxpbmsucmVsTGlzdC5zdXBwb3J0cygncHJlZmV0Y2gnKVxuICAgIClcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuY29uc3QgY2FuUHJlZmV0Y2g6IGJvb2xlYW4gPSBoYXNQcmVmZXRjaCgpXG5cbmZ1bmN0aW9uIHByZWZldGNoVmlhRG9tKFxuICBocmVmOiBzdHJpbmcsXG4gIGFzOiBzdHJpbmcsXG4gIGxpbms/OiBIVE1MTGlua0VsZW1lbnRcbik6IFByb21pc2U8YW55PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgbGlua1tyZWw9XCJwcmVmZXRjaFwiXVtocmVmXj1cIiR7aHJlZn1cIl1gKSkge1xuICAgICAgcmV0dXJuIHJlcygpXG4gICAgfVxuXG4gICAgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKVxuXG4gICAgLy8gVGhlIG9yZGVyIG9mIHByb3BlcnR5IGFzc2lnbm1lbnQgaGVyZSBpcyBpbnRlbnRpb25hbDpcbiAgICBpZiAoYXMpIGxpbmshLmFzID0gYXNcbiAgICBsaW5rIS5yZWwgPSBgcHJlZmV0Y2hgXG4gICAgbGluayEuY3Jvc3NPcmlnaW4gPSBwcm9jZXNzLmVudi5fX05FWFRfQ1JPU1NfT1JJR0lOIVxuICAgIGxpbmshLm9ubG9hZCA9IHJlc1xuICAgIGxpbmshLm9uZXJyb3IgPSByZWpcblxuICAgIC8vIGBocmVmYCBzaG91bGQgYWx3YXlzIGJlIGxhc3Q6XG4gICAgbGluayEuaHJlZiA9IGhyZWZcblxuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobGluaylcbiAgfSlcbn1cblxuY29uc3QgQVNTRVRfTE9BRF9FUlJPUiA9IFN5bWJvbCgnQVNTRVRfTE9BRF9FUlJPUicpXG4vLyBUT0RPOiB1bmV4cG9ydFxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtBc3NldEVycm9yKGVycjogRXJyb3IpOiBFcnJvciB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCBBU1NFVF9MT0FEX0VSUk9SLCB7fSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXNzZXRFcnJvcihlcnI/OiBFcnJvcikge1xuICByZXR1cm4gZXJyICYmIEFTU0VUX0xPQURfRVJST1IgaW4gZXJyXG59XG5cbmZ1bmN0aW9uIGFwcGVuZFNjcmlwdChcbiAgc3JjOiBzdHJpbmcsXG4gIHNjcmlwdD86IEhUTUxTY3JpcHRFbGVtZW50XG4pOiBQcm9taXNlPHVua25vd24+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKVxuXG4gICAgLy8gVGhlIG9yZGVyIG9mIHByb3BlcnR5IGFzc2lnbm1lbnQgaGVyZSBpcyBpbnRlbnRpb25hbC5cbiAgICAvLyAxLiBTZXR1cCBzdWNjZXNzL2ZhaWx1cmUgaG9va3MgaW4gY2FzZSB0aGUgYnJvd3NlciBzeW5jaHJvbm91c2x5XG4gICAgLy8gICAgZXhlY3V0ZXMgd2hlbiBgc3JjYCBpcyBzZXQuXG4gICAgc2NyaXB0Lm9ubG9hZCA9IHJlc29sdmVcbiAgICBzY3JpcHQub25lcnJvciA9ICgpID0+XG4gICAgICByZWplY3QobWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzY3JpcHQ6ICR7c3JjfWApKSlcblxuICAgIC8vIDIuIENvbmZpZ3VyZSB0aGUgY3Jvc3Mtb3JpZ2luIGF0dHJpYnV0ZSBiZWZvcmUgc2V0dGluZyBgc3JjYCBpbiBjYXNlIHRoZVxuICAgIC8vICAgIGJyb3dzZXIgYmVnaW5zIHRvIGZldGNoLlxuICAgIHNjcmlwdC5jcm9zc09yaWdpbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9DUk9TU19PUklHSU4hXG5cbiAgICAvLyAzLiBGaW5hbGx5LCBzZXQgdGhlIHNvdXJjZSBhbmQgaW5qZWN0IGludG8gdGhlIERPTSBpbiBjYXNlIHRoZSBjaGlsZFxuICAgIC8vICAgIG11c3QgYmUgYXBwZW5kZWQgZm9yIGZldGNoaW5nIHRvIHN0YXJ0LlxuICAgIHNjcmlwdC5zcmMgPSBzcmNcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdClcbiAgfSlcbn1cblxuZnVuY3Rpb24gaWRsZVRpbWVvdXQ8VD4obXM6IG51bWJlciwgZXJyOiBFcnJvcik6IFByb21pc2U8VD4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKF9yZXNvbHZlLCByZWplY3QpID0+XG4gICAgcmVxdWVzdElkbGVDYWxsYmFjaygoKSA9PiBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChlcnIpLCBtcykpXG4gIClcbn1cblxuLy8gVE9ETzogc3RvcCBleHBvcnRpbmcgb3IgY2FjaGUgdGhlIGZhaWx1cmVcbi8vIEl0J2QgYmUgYmVzdCB0byBzdG9wIGV4cG9ydGluZyB0aGlzLiBJdCdzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbC4gV2UncmVcbi8vIG9ubHkgZXhwb3J0aW5nIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbHR5IHdpdGggdGhlIGBwYWdlLWxvYWRlcmAuXG4vLyBPbmx5IGNhY2hlIHRoaXMgcmVzcG9uc2UgYXMgYSBsYXN0IHJlc29ydCBpZiB3ZSBjYW5ub3QgZWxpbWluYXRlIGFsbCBvdGhlclxuLy8gY29kZSBicmFuY2hlcyB0aGF0IHVzZSB0aGUgQnVpbGQgTWFuaWZlc3QgQ2FsbGJhY2sgYW5kIHB1c2ggdGhlbSB0aHJvdWdoXG4vLyB0aGUgUm91dGUgTG9hZGVyIGludGVyZmFjZS5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGllbnRCdWlsZE1hbmlmZXN0KCk6IFByb21pc2U8Q2xpZW50QnVpbGRNYW5pZmVzdD4ge1xuICBpZiAoc2VsZi5fX0JVSUxEX01BTklGRVNUKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzZWxmLl9fQlVJTERfTUFOSUZFU1QpXG4gIH1cblxuICBjb25zdCBvbkJ1aWxkTWFuaWZlc3QgPSBuZXcgUHJvbWlzZTxDbGllbnRCdWlsZE1hbmlmZXN0PigocmVzb2x2ZSkgPT4ge1xuICAgIC8vIE1hbmRhdG9yeSBiZWNhdXNlIHRoaXMgaXMgbm90IGNvbmN1cnJlbnQgc2FmZTpcbiAgICBjb25zdCBjYiA9IHNlbGYuX19CVUlMRF9NQU5JRkVTVF9DQlxuICAgIHNlbGYuX19CVUlMRF9NQU5JRkVTVF9DQiA9ICgpID0+IHtcbiAgICAgIHJlc29sdmUoc2VsZi5fX0JVSUxEX01BTklGRVNUKVxuICAgICAgY2IgJiYgY2IoKVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgb25CdWlsZE1hbmlmZXN0LFxuICAgIGlkbGVUaW1lb3V0PENsaWVudEJ1aWxkTWFuaWZlc3Q+KFxuICAgICAgTVNfTUFYX0lETEVfREVMQVksXG4gICAgICBtYXJrQXNzZXRFcnJvcihuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGNsaWVudCBidWlsZCBtYW5pZmVzdCcpKVxuICAgICksXG4gIF0pXG59XG5cbmludGVyZmFjZSBSb3V0ZUZpbGVzIHtcbiAgc2NyaXB0czogc3RyaW5nW11cbiAgY3NzOiBzdHJpbmdbXVxufVxuZnVuY3Rpb24gZ2V0RmlsZXNGb3JSb3V0ZShcbiAgYXNzZXRQcmVmaXg6IHN0cmluZyxcbiAgcm91dGU6IHN0cmluZ1xuKTogUHJvbWlzZTxSb3V0ZUZpbGVzPiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgc2NyaXB0czogW1xuICAgICAgICBhc3NldFByZWZpeCArXG4gICAgICAgICAgJy9fbmV4dC9zdGF0aWMvY2h1bmtzL3BhZ2VzJyArXG4gICAgICAgICAgZW5jb2RlVVJJKGdldEFzc2V0UGF0aEZyb21Sb3V0ZShyb3V0ZSwgJy5qcycpKSxcbiAgICAgIF0sXG4gICAgICAvLyBTdHlsZXMgYXJlIGhhbmRsZWQgYnkgYHN0eWxlLWxvYWRlcmAgaW4gZGV2ZWxvcG1lbnQ6XG4gICAgICBjc3M6IFtdLFxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIGdldENsaWVudEJ1aWxkTWFuaWZlc3QoKS50aGVuKChtYW5pZmVzdCkgPT4ge1xuICAgIGlmICghKHJvdXRlIGluIG1hbmlmZXN0KSkge1xuICAgICAgdGhyb3cgbWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9va3VwIHJvdXRlOiAke3JvdXRlfWApKVxuICAgIH1cbiAgICBjb25zdCBhbGxGaWxlcyA9IG1hbmlmZXN0W3JvdXRlXS5tYXAoXG4gICAgICAoZW50cnkpID0+IGFzc2V0UHJlZml4ICsgJy9fbmV4dC8nICsgZW5jb2RlVVJJKGVudHJ5KVxuICAgIClcbiAgICByZXR1cm4ge1xuICAgICAgc2NyaXB0czogYWxsRmlsZXMuZmlsdGVyKCh2KSA9PiB2LmVuZHNXaXRoKCcuanMnKSksXG4gICAgICBjc3M6IGFsbEZpbGVzLmZpbHRlcigodikgPT4gdi5lbmRzV2l0aCgnLmNzcycpKSxcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlTG9hZGVyKGFzc2V0UHJlZml4OiBzdHJpbmcpOiBSb3V0ZUxvYWRlciB7XG4gIGNvbnN0IGVudHJ5cG9pbnRzOiBNYXA8XG4gICAgc3RyaW5nLFxuICAgIEZ1dHVyZTxSb3V0ZUVudHJ5cG9pbnQ+IHwgUm91dGVFbnRyeXBvaW50XG4gID4gPSBuZXcgTWFwKClcbiAgY29uc3QgbG9hZGVkU2NyaXB0czogTWFwPHN0cmluZywgUHJvbWlzZTx1bmtub3duPj4gPSBuZXcgTWFwKClcbiAgY29uc3Qgc3R5bGVTaGVldHM6IE1hcDxzdHJpbmcsIFByb21pc2U8Um91dGVTdHlsZVNoZWV0Pj4gPSBuZXcgTWFwKClcbiAgY29uc3Qgcm91dGVzOiBNYXA8XG4gICAgc3RyaW5nLFxuICAgIEZ1dHVyZTxSb3V0ZUxvYWRlckVudHJ5PiB8IFJvdXRlTG9hZGVyRW50cnlcbiAgPiA9IG5ldyBNYXAoKVxuXG4gIGZ1bmN0aW9uIG1heWJlRXhlY3V0ZVNjcmlwdChzcmM6IHN0cmluZyk6IFByb21pc2U8dW5rbm93bj4ge1xuICAgIGxldCBwcm9tID0gbG9hZGVkU2NyaXB0cy5nZXQoc3JjKVxuICAgIGlmIChwcm9tKSB7XG4gICAgICByZXR1cm4gcHJvbVxuICAgIH1cblxuICAgIC8vIFNraXAgZXhlY3V0aW5nIHNjcmlwdCBpZiBpdCdzIGFscmVhZHkgaW4gdGhlIERPTTpcbiAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc2NyaXB0W3NyY149XCIke3NyY31cIl1gKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgbG9hZGVkU2NyaXB0cy5zZXQoc3JjLCAocHJvbSA9IGFwcGVuZFNjcmlwdChzcmMpKSlcbiAgICByZXR1cm4gcHJvbVxuICB9XG5cbiAgZnVuY3Rpb24gZmV0Y2hTdHlsZVNoZWV0KGhyZWY6IHN0cmluZyk6IFByb21pc2U8Um91dGVTdHlsZVNoZWV0PiB7XG4gICAgbGV0IHByb20gPSBzdHlsZVNoZWV0cy5nZXQoaHJlZilcbiAgICBpZiAocHJvbSkge1xuICAgICAgcmV0dXJuIHByb21cbiAgICB9XG5cbiAgICBzdHlsZVNoZWV0cy5zZXQoXG4gICAgICBocmVmLFxuICAgICAgKHByb20gPSBmZXRjaChocmVmKVxuICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc3R5bGVzaGVldDogJHtocmVmfWApXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXMudGV4dCgpLnRoZW4oKHRleHQpID0+ICh7IGhyZWY6IGhyZWYsIGNvbnRlbnQ6IHRleHQgfSkpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbWFya0Fzc2V0RXJyb3IoZXJyKVxuICAgICAgICB9KSlcbiAgICApXG4gICAgcmV0dXJuIHByb21cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2hlbkVudHJ5cG9pbnQocm91dGU6IHN0cmluZykge1xuICAgICAgcmV0dXJuIHdpdGhGdXR1cmUocm91dGUsIGVudHJ5cG9pbnRzKVxuICAgIH0sXG4gICAgb25FbnRyeXBvaW50KHJvdXRlLCBleGVjdXRlKSB7XG4gICAgICBQcm9taXNlLnJlc29sdmUoZXhlY3V0ZSlcbiAgICAgICAgLnRoZW4oKGZuKSA9PiBmbigpKVxuICAgICAgICAudGhlbihcbiAgICAgICAgICAoZXhwb3J0czogYW55KSA9PiAoe1xuICAgICAgICAgICAgY29tcG9uZW50OiAoZXhwb3J0cyAmJiBleHBvcnRzLmRlZmF1bHQpIHx8IGV4cG9ydHMsXG4gICAgICAgICAgICBleHBvcnRzOiBleHBvcnRzLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIChlcnIpID0+ICh7IGVycm9yOiBlcnIgfSlcbiAgICAgICAgKVxuICAgICAgICAudGhlbigoaW5wdXQ6IFJvdXRlRW50cnlwb2ludCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG9sZCA9IGVudHJ5cG9pbnRzLmdldChyb3V0ZSlcbiAgICAgICAgICBlbnRyeXBvaW50cy5zZXQocm91dGUsIGlucHV0KVxuICAgICAgICAgIGlmIChvbGQgJiYgJ3Jlc29sdmUnIGluIG9sZCkgb2xkLnJlc29sdmUoaW5wdXQpXG4gICAgICAgIH0pXG4gICAgfSxcbiAgICBsb2FkUm91dGUocm91dGUpIHtcbiAgICAgIHJldHVybiB3aXRoRnV0dXJlPFJvdXRlTG9hZGVyRW50cnk+KHJvdXRlLCByb3V0ZXMsIGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IHNjcmlwdHMsIGNzcyB9ID0gYXdhaXQgZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpXG4gICAgICAgICAgY29uc3QgWywgc3R5bGVzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGVudHJ5cG9pbnRzLmhhcyhyb3V0ZSlcbiAgICAgICAgICAgICAgPyBbXVxuICAgICAgICAgICAgICA6IFByb21pc2UuYWxsKHNjcmlwdHMubWFwKG1heWJlRXhlY3V0ZVNjcmlwdCkpLFxuICAgICAgICAgICAgUHJvbWlzZS5hbGwoY3NzLm1hcChmZXRjaFN0eWxlU2hlZXQpKSxcbiAgICAgICAgICBdIGFzIGNvbnN0KVxuXG4gICAgICAgICAgY29uc3QgZW50cnlwb2ludCA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICB0aGlzLndoZW5FbnRyeXBvaW50KHJvdXRlKSxcbiAgICAgICAgICAgIGlkbGVUaW1lb3V0PFJvdXRlTG9hZGVyRW50cnk+KFxuICAgICAgICAgICAgICBNU19NQVhfSURMRV9ERUxBWSxcbiAgICAgICAgICAgICAgbWFya0Fzc2V0RXJyb3IoXG4gICAgICAgICAgICAgICAgbmV3IEVycm9yKGBSb3V0ZSBkaWQgbm90IGNvbXBsZXRlIGxvYWRpbmc6ICR7cm91dGV9YClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBdKVxuICAgICAgICAgIGNvbnN0IHJlczogUm91dGVMb2FkZXJFbnRyeSA9IE9iamVjdC5hc3NpZ248XG4gICAgICAgICAgICB7IHN0eWxlczogUm91dGVTdHlsZVNoZWV0W10gfSxcbiAgICAgICAgICAgIFJvdXRlRW50cnlwb2ludFxuICAgICAgICAgID4oeyBzdHlsZXMgfSwgZW50cnlwb2ludClcbiAgICAgICAgICByZXR1cm4gJ2Vycm9yJyBpbiBlbnRyeXBvaW50ID8gZW50cnlwb2ludCA6IHJlc1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4geyBlcnJvcjogZXJyIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9LFxuICAgIHByZWZldGNoKHJvdXRlKSB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lTGFicy9xdWlja2xpbmsvYmxvYi80NTNhNjYxZmExZmE5NDBlMmQyZTA0NDQ1MjM5OGUzOGM2N2E5OGZiL3NyYy9pbmRleC5tanMjTDExNS1MMTE4XG4gICAgICAvLyBMaWNlbnNlOiBBcGFjaGUgMi4wXG4gICAgICBsZXQgY25cbiAgICAgIGlmICgoY24gPSAobmF2aWdhdG9yIGFzIGFueSkuY29ubmVjdGlvbikpIHtcbiAgICAgICAgLy8gRG9uJ3QgcHJlZmV0Y2ggaWYgdXNpbmcgMkcgb3IgaWYgU2F2ZS1EYXRhIGlzIGVuYWJsZWQuXG4gICAgICAgIGlmIChjbi5zYXZlRGF0YSB8fCAvMmcvLnRlc3QoY24uZWZmZWN0aXZlVHlwZSkpIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGdldEZpbGVzRm9yUm91dGUoYXNzZXRQcmVmaXgsIHJvdXRlKVxuICAgICAgICAudGhlbigob3V0cHV0KSA9PlxuICAgICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgY2FuUHJlZmV0Y2hcbiAgICAgICAgICAgICAgPyBvdXRwdXQuc2NyaXB0cy5tYXAoKHNjcmlwdCkgPT4gcHJlZmV0Y2hWaWFEb20oc2NyaXB0LCAnc2NyaXB0JykpXG4gICAgICAgICAgICAgIDogW11cbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4gdGhpcy5sb2FkUm91dGUocm91dGUpKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goXG4gICAgICAgICAgLy8gc3dhbGxvdyBwcmVmZXRjaCBlcnJvcnNcbiAgICAgICAgICAoKSA9PiB7fVxuICAgICAgICApXG4gICAgfSxcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVSb3V0ZUxvYWRlclxuIiwiLyogZ2xvYmFsIHdpbmRvdyAqL1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFJvdXRlciwgeyBOZXh0Um91dGVyIH0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci9yb3V0ZXInXG5pbXBvcnQgeyBSb3V0ZXJDb250ZXh0IH0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci1jb250ZXh0J1xuXG50eXBlIENsYXNzQXJndW1lbnRzPFQ+ID0gVCBleHRlbmRzIG5ldyAoLi4uYXJnczogaW5mZXIgVSkgPT4gYW55ID8gVSA6IGFueVxuXG50eXBlIFJvdXRlckFyZ3MgPSBDbGFzc0FyZ3VtZW50czx0eXBlb2YgUm91dGVyPlxuXG50eXBlIFNpbmdsZXRvblJvdXRlckJhc2UgPSB7XG4gIHJvdXRlcjogUm91dGVyIHwgbnVsbFxuICByZWFkeUNhbGxiYWNrczogQXJyYXk8KCkgPT4gYW55PlxuICByZWFkeShjYjogKCkgPT4gYW55KTogdm9pZFxufVxuXG5leHBvcnQgeyBSb3V0ZXIsIE5leHRSb3V0ZXIgfVxuXG5leHBvcnQgdHlwZSBTaW5nbGV0b25Sb3V0ZXIgPSBTaW5nbGV0b25Sb3V0ZXJCYXNlICYgTmV4dFJvdXRlclxuXG5jb25zdCBzaW5nbGV0b25Sb3V0ZXI6IFNpbmdsZXRvblJvdXRlckJhc2UgPSB7XG4gIHJvdXRlcjogbnVsbCwgLy8gaG9sZHMgdGhlIGFjdHVhbCByb3V0ZXIgaW5zdGFuY2VcbiAgcmVhZHlDYWxsYmFja3M6IFtdLFxuICByZWFkeShjYjogKCkgPT4gdm9pZCkge1xuICAgIGlmICh0aGlzLnJvdXRlcikgcmV0dXJuIGNiKClcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMucmVhZHlDYWxsYmFja3MucHVzaChjYilcbiAgICB9XG4gIH0sXG59XG5cbi8vIENyZWF0ZSBwdWJsaWMgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBvZiB0aGUgcm91dGVyIGluIHRoZSBzaW5nbGV0b25Sb3V0ZXJcbmNvbnN0IHVybFByb3BlcnR5RmllbGRzID0gW1xuICAncGF0aG5hbWUnLFxuICAncm91dGUnLFxuICAncXVlcnknLFxuICAnYXNQYXRoJyxcbiAgJ2NvbXBvbmVudHMnLFxuICAnaXNGYWxsYmFjaycsXG4gICdiYXNlUGF0aCcsXG4gICdsb2NhbGUnLFxuICAnbG9jYWxlcycsXG4gICdkZWZhdWx0TG9jYWxlJyxcbl1cbmNvbnN0IHJvdXRlckV2ZW50cyA9IFtcbiAgJ3JvdXRlQ2hhbmdlU3RhcnQnLFxuICAnYmVmb3JlSGlzdG9yeUNoYW5nZScsXG4gICdyb3V0ZUNoYW5nZUNvbXBsZXRlJyxcbiAgJ3JvdXRlQ2hhbmdlRXJyb3InLFxuICAnaGFzaENoYW5nZVN0YXJ0JyxcbiAgJ2hhc2hDaGFuZ2VDb21wbGV0ZScsXG5dXG5jb25zdCBjb3JlTWV0aG9kRmllbGRzID0gW1xuICAncHVzaCcsXG4gICdyZXBsYWNlJyxcbiAgJ3JlbG9hZCcsXG4gICdiYWNrJyxcbiAgJ3ByZWZldGNoJyxcbiAgJ2JlZm9yZVBvcFN0YXRlJyxcbl1cblxuLy8gRXZlbnRzIGlzIGEgc3RhdGljIHByb3BlcnR5IG9uIHRoZSByb3V0ZXIsIHRoZSByb3V0ZXIgZG9lc24ndCBoYXZlIHRvIGJlIGluaXRpYWxpemVkIHRvIHVzZSBpdFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNpbmdsZXRvblJvdXRlciwgJ2V2ZW50cycsIHtcbiAgZ2V0KCkge1xuICAgIHJldHVybiBSb3V0ZXIuZXZlbnRzXG4gIH0sXG59KVxuXG51cmxQcm9wZXJ0eUZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAvLyBIZXJlIHdlIG5lZWQgdG8gdXNlIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBiZWNhdXNlLCB3ZSBuZWVkIHRvIHJldHVyblxuICAvLyB0aGUgcHJvcGVydHkgYXNzaWduZWQgdG8gdGhlIGFjdHVhbCByb3V0ZXJcbiAgLy8gVGhlIHZhbHVlIG1pZ2h0IGdldCBjaGFuZ2VkIGFzIHdlIGNoYW5nZSByb3V0ZXMgYW5kIHRoaXMgaXMgdGhlXG4gIC8vIHByb3BlciB3YXkgdG8gYWNjZXNzIGl0XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaW5nbGV0b25Sb3V0ZXIsIGZpZWxkLCB7XG4gICAgZ2V0KCkge1xuICAgICAgY29uc3Qgcm91dGVyID0gZ2V0Um91dGVyKCkgYXMgYW55XG4gICAgICByZXR1cm4gcm91dGVyW2ZpZWxkXSBhcyBzdHJpbmdcbiAgICB9LFxuICB9KVxufSlcblxuY29yZU1ldGhvZEZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAvLyBXZSBkb24ndCByZWFsbHkga25vdyB0aGUgdHlwZXMgaGVyZSwgc28gd2UgYWRkIHRoZW0gbGF0ZXIgaW5zdGVhZFxuICA7KHNpbmdsZXRvblJvdXRlciBhcyBhbnkpW2ZpZWxkXSA9ICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgIGNvbnN0IHJvdXRlciA9IGdldFJvdXRlcigpIGFzIGFueVxuICAgIHJldHVybiByb3V0ZXJbZmllbGRdKC4uLmFyZ3MpXG4gIH1cbn0pXG5cbnJvdXRlckV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4ge1xuICBzaW5nbGV0b25Sb3V0ZXIucmVhZHkoKCkgPT4ge1xuICAgIFJvdXRlci5ldmVudHMub24oZXZlbnQsICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBldmVudEZpZWxkID0gYG9uJHtldmVudC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke2V2ZW50LnN1YnN0cmluZyhcbiAgICAgICAgMVxuICAgICAgKX1gXG4gICAgICBjb25zdCBfc2luZ2xldG9uUm91dGVyID0gc2luZ2xldG9uUm91dGVyIGFzIGFueVxuICAgICAgaWYgKF9zaW5nbGV0b25Sb3V0ZXJbZXZlbnRGaWVsZF0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBfc2luZ2xldG9uUm91dGVyW2V2ZW50RmllbGRdKC4uLmFyZ3MpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHdoZW4gcnVubmluZyB0aGUgUm91dGVyIGV2ZW50OiAke2V2ZW50RmllbGR9YClcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGAke2Vyci5tZXNzYWdlfVxcbiR7ZXJyLnN0YWNrfWApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9KVxufSlcblxuZnVuY3Rpb24gZ2V0Um91dGVyKCk6IFJvdXRlciB7XG4gIGlmICghc2luZ2xldG9uUm91dGVyLnJvdXRlcikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgJ05vIHJvdXRlciBpbnN0YW5jZSBmb3VuZC5cXG4nICtcbiAgICAgICdZb3Ugc2hvdWxkIG9ubHkgdXNlIFwibmV4dC9yb3V0ZXJcIiBpbnNpZGUgdGhlIGNsaWVudCBzaWRlIG9mIHlvdXIgYXBwLlxcbidcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgfVxuICByZXR1cm4gc2luZ2xldG9uUm91dGVyLnJvdXRlclxufVxuXG4vLyBFeHBvcnQgdGhlIHNpbmdsZXRvblJvdXRlciBhbmQgdGhpcyBpcyB0aGUgcHVibGljIEFQSS5cbmV4cG9ydCBkZWZhdWx0IHNpbmdsZXRvblJvdXRlciBhcyBTaW5nbGV0b25Sb3V0ZXJcblxuLy8gUmVleHBvcnQgdGhlIHdpdGhSb3V0ZSBIT0NcbmV4cG9ydCB7IGRlZmF1bHQgYXMgd2l0aFJvdXRlciB9IGZyb20gJy4vd2l0aC1yb3V0ZXInXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3V0ZXIoKTogTmV4dFJvdXRlciB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KFJvdXRlckNvbnRleHQpXG59XG5cbi8vIElOVEVSTkFMIEFQSVNcbi8vIC0tLS0tLS0tLS0tLS1cbi8vIChkbyBub3QgdXNlIGZvbGxvd2luZyBleHBvcnRzIGluc2lkZSB0aGUgYXBwKVxuXG4vLyBDcmVhdGUgYSByb3V0ZXIgYW5kIGFzc2lnbiBpdCBhcyB0aGUgc2luZ2xldG9uIGluc3RhbmNlLlxuLy8gVGhpcyBpcyB1c2VkIGluIGNsaWVudCBzaWRlIHdoZW4gd2UgYXJlIGluaXRpbGl6aW5nIHRoZSBhcHAuXG4vLyBUaGlzIHNob3VsZCAqKm5vdCoqIHVzZSBpbnNpZGUgdGhlIHNlcnZlci5cbmV4cG9ydCBjb25zdCBjcmVhdGVSb3V0ZXIgPSAoLi4uYXJnczogUm91dGVyQXJncyk6IFJvdXRlciA9PiB7XG4gIHNpbmdsZXRvblJvdXRlci5yb3V0ZXIgPSBuZXcgUm91dGVyKC4uLmFyZ3MpXG4gIHNpbmdsZXRvblJvdXRlci5yZWFkeUNhbGxiYWNrcy5mb3JFYWNoKChjYikgPT4gY2IoKSlcbiAgc2luZ2xldG9uUm91dGVyLnJlYWR5Q2FsbGJhY2tzID0gW11cblxuICByZXR1cm4gc2luZ2xldG9uUm91dGVyLnJvdXRlclxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gY3JlYXRlIHRoZSBgd2l0aFJvdXRlcmAgcm91dGVyIGluc3RhbmNlXG5leHBvcnQgZnVuY3Rpb24gbWFrZVB1YmxpY1JvdXRlckluc3RhbmNlKHJvdXRlcjogUm91dGVyKTogTmV4dFJvdXRlciB7XG4gIGNvbnN0IF9yb3V0ZXIgPSByb3V0ZXIgYXMgYW55XG4gIGNvbnN0IGluc3RhbmNlID0ge30gYXMgYW55XG5cbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiB1cmxQcm9wZXJ0eUZpZWxkcykge1xuICAgIGlmICh0eXBlb2YgX3JvdXRlcltwcm9wZXJ0eV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBpbnN0YW5jZVtwcm9wZXJ0eV0gPSBPYmplY3QuYXNzaWduKFxuICAgICAgICBBcnJheS5pc0FycmF5KF9yb3V0ZXJbcHJvcGVydHldKSA/IFtdIDoge30sXG4gICAgICAgIF9yb3V0ZXJbcHJvcGVydHldXG4gICAgICApIC8vIG1ha2VzIHN1cmUgcXVlcnkgaXMgbm90IHN0YXRlZnVsXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGluc3RhbmNlW3Byb3BlcnR5XSA9IF9yb3V0ZXJbcHJvcGVydHldXG4gIH1cblxuICAvLyBFdmVudHMgaXMgYSBzdGF0aWMgcHJvcGVydHkgb24gdGhlIHJvdXRlciwgdGhlIHJvdXRlciBkb2Vzbid0IGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gdXNlIGl0XG4gIGluc3RhbmNlLmV2ZW50cyA9IFJvdXRlci5ldmVudHNcblxuICBjb3JlTWV0aG9kRmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgaW5zdGFuY2VbZmllbGRdID0gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgICByZXR1cm4gX3JvdXRlcltmaWVsZF0oLi4uYXJncylcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIGluc3RhbmNlXG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBOZXh0Q29tcG9uZW50VHlwZSwgTmV4dFBhZ2VDb250ZXh0IH0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3V0aWxzJ1xuaW1wb3J0IHsgTmV4dFJvdXRlciwgdXNlUm91dGVyIH0gZnJvbSAnLi9yb3V0ZXInXG5cbmV4cG9ydCB0eXBlIFdpdGhSb3V0ZXJQcm9wcyA9IHtcbiAgcm91dGVyOiBOZXh0Um91dGVyXG59XG5cbmV4cG9ydCB0eXBlIEV4Y2x1ZGVSb3V0ZXJQcm9wczxQPiA9IFBpY2s8XG4gIFAsXG4gIEV4Y2x1ZGU8a2V5b2YgUCwga2V5b2YgV2l0aFJvdXRlclByb3BzPlxuPlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3aXRoUm91dGVyPFxuICBQIGV4dGVuZHMgV2l0aFJvdXRlclByb3BzLFxuICBDID0gTmV4dFBhZ2VDb250ZXh0XG4+KFxuICBDb21wb3NlZENvbXBvbmVudDogTmV4dENvbXBvbmVudFR5cGU8QywgYW55LCBQPlxuKTogUmVhY3QuQ29tcG9uZW50VHlwZTxFeGNsdWRlUm91dGVyUHJvcHM8UD4+IHtcbiAgZnVuY3Rpb24gV2l0aFJvdXRlcldyYXBwZXIocHJvcHM6IGFueSkge1xuICAgIHJldHVybiA8Q29tcG9zZWRDb21wb25lbnQgcm91dGVyPXt1c2VSb3V0ZXIoKX0gey4uLnByb3BzfSAvPlxuICB9XG5cbiAgV2l0aFJvdXRlcldyYXBwZXIuZ2V0SW5pdGlhbFByb3BzID0gQ29tcG9zZWRDb21wb25lbnQuZ2V0SW5pdGlhbFByb3BzXG4gIC8vIFRoaXMgaXMgbmVlZGVkIHRvIGFsbG93IGNoZWNraW5nIGZvciBjdXN0b20gZ2V0SW5pdGlhbFByb3BzIGluIF9hcHBcbiAgOyhXaXRoUm91dGVyV3JhcHBlciBhcyBhbnkpLm9yaWdHZXRJbml0aWFsUHJvcHMgPSAoQ29tcG9zZWRDb21wb25lbnQgYXMgYW55KS5vcmlnR2V0SW5pdGlhbFByb3BzXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgbmFtZSA9XG4gICAgICBDb21wb3NlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb3NlZENvbXBvbmVudC5uYW1lIHx8ICdVbmtub3duJ1xuICAgIFdpdGhSb3V0ZXJXcmFwcGVyLmRpc3BsYXlOYW1lID0gYHdpdGhSb3V0ZXIoJHtuYW1lfSlgXG4gIH1cblxuICByZXR1cm4gV2l0aFJvdXRlcldyYXBwZXJcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBUb2tlbml6ZSBpbnB1dCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGxleGVyKHN0cikge1xuICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaGFyID0gc3RyW2ldO1xuICAgICAgICBpZiAoY2hhciA9PT0gXCIqXCIgfHwgY2hhciA9PT0gXCIrXCIgfHwgY2hhciA9PT0gXCI/XCIpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJNT0RJRklFUlwiLCBpbmRleDogaSwgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiRVNDQVBFRF9DSEFSXCIsIGluZGV4OiBpKyssIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSBcIntcIikge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIk9QRU5cIiwgaW5kZXg6IGksIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSBcIn1cIikge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIkNMT1NFXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gXCJcIjtcbiAgICAgICAgICAgIHZhciBqID0gaSArIDE7XG4gICAgICAgICAgICB3aGlsZSAoaiA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGopO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAvLyBgMC05YFxuICAgICAgICAgICAgICAgIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIGBBLVpgXG4gICAgICAgICAgICAgICAgICAgIChjb2RlID49IDY1ICYmIGNvZGUgPD0gOTApIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIGBhLXpgXG4gICAgICAgICAgICAgICAgICAgIChjb2RlID49IDk3ICYmIGNvZGUgPD0gMTIyKSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBgX2BcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9PT0gOTUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSArPSBzdHJbaisrXTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuYW1lKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNaXNzaW5nIHBhcmFtZXRlciBuYW1lIGF0IFwiICsgaSk7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiTkFNRVwiLCBpbmRleDogaSwgdmFsdWU6IG5hbWUgfSk7XG4gICAgICAgICAgICBpID0gajtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSBcIihcIikge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMTtcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gXCJcIjtcbiAgICAgICAgICAgIHZhciBqID0gaSArIDE7XG4gICAgICAgICAgICBpZiAoc3RyW2pdID09PSBcIj9cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXR0ZXJuIGNhbm5vdCBzdGFydCB3aXRoIFxcXCI/XFxcIiBhdCBcIiArIGopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGogPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cltqXSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiArPSBzdHJbaisrXSArIHN0cltqKytdO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0cltqXSA9PT0gXCIpXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdHJbal0gPT09IFwiKFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJbaiArIDFdICE9PSBcIj9cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhcHR1cmluZyBncm91cHMgYXJlIG5vdCBhbGxvd2VkIGF0IFwiICsgaik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGF0dGVybiArPSBzdHJbaisrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb3VudClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5iYWxhbmNlZCBwYXR0ZXJuIGF0IFwiICsgaSk7XG4gICAgICAgICAgICBpZiAoIXBhdHRlcm4pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk1pc3NpbmcgcGF0dGVybiBhdCBcIiArIGkpO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIlBBVFRFUk5cIiwgaW5kZXg6IGksIHZhbHVlOiBwYXR0ZXJuIH0pO1xuICAgICAgICAgICAgaSA9IGo7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiQ0hBUlwiLCBpbmRleDogaSwgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgIH1cbiAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiRU5EXCIsIGluZGV4OiBpLCB2YWx1ZTogXCJcIiB9KTtcbiAgICByZXR1cm4gdG9rZW5zO1xufVxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBmb3IgdGhlIHJhdyB0b2tlbnMuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKHN0ciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIHRva2VucyA9IGxleGVyKHN0cik7XG4gICAgdmFyIF9hID0gb3B0aW9ucy5wcmVmaXhlcywgcHJlZml4ZXMgPSBfYSA9PT0gdm9pZCAwID8gXCIuL1wiIDogX2E7XG4gICAgdmFyIGRlZmF1bHRQYXR0ZXJuID0gXCJbXlwiICsgZXNjYXBlU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVyIHx8IFwiLyM/XCIpICsgXCJdKz9cIjtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGtleSA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBwYXRoID0gXCJcIjtcbiAgICB2YXIgdHJ5Q29uc3VtZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIGlmIChpIDwgdG9rZW5zLmxlbmd0aCAmJiB0b2tlbnNbaV0udHlwZSA9PT0gdHlwZSlcbiAgICAgICAgICAgIHJldHVybiB0b2tlbnNbaSsrXS52YWx1ZTtcbiAgICB9O1xuICAgIHZhciBtdXN0Q29uc3VtZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRyeUNvbnN1bWUodHlwZSk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YXIgX2EgPSB0b2tlbnNbaV0sIG5leHRUeXBlID0gX2EudHlwZSwgaW5kZXggPSBfYS5pbmRleDtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgXCIgKyBuZXh0VHlwZSArIFwiIGF0IFwiICsgaW5kZXggKyBcIiwgZXhwZWN0ZWQgXCIgKyB0eXBlKTtcbiAgICB9O1xuICAgIHZhciBjb25zdW1lVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHdoaWxlICgodmFsdWUgPSB0cnlDb25zdW1lKFwiQ0hBUlwiKSB8fCB0cnlDb25zdW1lKFwiRVNDQVBFRF9DSEFSXCIpKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICB3aGlsZSAoaSA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoYXIgPSB0cnlDb25zdW1lKFwiQ0hBUlwiKTtcbiAgICAgICAgdmFyIG5hbWUgPSB0cnlDb25zdW1lKFwiTkFNRVwiKTtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSB0cnlDb25zdW1lKFwiUEFUVEVSTlwiKTtcbiAgICAgICAgaWYgKG5hbWUgfHwgcGF0dGVybikge1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IGNoYXIgfHwgXCJcIjtcbiAgICAgICAgICAgIGlmIChwcmVmaXhlcy5pbmRleE9mKHByZWZpeCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcGF0aCArPSBwcmVmaXg7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGF0aCk7XG4gICAgICAgICAgICAgICAgcGF0aCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSB8fCBrZXkrKyxcbiAgICAgICAgICAgICAgICBwcmVmaXg6IHByZWZpeCxcbiAgICAgICAgICAgICAgICBzdWZmaXg6IFwiXCIsXG4gICAgICAgICAgICAgICAgcGF0dGVybjogcGF0dGVybiB8fCBkZWZhdWx0UGF0dGVybixcbiAgICAgICAgICAgICAgICBtb2RpZmllcjogdHJ5Q29uc3VtZShcIk1PRElGSUVSXCIpIHx8IFwiXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gY2hhciB8fCB0cnlDb25zdW1lKFwiRVNDQVBFRF9DSEFSXCIpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHBhdGggKz0gdmFsdWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGF0aCk7XG4gICAgICAgICAgICBwYXRoID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3BlbiA9IHRyeUNvbnN1bWUoXCJPUEVOXCIpO1xuICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IGNvbnN1bWVUZXh0KCk7XG4gICAgICAgICAgICB2YXIgbmFtZV8xID0gdHJ5Q29uc3VtZShcIk5BTUVcIikgfHwgXCJcIjtcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuXzEgPSB0cnlDb25zdW1lKFwiUEFUVEVSTlwiKSB8fCBcIlwiO1xuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IGNvbnN1bWVUZXh0KCk7XG4gICAgICAgICAgICBtdXN0Q29uc3VtZShcIkNMT1NFXCIpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVfMSB8fCAocGF0dGVybl8xID8ga2V5KysgOiBcIlwiKSxcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBuYW1lXzEgJiYgIXBhdHRlcm5fMSA/IGRlZmF1bHRQYXR0ZXJuIDogcGF0dGVybl8xLFxuICAgICAgICAgICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICAgICAgICAgIHN1ZmZpeDogc3VmZml4LFxuICAgICAgICAgICAgICAgIG1vZGlmaWVyOiB0cnlDb25zdW1lKFwiTU9ESUZJRVJcIikgfHwgXCJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtdXN0Q29uc3VtZShcIkVORFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbi8qKlxuICogQ29tcGlsZSBhIHN0cmluZyB0byBhIHRlbXBsYXRlIGZ1bmN0aW9uIGZvciB0aGUgcGF0aC5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZShzdHIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdG9rZW5zVG9GdW5jdGlvbihwYXJzZShzdHIsIG9wdGlvbnMpLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGU7XG4vKipcbiAqIEV4cG9zZSBhIG1ldGhvZCBmb3IgdHJhbnNmb3JtaW5nIHRva2VucyBpbnRvIHRoZSBwYXRoIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB0b2tlbnNUb0Z1bmN0aW9uKHRva2Vucywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIHJlRmxhZ3MgPSBmbGFncyhvcHRpb25zKTtcbiAgICB2YXIgX2EgPSBvcHRpb25zLmVuY29kZSwgZW5jb2RlID0gX2EgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9IDogX2EsIF9iID0gb3B0aW9ucy52YWxpZGF0ZSwgdmFsaWRhdGUgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iO1xuICAgIC8vIENvbXBpbGUgYWxsIHRoZSB0b2tlbnMgaW50byByZWdleHBzLlxuICAgIHZhciBtYXRjaGVzID0gdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKD86XCIgKyB0b2tlbi5wYXR0ZXJuICsgXCIpJFwiLCByZUZsYWdzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgcGF0aCA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcGF0aCArPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRhdGEgPyBkYXRhW3Rva2VuLm5hbWVdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIG9wdGlvbmFsID0gdG9rZW4ubW9kaWZpZXIgPT09IFwiP1wiIHx8IHRva2VuLm1vZGlmaWVyID09PSBcIipcIjtcbiAgICAgICAgICAgIHZhciByZXBlYXQgPSB0b2tlbi5tb2RpZmllciA9PT0gXCIqXCIgfHwgdG9rZW4ubW9kaWZpZXIgPT09IFwiK1wiO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXBlYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFxcXCJcIiArIHRva2VuLm5hbWUgKyBcIlxcXCIgdG8gbm90IHJlcGVhdCwgYnV0IGdvdCBhbiBhcnJheVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFxcXCJcIiArIHRva2VuLm5hbWUgKyBcIlxcXCIgdG8gbm90IGJlIGVtcHR5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWdtZW50ID0gZW5jb2RlKHZhbHVlW2pdLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZSAmJiAhbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYWxsIFxcXCJcIiArIHRva2VuLm5hbWUgKyBcIlxcXCIgdG8gbWF0Y2ggXFxcIlwiICsgdG9rZW4ucGF0dGVybiArIFwiXFxcIiwgYnV0IGdvdCBcXFwiXCIgKyBzZWdtZW50ICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4ICsgc2VnbWVudCArIHRva2VuLnN1ZmZpeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHZhciBzZWdtZW50ID0gZW5jb2RlKFN0cmluZyh2YWx1ZSksIHRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGUgJiYgIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBtYXRjaCBcXFwiXCIgKyB0b2tlbi5wYXR0ZXJuICsgXCJcXFwiLCBidXQgZ290IFxcXCJcIiArIHNlZ21lbnQgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4ICsgc2VnbWVudCArIHRva2VuLnN1ZmZpeDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25hbClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciB0eXBlT2ZNZXNzYWdlID0gcmVwZWF0ID8gXCJhbiBhcnJheVwiIDogXCJhIHN0cmluZ1wiO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFxcXCJcIiArIHRva2VuLm5hbWUgKyBcIlxcXCIgdG8gYmUgXCIgKyB0eXBlT2ZNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9O1xufVxuZXhwb3J0cy50b2tlbnNUb0Z1bmN0aW9uID0gdG9rZW5zVG9GdW5jdGlvbjtcbi8qKlxuICogQ3JlYXRlIHBhdGggbWF0Y2ggZnVuY3Rpb24gZnJvbSBgcGF0aC10by1yZWdleHBgIHNwZWMuXG4gKi9cbmZ1bmN0aW9uIG1hdGNoKHN0ciwgb3B0aW9ucykge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgdmFyIHJlID0gcGF0aFRvUmVnZXhwKHN0ciwga2V5cywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlZ2V4cFRvRnVuY3Rpb24ocmUsIGtleXMsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5tYXRjaCA9IG1hdGNoO1xuLyoqXG4gKiBDcmVhdGUgYSBwYXRoIG1hdGNoIGZ1bmN0aW9uIGZyb20gYHBhdGgtdG8tcmVnZXhwYCBvdXRwdXQuXG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvRnVuY3Rpb24ocmUsIGtleXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBfYSA9IG9wdGlvbnMuZGVjb2RlLCBkZWNvZGUgPSBfYSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0gOiBfYTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHBhdGhuYW1lKSB7XG4gICAgICAgIHZhciBtID0gcmUuZXhlYyhwYXRobmFtZSk7XG4gICAgICAgIGlmICghbSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIHBhdGggPSBtWzBdLCBpbmRleCA9IG0uaW5kZXg7XG4gICAgICAgIHZhciBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgIGlmIChtW2ldID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2kgLSAxXTtcbiAgICAgICAgICAgIGlmIChrZXkubW9kaWZpZXIgPT09IFwiKlwiIHx8IGtleS5tb2RpZmllciA9PT0gXCIrXCIpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNba2V5Lm5hbWVdID0gbVtpXS5zcGxpdChrZXkucHJlZml4ICsga2V5LnN1ZmZpeCkubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlKHZhbHVlLCBrZXkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW2tleS5uYW1lXSA9IGRlY29kZShtW2ldLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIF9sb29wXzEoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcGF0aDogcGF0aCwgaW5kZXg6IGluZGV4LCBwYXJhbXM6IHBhcmFtcyB9O1xuICAgIH07XG59XG5leHBvcnRzLnJlZ2V4cFRvRnVuY3Rpb24gPSByZWdleHBUb0Z1bmN0aW9uO1xuLyoqXG4gKiBFc2NhcGUgYSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy4rKj89XiE6JHt9KClbXFxdfC9cXFxcXSkvZywgXCJcXFxcJDFcIik7XG59XG4vKipcbiAqIEdldCB0aGUgZmxhZ3MgZm9yIGEgcmVnZXhwIGZyb20gdGhlIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGZsYWdzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLnNlbnNpdGl2ZSA/IFwiXCIgOiBcImlcIjtcbn1cbi8qKlxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuICovXG5mdW5jdGlvbiByZWdleHBUb1JlZ2V4cChwYXRoLCBrZXlzKSB7XG4gICAgaWYgKCFrZXlzKVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAvLyBVc2UgYSBuZWdhdGl2ZSBsb29rYWhlYWQgdG8gbWF0Y2ggb25seSBjYXB0dXJpbmcgZ3JvdXBzLlxuICAgIHZhciBncm91cHMgPSBwYXRoLnNvdXJjZS5tYXRjaCgvXFwoKD8hXFw/KS9nKTtcbiAgICBpZiAoZ3JvdXBzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IGksXG4gICAgICAgICAgICAgICAgcHJlZml4OiBcIlwiLFxuICAgICAgICAgICAgICAgIHN1ZmZpeDogXCJcIixcbiAgICAgICAgICAgICAgICBtb2RpZmllcjogXCJcIixcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBcIlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5IGludG8gYSByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAocGF0aHMsIGtleXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFydHMgPSBwYXRocy5tYXAoZnVuY3Rpb24gKHBhdGgpIHsgcmV0dXJuIHBhdGhUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKS5zb3VyY2U7IH0pO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiKD86XCIgKyBwYXJ0cy5qb2luKFwifFwiKSArIFwiKVwiLCBmbGFncyhvcHRpb25zKSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHBhdGggcmVnZXhwIGZyb20gc3RyaW5nIGlucHV0LlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRva2Vuc1RvUmVnZXhwKHBhcnNlKHBhdGgsIG9wdGlvbnMpLCBrZXlzLCBvcHRpb25zKTtcbn1cbi8qKlxuICogRXhwb3NlIGEgZnVuY3Rpb24gZm9yIHRha2luZyB0b2tlbnMgYW5kIHJldHVybmluZyBhIFJlZ0V4cC5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9SZWdleHAodG9rZW5zLCBrZXlzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgX2EgPSBvcHRpb25zLnN0cmljdCwgc3RyaWN0ID0gX2EgPT09IHZvaWQgMCA/IGZhbHNlIDogX2EsIF9iID0gb3B0aW9ucy5zdGFydCwgc3RhcnQgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iLCBfYyA9IG9wdGlvbnMuZW5kLCBlbmQgPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jLCBfZCA9IG9wdGlvbnMuZW5jb2RlLCBlbmNvZGUgPSBfZCA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0gOiBfZDtcbiAgICB2YXIgZW5kc1dpdGggPSBcIltcIiArIGVzY2FwZVN0cmluZyhvcHRpb25zLmVuZHNXaXRoIHx8IFwiXCIpICsgXCJdfCRcIjtcbiAgICB2YXIgZGVsaW1pdGVyID0gXCJbXCIgKyBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgXCIvIz9cIikgKyBcIl1cIjtcbiAgICB2YXIgcm91dGUgPSBzdGFydCA/IFwiXlwiIDogXCJcIjtcbiAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIHRva2VucyBhbmQgY3JlYXRlIG91ciByZWdleHAgc3RyaW5nLlxuICAgIGZvciAodmFyIF9pID0gMCwgdG9rZW5zXzEgPSB0b2tlbnM7IF9pIDwgdG9rZW5zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc18xW19pXTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcm91dGUgKz0gZXNjYXBlU3RyaW5nKGVuY29kZSh0b2tlbikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IGVzY2FwZVN0cmluZyhlbmNvZGUodG9rZW4ucHJlZml4KSk7XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gZXNjYXBlU3RyaW5nKGVuY29kZSh0b2tlbi5zdWZmaXgpKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi5wYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleXMpXG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHByZWZpeCB8fCBzdWZmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLm1vZGlmaWVyID09PSBcIitcIiB8fCB0b2tlbi5tb2RpZmllciA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2QgPSB0b2tlbi5tb2RpZmllciA9PT0gXCIqXCIgPyBcIj9cIiA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZSArPSBcIig/OlwiICsgcHJlZml4ICsgXCIoKD86XCIgKyB0b2tlbi5wYXR0ZXJuICsgXCIpKD86XCIgKyBzdWZmaXggKyBwcmVmaXggKyBcIig/OlwiICsgdG9rZW4ucGF0dGVybiArIFwiKSkqKVwiICsgc3VmZml4ICsgXCIpXCIgKyBtb2Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZSArPSBcIig/OlwiICsgcHJlZml4ICsgXCIoXCIgKyB0b2tlbi5wYXR0ZXJuICsgXCIpXCIgKyBzdWZmaXggKyBcIilcIiArIHRva2VuLm1vZGlmaWVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZSArPSBcIihcIiArIHRva2VuLnBhdHRlcm4gKyBcIilcIiArIHRva2VuLm1vZGlmaWVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvdXRlICs9IFwiKD86XCIgKyBwcmVmaXggKyBzdWZmaXggKyBcIilcIiArIHRva2VuLm1vZGlmaWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbmQpIHtcbiAgICAgICAgaWYgKCFzdHJpY3QpXG4gICAgICAgICAgICByb3V0ZSArPSBkZWxpbWl0ZXIgKyBcIj9cIjtcbiAgICAgICAgcm91dGUgKz0gIW9wdGlvbnMuZW5kc1dpdGggPyBcIiRcIiA6IFwiKD89XCIgKyBlbmRzV2l0aCArIFwiKVwiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGVuZFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIGlzRW5kRGVsaW1pdGVkID0gdHlwZW9mIGVuZFRva2VuID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IGRlbGltaXRlci5pbmRleE9mKGVuZFRva2VuW2VuZFRva2VuLmxlbmd0aCAtIDFdKSA+IC0xXG4gICAgICAgICAgICA6IC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgIGVuZFRva2VuID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghc3RyaWN0KSB7XG4gICAgICAgICAgICByb3V0ZSArPSBcIig/OlwiICsgZGVsaW1pdGVyICsgXCIoPz1cIiArIGVuZHNXaXRoICsgXCIpKT9cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRW5kRGVsaW1pdGVkKSB7XG4gICAgICAgICAgICByb3V0ZSArPSBcIig/PVwiICsgZGVsaW1pdGVyICsgXCJ8XCIgKyBlbmRzV2l0aCArIFwiKVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVnRXhwKHJvdXRlLCBmbGFncyhvcHRpb25zKSk7XG59XG5leHBvcnRzLnRva2Vuc1RvUmVnZXhwID0gdG9rZW5zVG9SZWdleHA7XG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcsIHJldHVybmluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBBbiBlbXB0eSBhcnJheSBjYW4gYmUgcGFzc2VkIGluIGZvciB0aGUga2V5cywgd2hpY2ggd2lsbCBob2xkIHRoZVxuICogcGxhY2Vob2xkZXIga2V5IGRlc2NyaXB0aW9ucy4gRm9yIGV4YW1wbGUsIHVzaW5nIGAvdXNlci86aWRgLCBga2V5c2Agd2lsbFxuICogY29udGFpbiBgW3sgbmFtZTogJ2lkJywgZGVsaW1pdGVyOiAnLycsIG9wdGlvbmFsOiBmYWxzZSwgcmVwZWF0OiBmYWxzZSB9XWAuXG4gKi9cbmZ1bmN0aW9uIHBhdGhUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gICAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApXG4gICAgICAgIHJldHVybiByZWdleHBUb1JlZ2V4cChwYXRoLCBrZXlzKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSlcbiAgICAgICAgcmV0dXJuIGFycmF5VG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHN0cmluZ1RvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5wYXRoVG9SZWdleHAgPSBwYXRoVG9SZWdleHA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlUGF0aChcbiAgcGF0aG5hbWU6IHN0cmluZyxcbiAgbG9jYWxlcz86IHN0cmluZ1tdXG4pOiB7XG4gIGRldGVjdGVkTG9jYWxlPzogc3RyaW5nXG4gIHBhdGhuYW1lOiBzdHJpbmdcbn0ge1xuICBsZXQgZGV0ZWN0ZWRMb2NhbGU6IHN0cmluZyB8IHVuZGVmaW5lZFxuICAvLyBmaXJzdCBpdGVtIHdpbGwgYmUgZW1wdHkgc3RyaW5nIGZyb20gc3BsaXR0aW5nIGF0IGZpcnN0IGNoYXJcbiAgY29uc3QgcGF0aG5hbWVQYXJ0cyA9IHBhdGhuYW1lLnNwbGl0KCcvJylcblxuICA7KGxvY2FsZXMgfHwgW10pLnNvbWUoKGxvY2FsZSkgPT4ge1xuICAgIGlmIChwYXRobmFtZVBhcnRzWzFdLnRvTG93ZXJDYXNlKCkgPT09IGxvY2FsZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBkZXRlY3RlZExvY2FsZSA9IGxvY2FsZVxuICAgICAgcGF0aG5hbWVQYXJ0cy5zcGxpY2UoMSwgMSlcbiAgICAgIHBhdGhuYW1lID0gcGF0aG5hbWVQYXJ0cy5qb2luKCcvJykgfHwgJy8nXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfSlcblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lLFxuICAgIGRldGVjdGVkTG9jYWxlLFxuICB9XG59XG4iLCIvKlxuTUlUIExpY2Vuc2VcblxuQ29weXJpZ2h0IChjKSBKYXNvbiBNaWxsZXIgKGh0dHBzOi8vamFzb25mb3JtYXQuY29tLylcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cblxuLy8gVGhpcyBmaWxlIGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9kZXZlbG9waXQvbWl0dC9ibG9iL3YxLjEuMy9zcmMvaW5kZXguanNcbi8vIEl0J3MgYmVlbiBlZGl0ZWQgZm9yIHRoZSBuZWVkcyBvZiB0aGlzIHNjcmlwdFxuLy8gU2VlIHRoZSBMSUNFTlNFIGF0IHRoZSB0b3Agb2YgdGhlIGZpbGVcblxudHlwZSBIYW5kbGVyID0gKC4uLmV2dHM6IGFueVtdKSA9PiB2b2lkXG5cbmV4cG9ydCB0eXBlIE1pdHRFbWl0dGVyID0ge1xuICBvbih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEhhbmRsZXIpOiB2b2lkXG4gIG9mZih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEhhbmRsZXIpOiB2b2lkXG4gIGVtaXQodHlwZTogc3RyaW5nLCAuLi5ldnRzOiBhbnlbXSk6IHZvaWRcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWl0dCgpOiBNaXR0RW1pdHRlciB7XG4gIGNvbnN0IGFsbDogeyBbczogc3RyaW5nXTogSGFuZGxlcltdIH0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgcmV0dXJuIHtcbiAgICBvbih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEhhbmRsZXIpIHtcbiAgICAgIDsoYWxsW3R5cGVdIHx8IChhbGxbdHlwZV0gPSBbXSkpLnB1c2goaGFuZGxlcilcbiAgICB9LFxuXG4gICAgb2ZmKHR5cGU6IHN0cmluZywgaGFuZGxlcjogSGFuZGxlcikge1xuICAgICAgaWYgKGFsbFt0eXBlXSkge1xuICAgICAgICBhbGxbdHlwZV0uc3BsaWNlKGFsbFt0eXBlXS5pbmRleE9mKGhhbmRsZXIpID4+PiAwLCAxKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbWl0KHR5cGU6IHN0cmluZywgLi4uZXZ0czogYW55W10pIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJheS1jYWxsYmFjay1yZXR1cm5cbiAgICAgIDsoYWxsW3R5cGVdIHx8IFtdKS5zbGljZSgpLm1hcCgoaGFuZGxlcjogSGFuZGxlcikgPT4ge1xuICAgICAgICBoYW5kbGVyKC4uLmV2dHMpXG4gICAgICB9KVxuICAgIH0sXG4gIH1cbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IE5leHRSb3V0ZXIgfSBmcm9tICcuL3JvdXRlci9yb3V0ZXInXG5cbmV4cG9ydCBjb25zdCBSb3V0ZXJDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxOZXh0Um91dGVyPihudWxsIGFzIGFueSlcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdSb3V0ZXJDb250ZXh0J1xufVxuIiwiLyogZ2xvYmFsIF9fTkVYVF9EQVRBX18gKi9cbi8vIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGVcbmltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQge1xuICBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCxcbiAgcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gsXG59IGZyb20gJy4uLy4uLy4uL2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2gnXG5pbXBvcnQgeyBHb29kUGFnZUNhY2hlLCBTdHlsZVNoZWV0VHVwbGUgfSBmcm9tICcuLi8uLi8uLi9jbGllbnQvcGFnZS1sb2FkZXInXG5pbXBvcnQge1xuICBnZXRDbGllbnRCdWlsZE1hbmlmZXN0LFxuICBpc0Fzc2V0RXJyb3IsXG4gIG1hcmtBc3NldEVycm9yLFxufSBmcm9tICcuLi8uLi8uLi9jbGllbnQvcm91dGUtbG9hZGVyJ1xuaW1wb3J0IHsgZGVub3JtYWxpemVQYWdlUGF0aCB9IGZyb20gJy4uLy4uL3NlcnZlci9kZW5vcm1hbGl6ZS1wYWdlLXBhdGgnXG5pbXBvcnQgbWl0dCwgeyBNaXR0RW1pdHRlciB9IGZyb20gJy4uL21pdHQnXG5pbXBvcnQge1xuICBBcHBDb250ZXh0VHlwZSxcbiAgZm9ybWF0V2l0aFZhbGlkYXRpb24sXG4gIGdldExvY2F0aW9uT3JpZ2luLFxuICBnZXRVUkwsXG4gIGxvYWRHZXRJbml0aWFsUHJvcHMsXG4gIE5leHRQYWdlQ29udGV4dCxcbiAgU1QsXG59IGZyb20gJy4uL3V0aWxzJ1xuaW1wb3J0IGVzY2FwZVBhdGhEZWxpbWl0ZXJzIGZyb20gJy4vdXRpbHMvZXNjYXBlLXBhdGgtZGVsaW1pdGVycydcbmltcG9ydCB7IGlzRHluYW1pY1JvdXRlIH0gZnJvbSAnLi91dGlscy9pcy1keW5hbWljJ1xuaW1wb3J0IHsgcGFyc2VSZWxhdGl2ZVVybCB9IGZyb20gJy4vdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsJ1xuaW1wb3J0IHsgc2VhcmNoUGFyYW1zVG9VcmxRdWVyeSB9IGZyb20gJy4vdXRpbHMvcXVlcnlzdHJpbmcnXG5pbXBvcnQgcmVzb2x2ZVJld3JpdGVzIGZyb20gJy4vdXRpbHMvcmVzb2x2ZS1yZXdyaXRlcydcbmltcG9ydCB7IGdldFJvdXRlTWF0Y2hlciB9IGZyb20gJy4vdXRpbHMvcm91dGUtbWF0Y2hlcidcbmltcG9ydCB7IGdldFJvdXRlUmVnZXggfSBmcm9tICcuL3V0aWxzL3JvdXRlLXJlZ2V4J1xuXG5pbnRlcmZhY2UgVHJhbnNpdGlvbk9wdGlvbnMge1xuICBzaGFsbG93PzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZVxufVxuXG5pbnRlcmZhY2UgTmV4dEhpc3RvcnlTdGF0ZSB7XG4gIHVybDogc3RyaW5nXG4gIGFzOiBzdHJpbmdcbiAgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnNcbn1cblxudHlwZSBIaXN0b3J5U3RhdGUgPSBudWxsIHwgeyBfX046IGZhbHNlIH0gfCAoeyBfX046IHRydWUgfSAmIE5leHRIaXN0b3J5U3RhdGUpXG5cbmNvbnN0IGJhc2VQYXRoID0gKHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggYXMgc3RyaW5nKSB8fCAnJ1xuXG5mdW5jdGlvbiBidWlsZENhbmNlbGxhdGlvbkVycm9yKCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ1JvdXRlIENhbmNlbGxlZCcpLCB7XG4gICAgY2FuY2VsbGVkOiB0cnVlLFxuICB9KVxufVxuXG5mdW5jdGlvbiBhZGRQYXRoUHJlZml4KHBhdGg6IHN0cmluZywgcHJlZml4Pzogc3RyaW5nKSB7XG4gIHJldHVybiBwcmVmaXggJiYgcGF0aC5zdGFydHNXaXRoKCcvJylcbiAgICA/IHBhdGggPT09ICcvJ1xuICAgICAgPyBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaChwcmVmaXgpXG4gICAgICA6IGAke3ByZWZpeH0ke3BhdGh9YFxuICAgIDogcGF0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkTG9jYWxlKFxuICBwYXRoOiBzdHJpbmcsXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlLFxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICByZXR1cm4gbG9jYWxlICYmXG4gICAgICBsb2NhbGUgIT09IGRlZmF1bHRMb2NhbGUgJiZcbiAgICAgICFwYXRoLnN0YXJ0c1dpdGgoJy8nICsgbG9jYWxlICsgJy8nKSAmJlxuICAgICAgcGF0aCAhPT0gJy8nICsgbG9jYWxlXG4gICAgICA/IGFkZFBhdGhQcmVmaXgocGF0aCwgJy8nICsgbG9jYWxlKVxuICAgICAgOiBwYXRoXG4gIH1cbiAgcmV0dXJuIHBhdGhcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbExvY2FsZShwYXRoOiBzdHJpbmcsIGxvY2FsZT86IHN0cmluZykge1xuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgIHJldHVybiBsb2NhbGUgJiZcbiAgICAgIChwYXRoLnN0YXJ0c1dpdGgoJy8nICsgbG9jYWxlICsgJy8nKSB8fCBwYXRoID09PSAnLycgKyBsb2NhbGUpXG4gICAgICA/IHBhdGguc3Vic3RyKGxvY2FsZS5sZW5ndGggKyAxKSB8fCAnLydcbiAgICAgIDogcGF0aFxuICB9XG4gIHJldHVybiBwYXRoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNCYXNlUGF0aChwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIHBhdGggPT09IGJhc2VQYXRoIHx8IHBhdGguc3RhcnRzV2l0aChiYXNlUGF0aCArICcvJylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEJhc2VQYXRoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIHdlIG9ubHkgYWRkIHRoZSBiYXNlcGF0aCBvbiByZWxhdGl2ZSB1cmxzXG4gIHJldHVybiBhZGRQYXRoUHJlZml4KHBhdGgsIGJhc2VQYXRoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsQmFzZVBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHBhdGguc2xpY2UoYmFzZVBhdGgubGVuZ3RoKSB8fCAnLydcbn1cblxuLyoqXG4gKiBEZXRlY3RzIHdoZXRoZXIgYSBnaXZlbiB1cmwgaXMgcm91dGFibGUgYnkgdGhlIE5leHQuanMgcm91dGVyIChicm93c2VyIG9ubHkpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNMb2NhbFVSTCh1cmw6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpZiAodXJsLnN0YXJ0c1dpdGgoJy8nKSkgcmV0dXJuIHRydWVcbiAgdHJ5IHtcbiAgICAvLyBhYnNvbHV0ZSB1cmxzIGNhbiBiZSBsb2NhbCBpZiB0aGV5IGFyZSBvbiB0aGUgc2FtZSBvcmlnaW5cbiAgICBjb25zdCBsb2NhdGlvbk9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKClcbiAgICBjb25zdCByZXNvbHZlZCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbk9yaWdpbilcbiAgICByZXR1cm4gcmVzb2x2ZWQub3JpZ2luID09PSBsb2NhdGlvbk9yaWdpbiAmJiBoYXNCYXNlUGF0aChyZXNvbHZlZC5wYXRobmFtZSlcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbnR5cGUgVXJsID0gVXJsT2JqZWN0IHwgc3RyaW5nXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnBvbGF0ZUFzKFxuICByb3V0ZTogc3RyaW5nLFxuICBhc1BhdGhuYW1lOiBzdHJpbmcsXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuKSB7XG4gIGxldCBpbnRlcnBvbGF0ZWRSb3V0ZSA9ICcnXG5cbiAgY29uc3QgZHluYW1pY1JlZ2V4ID0gZ2V0Um91dGVSZWdleChyb3V0ZSlcbiAgY29uc3QgZHluYW1pY0dyb3VwcyA9IGR5bmFtaWNSZWdleC5ncm91cHNcbiAgY29uc3QgZHluYW1pY01hdGNoZXMgPVxuICAgIC8vIFRyeSB0byBtYXRjaCB0aGUgZHluYW1pYyByb3V0ZSBhZ2FpbnN0IHRoZSBhc1BhdGhcbiAgICAoYXNQYXRobmFtZSAhPT0gcm91dGUgPyBnZXRSb3V0ZU1hdGNoZXIoZHluYW1pY1JlZ2V4KShhc1BhdGhuYW1lKSA6ICcnKSB8fFxuICAgIC8vIEZhbGwgYmFjayB0byByZWFkaW5nIHRoZSB2YWx1ZXMgZnJvbSB0aGUgaHJlZlxuICAgIC8vIFRPRE86IHNob3VsZCB0aGlzIHRha2UgcHJpb3JpdHk7IGFsc28gbmVlZCB0byBjaGFuZ2UgaW4gdGhlIHJvdXRlci5cbiAgICBxdWVyeVxuXG4gIGludGVycG9sYXRlZFJvdXRlID0gcm91dGVcbiAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmtleXMoZHluYW1pY0dyb3VwcylcblxuICBpZiAoXG4gICAgIXBhcmFtcy5ldmVyeSgocGFyYW0pID0+IHtcbiAgICAgIGxldCB2YWx1ZSA9IGR5bmFtaWNNYXRjaGVzW3BhcmFtXSB8fCAnJ1xuICAgICAgY29uc3QgeyByZXBlYXQsIG9wdGlvbmFsIH0gPSBkeW5hbWljR3JvdXBzW3BhcmFtXVxuXG4gICAgICAvLyBzdXBwb3J0IHNpbmdsZS1sZXZlbCBjYXRjaC1hbGxcbiAgICAgIC8vIFRPRE86IG1vcmUgcm9idXN0IGhhbmRsaW5nIGZvciB1c2VyLWVycm9yIChwYXNzaW5nIGAvYClcbiAgICAgIGxldCByZXBsYWNlZCA9IGBbJHtyZXBlYXQgPyAnLi4uJyA6ICcnfSR7cGFyYW19XWBcbiAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICByZXBsYWNlZCA9IGAkeyF2YWx1ZSA/ICcvJyA6ICcnfVske3JlcGxhY2VkfV1gXG4gICAgICB9XG4gICAgICBpZiAocmVwZWF0ICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkgdmFsdWUgPSBbdmFsdWVdXG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIChvcHRpb25hbCB8fCBwYXJhbSBpbiBkeW5hbWljTWF0Y2hlcykgJiZcbiAgICAgICAgLy8gSW50ZXJwb2xhdGUgZ3JvdXAgaW50byBkYXRhIFVSTCBpZiBwcmVzZW50XG4gICAgICAgIChpbnRlcnBvbGF0ZWRSb3V0ZSA9XG4gICAgICAgICAgaW50ZXJwb2xhdGVkUm91dGUhLnJlcGxhY2UoXG4gICAgICAgICAgICByZXBsYWNlZCxcbiAgICAgICAgICAgIHJlcGVhdFxuICAgICAgICAgICAgICA/ICh2YWx1ZSBhcyBzdHJpbmdbXSkubWFwKGVzY2FwZVBhdGhEZWxpbWl0ZXJzKS5qb2luKCcvJylcbiAgICAgICAgICAgICAgOiBlc2NhcGVQYXRoRGVsaW1pdGVycyh2YWx1ZSBhcyBzdHJpbmcpXG4gICAgICAgICAgKSB8fCAnLycpXG4gICAgICApXG4gICAgfSlcbiAgKSB7XG4gICAgaW50ZXJwb2xhdGVkUm91dGUgPSAnJyAvLyBkaWQgbm90IHNhdGlzZnkgYWxsIHJlcXVpcmVtZW50c1xuXG4gICAgLy8gbi5iLiBXZSBpZ25vcmUgdGhpcyBlcnJvciBiZWNhdXNlIHdlIGhhbmRsZSB3YXJuaW5nIGZvciB0aGlzIGNhc2UgaW5cbiAgICAvLyBkZXZlbG9wbWVudCBpbiB0aGUgYDxMaW5rPmAgY29tcG9uZW50IGRpcmVjdGx5LlxuICB9XG4gIHJldHVybiB7XG4gICAgcGFyYW1zLFxuICAgIHJlc3VsdDogaW50ZXJwb2xhdGVkUm91dGUsXG4gIH1cbn1cblxuZnVuY3Rpb24gb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSwgcGFyYW1zOiBzdHJpbmdbXSkge1xuICBjb25zdCBmaWx0ZXJlZFF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSA9IHt9XG5cbiAgT2JqZWN0LmtleXMocXVlcnkpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmICghcGFyYW1zLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIGZpbHRlcmVkUXVlcnlba2V5XSA9IHF1ZXJ5W2tleV1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBmaWx0ZXJlZFF1ZXJ5XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgYSBnaXZlbiBoeXBlcmxpbmsgd2l0aCBhIGNlcnRhaW4gcm91dGVyIHN0YXRlIChiYXNlUGF0aCBub3QgaW5jbHVkZWQpLlxuICogUHJlc2VydmVzIGFic29sdXRlIHVybHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlSHJlZihcbiAgY3VycmVudFBhdGg6IHN0cmluZyxcbiAgaHJlZjogVXJsLFxuICByZXNvbHZlQXM/OiBib29sZWFuXG4pOiBzdHJpbmcge1xuICAvLyB3ZSB1c2UgYSBkdW1teSBiYXNlIHVybCBmb3IgcmVsYXRpdmUgdXJsc1xuICBjb25zdCBiYXNlID0gbmV3IFVSTChjdXJyZW50UGF0aCwgJ2h0dHA6Ly9uJylcbiAgY29uc3QgdXJsQXNTdHJpbmcgPVxuICAgIHR5cGVvZiBocmVmID09PSAnc3RyaW5nJyA/IGhyZWYgOiBmb3JtYXRXaXRoVmFsaWRhdGlvbihocmVmKVxuICAvLyBSZXR1cm4gYmVjYXVzZSBpdCBjYW5ub3QgYmUgcm91dGVkIGJ5IHRoZSBOZXh0LmpzIHJvdXRlclxuICBpZiAoIWlzTG9jYWxVUkwodXJsQXNTdHJpbmcpKSB7XG4gICAgcmV0dXJuIChyZXNvbHZlQXMgPyBbdXJsQXNTdHJpbmddIDogdXJsQXNTdHJpbmcpIGFzIHN0cmluZ1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgZmluYWxVcmwgPSBuZXcgVVJMKHVybEFzU3RyaW5nLCBiYXNlKVxuICAgIGZpbmFsVXJsLnBhdGhuYW1lID0gbm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2goZmluYWxVcmwucGF0aG5hbWUpXG4gICAgbGV0IGludGVycG9sYXRlZEFzID0gJydcblxuICAgIGlmIChcbiAgICAgIGlzRHluYW1pY1JvdXRlKGZpbmFsVXJsLnBhdGhuYW1lKSAmJlxuICAgICAgZmluYWxVcmwuc2VhcmNoUGFyYW1zICYmXG4gICAgICByZXNvbHZlQXNcbiAgICApIHtcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gc2VhcmNoUGFyYW1zVG9VcmxRdWVyeShmaW5hbFVybC5zZWFyY2hQYXJhbXMpXG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0LCBwYXJhbXMgfSA9IGludGVycG9sYXRlQXMoXG4gICAgICAgIGZpbmFsVXJsLnBhdGhuYW1lLFxuICAgICAgICBmaW5hbFVybC5wYXRobmFtZSxcbiAgICAgICAgcXVlcnlcbiAgICAgIClcblxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBpbnRlcnBvbGF0ZWRBcyA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHtcbiAgICAgICAgICBwYXRobmFtZTogcmVzdWx0LFxuICAgICAgICAgIGhhc2g6IGZpbmFsVXJsLmhhc2gsXG4gICAgICAgICAgcXVlcnk6IG9taXRQYXJtc0Zyb21RdWVyeShxdWVyeSwgcGFyYW1zKSxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB0aGUgb3JpZ2luIGRpZG4ndCBjaGFuZ2UsIGl0IG1lYW5zIHdlIHJlY2VpdmVkIGEgcmVsYXRpdmUgaHJlZlxuICAgIGNvbnN0IHJlc29sdmVkSHJlZiA9XG4gICAgICBmaW5hbFVybC5vcmlnaW4gPT09IGJhc2Uub3JpZ2luXG4gICAgICAgID8gZmluYWxVcmwuaHJlZi5zbGljZShmaW5hbFVybC5vcmlnaW4ubGVuZ3RoKVxuICAgICAgICA6IGZpbmFsVXJsLmhyZWZcblxuICAgIHJldHVybiAocmVzb2x2ZUFzXG4gICAgICA/IFtyZXNvbHZlZEhyZWYsIGludGVycG9sYXRlZEFzIHx8IHJlc29sdmVkSHJlZl1cbiAgICAgIDogcmVzb2x2ZWRIcmVmKSBhcyBzdHJpbmdcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiAocmVzb2x2ZUFzID8gW3VybEFzU3RyaW5nXSA6IHVybEFzU3RyaW5nKSBhcyBzdHJpbmdcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVwYXJlVXJsQXMocm91dGVyOiBOZXh0Um91dGVyLCB1cmw6IFVybCwgYXM6IFVybCkge1xuICAvLyBJZiB1cmwgYW5kIGFzIHByb3ZpZGVkIGFzIGFuIG9iamVjdCByZXByZXNlbnRhdGlvbixcbiAgLy8gd2UnbGwgZm9ybWF0IHRoZW0gaW50byB0aGUgc3RyaW5nIHZlcnNpb24gaGVyZS5cbiAgcmV0dXJuIHtcbiAgICB1cmw6IGFkZEJhc2VQYXRoKHJlc29sdmVIcmVmKHJvdXRlci5wYXRobmFtZSwgdXJsKSksXG4gICAgYXM6IGFzID8gYWRkQmFzZVBhdGgocmVzb2x2ZUhyZWYocm91dGVyLnBhdGhuYW1lLCBhcykpIDogYXMsXG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgQmFzZVJvdXRlciA9IHtcbiAgcm91dGU6IHN0cmluZ1xuICBwYXRobmFtZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBhc1BhdGg6IHN0cmluZ1xuICBiYXNlUGF0aDogc3RyaW5nXG4gIGxvY2FsZT86IHN0cmluZ1xuICBsb2NhbGVzPzogc3RyaW5nW11cbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBOZXh0Um91dGVyID0gQmFzZVJvdXRlciAmXG4gIFBpY2s8XG4gICAgUm91dGVyLFxuICAgIHwgJ3B1c2gnXG4gICAgfCAncmVwbGFjZSdcbiAgICB8ICdyZWxvYWQnXG4gICAgfCAnYmFjaydcbiAgICB8ICdwcmVmZXRjaCdcbiAgICB8ICdiZWZvcmVQb3BTdGF0ZSdcbiAgICB8ICdldmVudHMnXG4gICAgfCAnaXNGYWxsYmFjaydcbiAgPlxuXG5leHBvcnQgdHlwZSBQcmVmZXRjaE9wdGlvbnMgPSB7XG4gIHByaW9yaXR5PzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZVxufVxuXG5leHBvcnQgdHlwZSBQcml2YXRlUm91dGVJbmZvID1cbiAgfCAoT21pdDxDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8sICdzdHlsZVNoZWV0cyc+ICYgeyBpbml0aWFsOiB0cnVlIH0pXG4gIHwgQ29tcGxldGVQcml2YXRlUm91dGVJbmZvXG5cbmV4cG9ydCB0eXBlIENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbyA9IHtcbiAgQ29tcG9uZW50OiBDb21wb25lbnRUeXBlXG4gIHN0eWxlU2hlZXRzOiBTdHlsZVNoZWV0VHVwbGVbXVxuICBfX05fU1NHPzogYm9vbGVhblxuICBfX05fU1NQPzogYm9vbGVhblxuICBwcm9wcz86IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgZXJyPzogRXJyb3JcbiAgZXJyb3I/OiBhbnlcbn1cblxuZXhwb3J0IHR5cGUgQXBwUHJvcHMgPSBQaWNrPENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbywgJ0NvbXBvbmVudCcgfCAnZXJyJz4gJiB7XG4gIHJvdXRlcjogUm91dGVyXG59ICYgUmVjb3JkPHN0cmluZywgYW55PlxuZXhwb3J0IHR5cGUgQXBwQ29tcG9uZW50ID0gQ29tcG9uZW50VHlwZTxBcHBQcm9wcz5cblxudHlwZSBTdWJzY3JpcHRpb24gPSAoZGF0YTogUHJpdmF0ZVJvdXRlSW5mbywgQXBwOiBBcHBDb21wb25lbnQpID0+IFByb21pc2U8dm9pZD5cblxudHlwZSBCZWZvcmVQb3BTdGF0ZUNhbGxiYWNrID0gKHN0YXRlOiBOZXh0SGlzdG9yeVN0YXRlKSA9PiBib29sZWFuXG5cbnR5cGUgQ29tcG9uZW50TG9hZENhbmNlbCA9ICgoKSA9PiB2b2lkKSB8IG51bGxcblxudHlwZSBIaXN0b3J5TWV0aG9kID0gJ3JlcGxhY2VTdGF0ZScgfCAncHVzaFN0YXRlJ1xuXG5jb25zdCBtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiA9XG4gIHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04gJiZcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgJ3Njcm9sbFJlc3RvcmF0aW9uJyBpbiB3aW5kb3cuaGlzdG9yeVxuXG5jb25zdCBTU0dfREFUQV9OT1RfRk9VTkRfRVJST1IgPSAnU1NHIERhdGEgTk9UX0ZPVU5EJ1xuXG5mdW5jdGlvbiBmZXRjaFJldHJ5KHVybDogc3RyaW5nLCBhdHRlbXB0czogbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgcmV0dXJuIGZldGNoKHVybCwge1xuICAgIC8vIENvb2tpZXMgYXJlIHJlcXVpcmVkIHRvIGJlIHByZXNlbnQgZm9yIE5leHQuanMnIFNTRyBcIlByZXZpZXcgTW9kZVwiLlxuICAgIC8vIENvb2tpZXMgbWF5IGFsc28gYmUgcmVxdWlyZWQgZm9yIGBnZXRTZXJ2ZXJTaWRlUHJvcHNgLlxuICAgIC8vXG4gICAgLy8gPiBgZmV0Y2hgIHdvbuKAmXQgc2VuZCBjb29raWVzLCB1bmxlc3MgeW91IHNldCB0aGUgY3JlZGVudGlhbHMgaW5pdFxuICAgIC8vID4gb3B0aW9uLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GZXRjaF9BUEkvVXNpbmdfRmV0Y2hcbiAgICAvL1xuICAgIC8vID4gRm9yIG1heGltdW0gYnJvd3NlciBjb21wYXRpYmlsaXR5IHdoZW4gaXQgY29tZXMgdG8gc2VuZGluZyAmXG4gICAgLy8gPiByZWNlaXZpbmcgY29va2llcywgYWx3YXlzIHN1cHBseSB0aGUgYGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nYFxuICAgIC8vID4gb3B0aW9uIGluc3RlYWQgb2YgcmVseWluZyBvbiB0aGUgZGVmYXVsdC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoI2NhdmVhdHNcbiAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgfSkudGhlbigocmVzKSA9PiB7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGlmIChhdHRlbXB0cyA+IDEgJiYgcmVzLnN0YXR1cyA+PSA1MDApIHtcbiAgICAgICAgcmV0dXJuIGZldGNoUmV0cnkodXJsLCBhdHRlbXB0cyAtIDEpXG4gICAgICB9XG4gICAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIC8vIFRPRE86IGhhbmRsZSByZWxvYWRpbmcgaW4gZGV2ZWxvcG1lbnQgZnJvbSBmYWxsYmFjayByZXR1cm5pbmcgMjAwXG4gICAgICAgIC8vIHRvIG9uLWRlbWFuZC1lbnRyeS1oYW5kbGVyIGNhdXNpbmcgaXQgdG8gcmVsb2FkIHBlcmlvZGljYWxseVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoU1NHX0RBVEFfTk9UX0ZPVU5EX0VSUk9SKVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzdGF0aWMgcHJvcHNgKVxuICAgIH1cbiAgICByZXR1cm4gcmVzLmpzb24oKVxuICB9KVxufVxuXG5mdW5jdGlvbiBmZXRjaE5leHREYXRhKGRhdGFIcmVmOiBzdHJpbmcsIGlzU2VydmVyUmVuZGVyOiBib29sZWFuKSB7XG4gIHJldHVybiBmZXRjaFJldHJ5KGRhdGFIcmVmLCBpc1NlcnZlclJlbmRlciA/IDMgOiAxKS5jYXRjaCgoZXJyOiBFcnJvcikgPT4ge1xuICAgIC8vIFdlIHNob3VsZCBvbmx5IHRyaWdnZXIgYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uIGlmIHRoaXMgd2FzIGNhdXNlZFxuICAgIC8vIG9uIGEgY2xpZW50LXNpZGUgdHJhbnNpdGlvbi4gT3RoZXJ3aXNlLCB3ZSdkIGdldCBpbnRvIGFuIGluZmluaXRlXG4gICAgLy8gbG9vcC5cblxuICAgIGlmICghaXNTZXJ2ZXJSZW5kZXIpIHtcbiAgICAgIG1hcmtBc3NldEVycm9yKGVycilcbiAgICB9XG4gICAgdGhyb3cgZXJyXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvdXRlciBpbXBsZW1lbnRzIEJhc2VSb3V0ZXIge1xuICByb3V0ZTogc3RyaW5nXG4gIHBhdGhuYW1lOiBzdHJpbmdcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIGFzUGF0aDogc3RyaW5nXG4gIGJhc2VQYXRoOiBzdHJpbmdcblxuICAvKipcbiAgICogTWFwIG9mIGFsbCBjb21wb25lbnRzIGxvYWRlZCBpbiBgUm91dGVyYFxuICAgKi9cbiAgY29tcG9uZW50czogeyBbcGF0aG5hbWU6IHN0cmluZ106IFByaXZhdGVSb3V0ZUluZm8gfVxuICAvLyBTdGF0aWMgRGF0YSBDYWNoZVxuICBzZGM6IHsgW2FzUGF0aDogc3RyaW5nXTogb2JqZWN0IH0gPSB7fVxuICBzdWI6IFN1YnNjcmlwdGlvblxuICBjbGM6IENvbXBvbmVudExvYWRDYW5jZWxcbiAgcGFnZUxvYWRlcjogYW55XG4gIF9icHM6IEJlZm9yZVBvcFN0YXRlQ2FsbGJhY2sgfCB1bmRlZmluZWRcbiAgZXZlbnRzOiBNaXR0RW1pdHRlclxuICBfd3JhcEFwcDogKEFwcDogQXBwQ29tcG9uZW50KSA9PiBhbnlcbiAgaXNTc3I6IGJvb2xlYW5cbiAgaXNGYWxsYmFjazogYm9vbGVhblxuICBfaW5GbGlnaHRSb3V0ZT86IHN0cmluZ1xuICBfc2hhbGxvdz86IGJvb2xlYW5cbiAgbG9jYWxlPzogc3RyaW5nXG4gIGxvY2FsZXM/OiBzdHJpbmdbXVxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG5cbiAgc3RhdGljIGV2ZW50czogTWl0dEVtaXR0ZXIgPSBtaXR0KClcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSxcbiAgICBhczogc3RyaW5nLFxuICAgIHtcbiAgICAgIGluaXRpYWxQcm9wcyxcbiAgICAgIHBhZ2VMb2FkZXIsXG4gICAgICBBcHAsXG4gICAgICB3cmFwQXBwLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgZXJyLFxuICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgaXNGYWxsYmFjayxcbiAgICAgIGxvY2FsZSxcbiAgICAgIGxvY2FsZXMsXG4gICAgICBkZWZhdWx0TG9jYWxlLFxuICAgIH06IHtcbiAgICAgIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uXG4gICAgICBpbml0aWFsUHJvcHM6IGFueVxuICAgICAgcGFnZUxvYWRlcjogYW55XG4gICAgICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgICAgIEFwcDogQXBwQ29tcG9uZW50XG4gICAgICB3cmFwQXBwOiAoQXBwOiBBcHBDb21wb25lbnQpID0+IGFueVxuICAgICAgZXJyPzogRXJyb3JcbiAgICAgIGlzRmFsbGJhY2s6IGJvb2xlYW5cbiAgICAgIGxvY2FsZT86IHN0cmluZ1xuICAgICAgbG9jYWxlcz86IHN0cmluZ1tdXG4gICAgICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG4gICAgfVxuICApIHtcbiAgICAvLyByZXByZXNlbnRzIHRoZSBjdXJyZW50IGNvbXBvbmVudCBrZXlcbiAgICB0aGlzLnJvdXRlID0gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aG5hbWUpXG5cbiAgICAvLyBzZXQgdXAgdGhlIGNvbXBvbmVudCBjYWNoZSAoYnkgcm91dGUga2V5cylcbiAgICB0aGlzLmNvbXBvbmVudHMgPSB7fVxuICAgIC8vIFdlIHNob3VsZCBub3Qga2VlcCB0aGUgY2FjaGUsIGlmIHRoZXJlJ3MgYW4gZXJyb3JcbiAgICAvLyBPdGhlcndpc2UsIHRoaXMgY2F1c2UgaXNzdWVzIHdoZW4gd2hlbiBnb2luZyBiYWNrIGFuZFxuICAgIC8vIGNvbWUgYWdhaW4gdG8gdGhlIGVycm9yZWQgcGFnZS5cbiAgICBpZiAocGF0aG5hbWUgIT09ICcvX2Vycm9yJykge1xuICAgICAgdGhpcy5jb21wb25lbnRzW3RoaXMucm91dGVdID0ge1xuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgIHByb3BzOiBpbml0aWFsUHJvcHMsXG4gICAgICAgIGVycixcbiAgICAgICAgX19OX1NTRzogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NHLFxuICAgICAgICBfX05fU1NQOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU1AsXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jb21wb25lbnRzWycvX2FwcCddID0ge1xuICAgICAgQ29tcG9uZW50OiBBcHAgYXMgQ29tcG9uZW50VHlwZSxcbiAgICAgIHN0eWxlU2hlZXRzOiBbXG4gICAgICAgIC8qIC9fYXBwIGRvZXMgbm90IG5lZWQgaXRzIHN0eWxlc2hlZXRzIG1hbmFnZWQgKi9cbiAgICAgIF0sXG4gICAgfVxuXG4gICAgLy8gQmFja3dhcmRzIGNvbXBhdCBmb3IgUm91dGVyLnJvdXRlci5ldmVudHNcbiAgICAvLyBUT0RPOiBTaG91bGQgYmUgcmVtb3ZlIHRoZSBmb2xsb3dpbmcgbWFqb3IgdmVyc2lvbiBhcyBpdCB3YXMgbmV2ZXIgZG9jdW1lbnRlZFxuICAgIHRoaXMuZXZlbnRzID0gUm91dGVyLmV2ZW50c1xuXG4gICAgdGhpcy5wYWdlTG9hZGVyID0gcGFnZUxvYWRlclxuICAgIHRoaXMucGF0aG5hbWUgPSBwYXRobmFtZVxuICAgIHRoaXMucXVlcnkgPSBxdWVyeVxuICAgIC8vIGlmIGF1dG8gcHJlcmVuZGVyZWQgYW5kIGR5bmFtaWMgcm91dGUgd2FpdCB0byB1cGRhdGUgYXNQYXRoXG4gICAgLy8gdW50aWwgYWZ0ZXIgbW91bnQgdG8gcHJldmVudCBoeWRyYXRpb24gbWlzbWF0Y2hcbiAgICB0aGlzLmFzUGF0aCA9XG4gICAgICAvLyBAdHMtaWdub3JlIHRoaXMgaXMgdGVtcG9yYXJpbHkgZ2xvYmFsIChhdHRhY2hlZCB0byB3aW5kb3cpXG4gICAgICBpc0R5bmFtaWNSb3V0ZShwYXRobmFtZSkgJiYgX19ORVhUX0RBVEFfXy5hdXRvRXhwb3J0ID8gcGF0aG5hbWUgOiBhc1xuICAgIHRoaXMuYmFzZVBhdGggPSBiYXNlUGF0aFxuICAgIHRoaXMuc3ViID0gc3Vic2NyaXB0aW9uXG4gICAgdGhpcy5jbGMgPSBudWxsXG4gICAgdGhpcy5fd3JhcEFwcCA9IHdyYXBBcHBcbiAgICAvLyBtYWtlIHN1cmUgdG8gaWdub3JlIGV4dHJhIHBvcFN0YXRlIGluIHNhZmFyaSBvbiBuYXZpZ2F0aW5nXG4gICAgLy8gYmFjayBmcm9tIGV4dGVybmFsIHNpdGVcbiAgICB0aGlzLmlzU3NyID0gdHJ1ZVxuXG4gICAgdGhpcy5pc0ZhbGxiYWNrID0gaXNGYWxsYmFja1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgIHRoaXMubG9jYWxlID0gbG9jYWxlXG4gICAgICB0aGlzLmxvY2FsZXMgPSBsb2NhbGVzXG4gICAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSBkZWZhdWx0TG9jYWxlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgXCJhc1wiIGRvZXNuJ3Qgc3RhcnQgd2l0aCBkb3VibGUgc2xhc2hlcyBvciBlbHNlIGl0IGNhblxuICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgYXMgaXQncyBjb25zaWRlcmVkIGludmFsaWRcbiAgICAgIGlmIChhcy5zdWJzdHIoMCwgMikgIT09ICcvLycpIHtcbiAgICAgICAgLy8gaW4gb3JkZXIgZm9yIGBlLnN0YXRlYCB0byB3b3JrIG9uIHRoZSBgb25wb3BzdGF0ZWAgZXZlbnRcbiAgICAgICAgLy8gd2UgaGF2ZSB0byByZWdpc3RlciB0aGUgaW5pdGlhbCByb3V0ZSB1cG9uIGluaXRpYWxpemF0aW9uXG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgICAgJ3JlcGxhY2VTdGF0ZScsXG4gICAgICAgICAgZm9ybWF0V2l0aFZhbGlkYXRpb24oeyBwYXRobmFtZTogYWRkQmFzZVBhdGgocGF0aG5hbWUpLCBxdWVyeSB9KSxcbiAgICAgICAgICBnZXRVUkwoKSxcbiAgICAgICAgICB7IGxvY2FsZSB9XG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5vblBvcFN0YXRlKVxuXG4gICAgICAvLyBlbmFibGUgY3VzdG9tIHNjcm9sbCByZXN0b3JhdGlvbiBoYW5kbGluZyB3aGVuIGF2YWlsYWJsZVxuICAgICAgLy8gb3RoZXJ3aXNlIGZhbGxiYWNrIHRvIGJyb3dzZXIncyBkZWZhdWx0IGhhbmRsaW5nXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9ICdtYW51YWwnXG5cbiAgICAgICAgICBsZXQgc2Nyb2xsRGVib3VuY2VUaW1lb3V0OiB1bmRlZmluZWQgfCBOb2RlSlMuVGltZW91dFxuXG4gICAgICAgICAgY29uc3QgZGVib3VuY2VkU2Nyb2xsU2F2ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChzY3JvbGxEZWJvdW5jZVRpbWVvdXQpIGNsZWFyVGltZW91dChzY3JvbGxEZWJvdW5jZVRpbWVvdXQpXG5cbiAgICAgICAgICAgIHNjcm9sbERlYm91bmNlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB7IHVybCwgYXM6IGN1ckFzLCBvcHRpb25zIH0gPSBoaXN0b3J5LnN0YXRlXG4gICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgICAgICAgICAgJ3JlcGxhY2VTdGF0ZScsXG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGN1ckFzLFxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgIF9OX1g6IHdpbmRvdy5zY3JvbGxYLFxuICAgICAgICAgICAgICAgICAgX05fWTogd2luZG93LnNjcm9sbFksXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSwgMTApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGRlYm91bmNlZFNjcm9sbFNhdmUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvblBvcFN0YXRlID0gKGU6IFBvcFN0YXRlRXZlbnQpOiB2b2lkID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IGUuc3RhdGUgYXMgSGlzdG9yeVN0YXRlXG5cbiAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAvLyBXZSBnZXQgc3RhdGUgYXMgdW5kZWZpbmVkIGZvciB0d28gcmVhc29ucy5cbiAgICAgIC8vICAxLiBXaXRoIG9sZGVyIHNhZmFyaSAoPCA4KSBhbmQgb2xkZXIgY2hyb21lICg8IDM0KVxuICAgICAgLy8gIDIuIFdoZW4gdGhlIFVSTCBjaGFuZ2VkIHdpdGggI1xuICAgICAgLy9cbiAgICAgIC8vIEluIHRoZSBib3RoIGNhc2VzLCB3ZSBkb24ndCBuZWVkIHRvIHByb2NlZWQgYW5kIGNoYW5nZSB0aGUgcm91dGUuXG4gICAgICAvLyAoYXMgaXQncyBhbHJlYWR5IGNoYW5nZWQpXG4gICAgICAvLyBCdXQgd2UgY2FuIHNpbXBseSByZXBsYWNlIHRoZSBzdGF0ZSB3aXRoIHRoZSBuZXcgY2hhbmdlcy5cbiAgICAgIC8vIEFjdHVhbGx5LCBmb3IgKDEpIHdlIGRvbid0IG5lZWQgdG8gbm90aGluZy4gQnV0IGl0J3MgaGFyZCB0byBkZXRlY3QgdGhhdCBldmVudC5cbiAgICAgIC8vIFNvLCBkb2luZyB0aGUgZm9sbG93aW5nIGZvciAoMSkgZG9lcyBubyBoYXJtLlxuICAgICAgY29uc3QgeyBwYXRobmFtZSwgcXVlcnkgfSA9IHRoaXNcbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgICdyZXBsYWNlU3RhdGUnLFxuICAgICAgICBmb3JtYXRXaXRoVmFsaWRhdGlvbih7IHBhdGhuYW1lOiBhZGRCYXNlUGF0aChwYXRobmFtZSksIHF1ZXJ5IH0pLFxuICAgICAgICBnZXRVUkwoKVxuICAgICAgKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFzdGF0ZS5fX04pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHsgdXJsLCBhcywgb3B0aW9ucyB9ID0gc3RhdGVcblxuICAgIGNvbnN0IHsgcGF0aG5hbWUgfSA9IHBhcnNlUmVsYXRpdmVVcmwodXJsKVxuXG4gICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IHJlLXJlbmRlciBvbiBpbml0aWFsIGxvYWQsXG4gICAgLy8gY2FuIGJlIGNhdXNlZCBieSBuYXZpZ2F0aW5nIGJhY2sgZnJvbSBhbiBleHRlcm5hbCBzaXRlXG4gICAgaWYgKHRoaXMuaXNTc3IgJiYgYXMgPT09IHRoaXMuYXNQYXRoICYmIHBhdGhuYW1lID09PSB0aGlzLnBhdGhuYW1lKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgZG93bnN0cmVhbSBhcHBsaWNhdGlvbiByZXR1cm5zIGZhbHN5LCByZXR1cm4uXG4gICAgLy8gVGhleSB3aWxsIHRoZW4gYmUgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIHRoZSBldmVudC5cbiAgICBpZiAodGhpcy5fYnBzICYmICF0aGlzLl9icHMoc3RhdGUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmNoYW5nZShcbiAgICAgICdyZXBsYWNlU3RhdGUnLFxuICAgICAgdXJsLFxuICAgICAgYXMsXG4gICAgICBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIHNoYWxsb3c6IG9wdGlvbnMuc2hhbGxvdyAmJiB0aGlzLl9zaGFsbG93LFxuICAgICAgICBsb2NhbGU6IG9wdGlvbnMubG9jYWxlIHx8IHRoaXMuZGVmYXVsdExvY2FsZSxcbiAgICAgIH0pXG4gICAgKVxuICB9XG5cbiAgcmVsb2FkKCk6IHZvaWQge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdvIGJhY2sgaW4gaGlzdG9yeVxuICAgKi9cbiAgYmFjaygpIHtcbiAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKClcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIGBwdXNoU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi9cbiAgcHVzaCh1cmw6IFVybCwgYXM6IFVybCA9IHVybCwgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMgPSB7fSkge1xuICAgIDsoeyB1cmwsIGFzIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpXG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdwdXNoU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHJlcGxhY2VTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqL1xuICByZXBsYWNlKHVybDogVXJsLCBhczogVXJsID0gdXJsLCBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHt9KSB7XG4gICAgOyh7IHVybCwgYXMgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSlcbiAgICByZXR1cm4gdGhpcy5jaGFuZ2UoJ3JlcGxhY2VTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpXG4gIH1cblxuICBhc3luYyBjaGFuZ2UoXG4gICAgbWV0aG9kOiBIaXN0b3J5TWV0aG9kLFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzOiBzdHJpbmcsXG4gICAgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnNcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCFpc0xvY2FsVVJMKHVybCkpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgbGV0IGxvY2FsZUNoYW5nZSA9IG9wdGlvbnMubG9jYWxlICE9PSB0aGlzLmxvY2FsZVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgIHRoaXMubG9jYWxlID1cbiAgICAgICAgb3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlXG4gICAgICAgICAgPyB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgICA6IG9wdGlvbnMubG9jYWxlIHx8IHRoaXMubG9jYWxlXG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9wdGlvbnMubG9jYWxlID0gdGhpcy5sb2NhbGVcbiAgICAgIH1cblxuICAgICAgY29uc3Qge1xuICAgICAgICBub3JtYWxpemVMb2NhbGVQYXRoLFxuICAgICAgfSA9IHJlcXVpcmUoJy4uL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGgnKVxuXG4gICAgICBjb25zdCBwYXJzZWRBcyA9IHBhcnNlUmVsYXRpdmVVcmwoaGFzQmFzZVBhdGgoYXMpID8gZGVsQmFzZVBhdGgoYXMpIDogYXMpXG4gICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gbm9ybWFsaXplTG9jYWxlUGF0aChcbiAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUsXG4gICAgICAgIHRoaXMubG9jYWxlc1xuICAgICAgKVxuICAgICAgaWYgKGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUpIHtcbiAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlXG4gICAgICAgIHVybCA9IGFkZEJhc2VQYXRoKGxvY2FsZVBhdGhSZXN1bHQucGF0aG5hbWUpXG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZSBsb2NhbGUgaXNuJ3QgY29uZmlndXJlZCBoYXJkIG5hdmlnYXRlIHRvIHNob3cgNDA0IHBhZ2VcbiAgICAgIGlmICghdGhpcy5sb2NhbGVzPy5pbmNsdWRlcyh0aGlzLmxvY2FsZSEpKSB7XG4gICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gYWRkTG9jYWxlKHBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZSlcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWRBcylcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHt9KVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghKG9wdGlvbnMgYXMgYW55KS5faCkge1xuICAgICAgdGhpcy5pc1NzciA9IGZhbHNlXG4gICAgfVxuICAgIC8vIG1hcmtpbmcgcm91dGUgY2hhbmdlcyBhcyBhIG5hdmlnYXRpb24gc3RhcnQgZW50cnlcbiAgICBpZiAoU1QpIHtcbiAgICAgIHBlcmZvcm1hbmNlLm1hcmsoJ3JvdXRlQ2hhbmdlJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW5GbGlnaHRSb3V0ZSkge1xuICAgICAgdGhpcy5hYm9ydENvbXBvbmVudExvYWQodGhpcy5faW5GbGlnaHRSb3V0ZSlcbiAgICB9XG5cbiAgICBhcyA9IGFkZEJhc2VQYXRoKFxuICAgICAgYWRkTG9jYWxlKFxuICAgICAgICBoYXNCYXNlUGF0aChhcykgPyBkZWxCYXNlUGF0aChhcykgOiBhcyxcbiAgICAgICAgb3B0aW9ucy5sb2NhbGUsXG4gICAgICAgIHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgKVxuICAgIClcbiAgICBjb25zdCBjbGVhbmVkQXMgPSBkZWxMb2NhbGUoXG4gICAgICBoYXNCYXNlUGF0aChhcykgPyBkZWxCYXNlUGF0aChhcykgOiBhcyxcbiAgICAgIHRoaXMubG9jYWxlXG4gICAgKVxuICAgIHRoaXMuX2luRmxpZ2h0Um91dGUgPSBhc1xuXG4gICAgLy8gSWYgdGhlIHVybCBjaGFuZ2UgaXMgb25seSByZWxhdGVkIHRvIGEgaGFzaCBjaGFuZ2VcbiAgICAvLyBXZSBzaG91bGQgbm90IHByb2NlZWQuIFdlIHNob3VsZCBvbmx5IGNoYW5nZSB0aGUgc3RhdGUuXG5cbiAgICAvLyBXQVJOSU5HOiBgX2hgIGlzIGFuIGludGVybmFsIG9wdGlvbiBmb3IgaGFuZGluZyBOZXh0LmpzIGNsaWVudC1zaWRlXG4gICAgLy8gaHlkcmF0aW9uLiBZb3VyIGFwcCBzaG91bGQgX25ldmVyXyB1c2UgdGhpcyBwcm9wZXJ0eS4gSXQgbWF5IGNoYW5nZSBhdFxuICAgIC8vIGFueSB0aW1lIHdpdGhvdXQgbm90aWNlLlxuICAgIGlmICghKG9wdGlvbnMgYXMgYW55KS5faCAmJiB0aGlzLm9ubHlBSGFzaENoYW5nZShjbGVhbmVkQXMpKSB7XG4gICAgICB0aGlzLmFzUGF0aCA9IGNsZWFuZWRBc1xuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdoYXNoQ2hhbmdlU3RhcnQnLCBhcylcbiAgICAgIC8vIFRPRE86IGRvIHdlIG5lZWQgdGhlIHJlc29sdmVkIGhyZWYgd2hlbiBvbmx5IGEgaGFzaCBjaGFuZ2U/XG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucylcbiAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKGNsZWFuZWRBcylcbiAgICAgIHRoaXMubm90aWZ5KHRoaXMuY29tcG9uZW50c1t0aGlzLnJvdXRlXSlcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZUNvbXBsZXRlJywgYXMpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGxldCBwYXJzZWQgPSBwYXJzZVJlbGF0aXZlVXJsKHVybClcbiAgICBsZXQgeyBwYXRobmFtZSwgcXVlcnkgfSA9IHBhcnNlZFxuXG4gICAgLy8gVGhlIGJ1aWxkIG1hbmlmZXN0IG5lZWRzIHRvIGJlIGxvYWRlZCBiZWZvcmUgYXV0by1zdGF0aWMgZHluYW1pYyBwYWdlc1xuICAgIC8vIGdldCB0aGVpciBxdWVyeSBwYXJhbWV0ZXJzIHRvIGFsbG93IGVuc3VyaW5nIHRoZXkgY2FuIGJlIHBhcnNlZCBwcm9wZXJseVxuICAgIC8vIHdoZW4gcmV3cml0dGVuIHRvXG4gICAgbGV0IHBhZ2VzOiBhbnksIHJld3JpdGVzOiBhbnlcbiAgICB0cnkge1xuICAgICAgcGFnZXMgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKVxuICAgICAgOyh7IF9fcmV3cml0ZXM6IHJld3JpdGVzIH0gPSBhd2FpdCBnZXRDbGllbnRCdWlsZE1hbmlmZXN0KCkpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBJZiB3ZSBmYWlsIHRvIHJlc29sdmUgdGhlIHBhZ2UgbGlzdCBvciBjbGllbnQtYnVpbGQgbWFuaWZlc3QsIHdlIG11c3RcbiAgICAgIC8vIGRvIGEgc2VydmVyLXNpZGUgdHJhbnNpdGlvbjpcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYXNcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHBhcnNlZCA9IHRoaXMuX3Jlc29sdmVIcmVmKHBhcnNlZCwgcGFnZXMpIGFzIHR5cGVvZiBwYXJzZWRcblxuICAgIGlmIChwYXJzZWQucGF0aG5hbWUgIT09IHBhdGhuYW1lKSB7XG4gICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZVxuICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgIH1cblxuICAgIC8vIHVybCBhbmQgYXMgc2hvdWxkIGFsd2F5cyBiZSBwcmVmaXhlZCB3aXRoIGJhc2VQYXRoIGJ5IHRoaXNcbiAgICAvLyBwb2ludCBieSBlaXRoZXIgbmV4dC9saW5rIG9yIHJvdXRlci5wdXNoL3JlcGxhY2Ugc28gc3RyaXAgdGhlXG4gICAgLy8gYmFzZVBhdGggZnJvbSB0aGUgcGF0aG5hbWUgdG8gbWF0Y2ggdGhlIHBhZ2VzIGRpciAxLXRvLTFcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgICA/IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKGRlbEJhc2VQYXRoKHBhdGhuYW1lKSlcbiAgICAgIDogcGF0aG5hbWVcblxuICAgIC8vIElmIGFza2VkIHRvIGNoYW5nZSB0aGUgY3VycmVudCBVUkwgd2Ugc2hvdWxkIHJlbG9hZCB0aGUgY3VycmVudCBwYWdlXG4gICAgLy8gKG5vdCBsb2NhdGlvbi5yZWxvYWQoKSBidXQgcmVsb2FkIGdldEluaXRpYWxQcm9wcyBhbmQgb3RoZXIgTmV4dC5qcyBzdHVmZnMpXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIHNldCB0aGUgbWV0aG9kID0gcmVwbGFjZVN0YXRlIGFsd2F5c1xuICAgIC8vIGFzIHRoaXMgc2hvdWxkIG5vdCBnbyBpbnRvIHRoZSBoaXN0b3J5IChUaGF0J3MgaG93IGJyb3dzZXJzIHdvcmspXG4gICAgLy8gV2Ugc2hvdWxkIGNvbXBhcmUgdGhlIG5ldyBhc1BhdGggdG8gdGhlIGN1cnJlbnQgYXNQYXRoLCBub3QgdGhlIHVybFxuICAgIGlmICghdGhpcy51cmxJc05ldyhjbGVhbmVkQXMpICYmICFsb2NhbGVDaGFuZ2UpIHtcbiAgICAgIG1ldGhvZCA9ICdyZXBsYWNlU3RhdGUnXG4gICAgfVxuXG4gICAgbGV0IHJvdXRlID0gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aG5hbWUpXG4gICAgY29uc3QgeyBzaGFsbG93ID0gZmFsc2UgfSA9IG9wdGlvbnNcblxuICAgIC8vIHdlIG5lZWQgdG8gcmVzb2x2ZSB0aGUgYXMgdmFsdWUgdXNpbmcgcmV3cml0ZXMgZm9yIGR5bmFtaWMgU1NHXG4gICAgLy8gcGFnZXMgdG8gYWxsb3cgYnVpbGRpbmcgdGhlIGRhdGEgVVJMIGNvcnJlY3RseVxuICAgIGxldCByZXNvbHZlZEFzID0gYXNcblxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTKSB7XG4gICAgICByZXNvbHZlZEFzID0gcmVzb2x2ZVJld3JpdGVzKFxuICAgICAgICBwYXJzZVJlbGF0aXZlVXJsKGFzKS5wYXRobmFtZSxcbiAgICAgICAgcGFnZXMsXG4gICAgICAgIGJhc2VQYXRoLFxuICAgICAgICByZXdyaXRlcyxcbiAgICAgICAgcXVlcnksXG4gICAgICAgIChwOiBzdHJpbmcpID0+IHRoaXMuX3Jlc29sdmVIcmVmKHsgcGF0aG5hbWU6IHAgfSwgcGFnZXMpLnBhdGhuYW1lIVxuICAgICAgKVxuXG4gICAgICBpZiAocmVzb2x2ZWRBcyAhPT0gYXMpIHtcbiAgICAgICAgY29uc3QgcG90ZW50aWFsSHJlZiA9IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKFxuICAgICAgICAgIHRoaXMuX3Jlc29sdmVIcmVmKFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkLCB7IHBhdGhuYW1lOiByZXNvbHZlZEFzIH0pLFxuICAgICAgICAgICAgcGFnZXMsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICkucGF0aG5hbWUhXG4gICAgICAgIClcblxuICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXG4gICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgIGlmIChwYWdlcy5pbmNsdWRlcyhwb3RlbnRpYWxIcmVmKSkge1xuICAgICAgICAgIHJvdXRlID0gcG90ZW50aWFsSHJlZlxuICAgICAgICAgIHBhdGhuYW1lID0gcG90ZW50aWFsSHJlZlxuICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlc29sdmVkQXMgPSBkZWxMb2NhbGUoZGVsQmFzZVBhdGgocmVzb2x2ZWRBcyksIHRoaXMubG9jYWxlKVxuXG4gICAgaWYgKGlzRHluYW1pY1JvdXRlKHJvdXRlKSkge1xuICAgICAgY29uc3QgcGFyc2VkQXMgPSBwYXJzZVJlbGF0aXZlVXJsKHJlc29sdmVkQXMpXG4gICAgICBjb25zdCBhc1BhdGhuYW1lID0gcGFyc2VkQXMucGF0aG5hbWVcblxuICAgICAgY29uc3Qgcm91dGVSZWdleCA9IGdldFJvdXRlUmVnZXgocm91dGUpXG4gICAgICBjb25zdCByb3V0ZU1hdGNoID0gZ2V0Um91dGVNYXRjaGVyKHJvdXRlUmVnZXgpKGFzUGF0aG5hbWUpXG4gICAgICBjb25zdCBzaG91bGRJbnRlcnBvbGF0ZSA9IHJvdXRlID09PSBhc1BhdGhuYW1lXG4gICAgICBjb25zdCBpbnRlcnBvbGF0ZWRBcyA9IHNob3VsZEludGVycG9sYXRlXG4gICAgICAgID8gaW50ZXJwb2xhdGVBcyhyb3V0ZSwgYXNQYXRobmFtZSwgcXVlcnkpXG4gICAgICAgIDogKHt9IGFzIHsgcmVzdWx0OiB1bmRlZmluZWQ7IHBhcmFtczogdW5kZWZpbmVkIH0pXG5cbiAgICAgIGlmICghcm91dGVNYXRjaCB8fCAoc2hvdWxkSW50ZXJwb2xhdGUgJiYgIWludGVycG9sYXRlZEFzLnJlc3VsdCkpIHtcbiAgICAgICAgY29uc3QgbWlzc2luZ1BhcmFtcyA9IE9iamVjdC5rZXlzKHJvdXRlUmVnZXguZ3JvdXBzKS5maWx0ZXIoXG4gICAgICAgICAgKHBhcmFtKSA9PiAhcXVlcnlbcGFyYW1dXG4gICAgICAgIClcblxuICAgICAgICBpZiAobWlzc2luZ1BhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgYCR7XG4gICAgICAgICAgICAgICAgc2hvdWxkSW50ZXJwb2xhdGVcbiAgICAgICAgICAgICAgICAgID8gYEludGVycG9sYXRpbmcgaHJlZmBcbiAgICAgICAgICAgICAgICAgIDogYE1pc21hdGNoaW5nIFxcYGFzXFxgIGFuZCBcXGBocmVmXFxgYFxuICAgICAgICAgICAgICB9IGZhaWxlZCB0byBtYW51YWxseSBwcm92aWRlIGAgK1xuICAgICAgICAgICAgICAgIGB0aGUgcGFyYW1zOiAke21pc3NpbmdQYXJhbXMuam9pbihcbiAgICAgICAgICAgICAgICAgICcsICdcbiAgICAgICAgICAgICAgICApfSBpbiB0aGUgXFxgaHJlZlxcYCdzIFxcYHF1ZXJ5XFxgYFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIChzaG91bGRJbnRlcnBvbGF0ZVxuICAgICAgICAgICAgICA/IGBUaGUgcHJvdmlkZWQgXFxgaHJlZlxcYCAoJHt1cmx9KSB2YWx1ZSBpcyBtaXNzaW5nIHF1ZXJ5IHZhbHVlcyAoJHttaXNzaW5nUGFyYW1zLmpvaW4oXG4gICAgICAgICAgICAgICAgICAnLCAnXG4gICAgICAgICAgICAgICAgKX0pIHRvIGJlIGludGVycG9sYXRlZCBwcm9wZXJseS4gYFxuICAgICAgICAgICAgICA6IGBUaGUgcHJvdmlkZWQgXFxgYXNcXGAgdmFsdWUgKCR7YXNQYXRobmFtZX0pIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoZSBcXGBocmVmXFxgIHZhbHVlICgke3JvdXRlfSkuIGApICtcbiAgICAgICAgICAgICAgYFJlYWQgbW9yZTogaHR0cHM6Ly9lcnIuc2gvdmVyY2VsL25leHQuanMvJHtcbiAgICAgICAgICAgICAgICBzaG91bGRJbnRlcnBvbGF0ZVxuICAgICAgICAgICAgICAgICAgPyAnaHJlZi1pbnRlcnBvbGF0aW9uLWZhaWxlZCdcbiAgICAgICAgICAgICAgICAgIDogJ2luY29tcGF0aWJsZS1ocmVmLWFzJ1xuICAgICAgICAgICAgICB9YFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzaG91bGRJbnRlcnBvbGF0ZSkge1xuICAgICAgICBhcyA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKFxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHBhcnNlZEFzLCB7XG4gICAgICAgICAgICBwYXRobmFtZTogaW50ZXJwb2xhdGVkQXMucmVzdWx0LFxuICAgICAgICAgICAgcXVlcnk6IG9taXRQYXJtc0Zyb21RdWVyeShxdWVyeSwgaW50ZXJwb2xhdGVkQXMucGFyYW1zISksXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWVyZ2UgcGFyYW1zIGludG8gYHF1ZXJ5YCwgb3ZlcndyaXRpbmcgYW55IHNwZWNpZmllZCBpbiBzZWFyY2hcbiAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgcm91dGVNYXRjaClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlU3RhcnQnLCBhcylcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyhcbiAgICAgICAgcm91dGUsXG4gICAgICAgIHBhdGhuYW1lLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgYXMsXG4gICAgICAgIHNoYWxsb3dcbiAgICAgIClcbiAgICAgIGxldCB7IGVycm9yLCBwcm9wcywgX19OX1NTRywgX19OX1NTUCB9ID0gcm91dGVJbmZvXG5cbiAgICAgIC8vIGhhbmRsZSByZWRpcmVjdCBvbiBjbGllbnQtdHJhbnNpdGlvblxuICAgICAgaWYgKFxuICAgICAgICAoX19OX1NTRyB8fCBfX05fU1NQKSAmJlxuICAgICAgICBwcm9wcyAmJlxuICAgICAgICAocHJvcHMgYXMgYW55KS5wYWdlUHJvcHMgJiZcbiAgICAgICAgKHByb3BzIGFzIGFueSkucGFnZVByb3BzLl9fTl9SRURJUkVDVFxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gKHByb3BzIGFzIGFueSkucGFnZVByb3BzLl9fTl9SRURJUkVDVFxuXG4gICAgICAgIC8vIGNoZWNrIGlmIGRlc3RpbmF0aW9uIGlzIGludGVybmFsIChyZXNvbHZlcyB0byBhIHBhZ2UpIGFuZCBhdHRlbXB0XG4gICAgICAgIC8vIGNsaWVudC1uYXZpZ2F0aW9uIGlmIGl0IGlzIGZhbGxpbmcgYmFjayB0byBoYXJkIG5hdmlnYXRpb24gaWZcbiAgICAgICAgLy8gaXQncyBub3RcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZEhyZWYgPSBwYXJzZVJlbGF0aXZlVXJsKGRlc3RpbmF0aW9uKVxuICAgICAgICAgIHRoaXMuX3Jlc29sdmVIcmVmKHBhcnNlZEhyZWYsIHBhZ2VzLCBmYWxzZSlcblxuICAgICAgICAgIGlmIChwYWdlcy5pbmNsdWRlcyhwYXJzZWRIcmVmLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgeyB1cmw6IG5ld1VybCwgYXM6IG5ld0FzIH0gPSBwcmVwYXJlVXJsQXMoXG4gICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICBkZXN0aW5hdGlvblxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKG1ldGhvZCwgbmV3VXJsLCBuZXdBcywgb3B0aW9ucylcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGRlc3RpbmF0aW9uXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7fSlcbiAgICAgIH1cblxuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdiZWZvcmVIaXN0b3J5Q2hhbmdlJywgYXMpXG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucylcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgYXBwQ29tcDogYW55ID0gdGhpcy5jb21wb25lbnRzWycvX2FwcCddLkNvbXBvbmVudFxuICAgICAgICA7KHdpbmRvdyBhcyBhbnkpLm5leHQuaXNQcmVyZW5kZXJlZCA9XG4gICAgICAgICAgYXBwQ29tcC5nZXRJbml0aWFsUHJvcHMgPT09IGFwcENvbXAub3JpZ0dldEluaXRpYWxQcm9wcyAmJlxuICAgICAgICAgICEocm91dGVJbmZvLkNvbXBvbmVudCBhcyBhbnkpLmdldEluaXRpYWxQcm9wc1xuICAgICAgfVxuXG4gICAgICBhd2FpdCB0aGlzLnNldChyb3V0ZSwgcGF0aG5hbWUhLCBxdWVyeSwgY2xlYW5lZEFzLCByb3V0ZUluZm8pLmNhdGNoKFxuICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgIGlmIChlLmNhbmNlbGxlZCkgZXJyb3IgPSBlcnJvciB8fCBlXG4gICAgICAgICAgZWxzZSB0aHJvdyBlXG4gICAgICAgIH1cbiAgICAgIClcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVycm9yLCBjbGVhbmVkQXMpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiAmJiAnX05fWCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygob3B0aW9ucyBhcyBhbnkpLl9OX1gsIChvcHRpb25zIGFzIGFueSkuX05fWSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICBpZiAodGhpcy5sb2NhbGUpIHtcbiAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZyA9IHRoaXMubG9jYWxlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VDb21wbGV0ZScsIGFzKVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICBjaGFuZ2VTdGF0ZShcbiAgICBtZXRob2Q6IEhpc3RvcnlNZXRob2QsXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgYXM6IHN0cmluZyxcbiAgICBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHt9XG4gICk6IHZvaWQge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeSBpcyBub3QgYXZhaWxhYmxlLmApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5LiR7bWV0aG9kfSBpcyBub3QgYXZhaWxhYmxlYClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1ldGhvZCAhPT0gJ3B1c2hTdGF0ZScgfHwgZ2V0VVJMKCkgIT09IGFzKSB7XG4gICAgICB0aGlzLl9zaGFsbG93ID0gb3B0aW9ucy5zaGFsbG93XG4gICAgICB3aW5kb3cuaGlzdG9yeVttZXRob2RdKFxuICAgICAgICB7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIGFzLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgX19OOiB0cnVlLFxuICAgICAgICB9IGFzIEhpc3RvcnlTdGF0ZSxcbiAgICAgICAgLy8gTW9zdCBicm93c2VycyBjdXJyZW50bHkgaWdub3JlcyB0aGlzIHBhcmFtZXRlciwgYWx0aG91Z2ggdGhleSBtYXkgdXNlIGl0IGluIHRoZSBmdXR1cmUuXG4gICAgICAgIC8vIFBhc3NpbmcgdGhlIGVtcHR5IHN0cmluZyBoZXJlIHNob3VsZCBiZSBzYWZlIGFnYWluc3QgZnV0dXJlIGNoYW5nZXMgdG8gdGhlIG1ldGhvZC5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hpc3RvcnkvcmVwbGFjZVN0YXRlXG4gICAgICAgICcnLFxuICAgICAgICBhc1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGhhbmRsZVJvdXRlSW5mb0Vycm9yKFxuICAgIGVycjogRXJyb3IgJiB7IGNvZGU6IGFueTsgY2FuY2VsbGVkOiBib29sZWFuIH0sXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gICAgYXM6IHN0cmluZyxcbiAgICBsb2FkRXJyb3JGYWlsPzogYm9vbGVhblxuICApOiBQcm9taXNlPENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbz4ge1xuICAgIGlmIChlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAvLyBidWJibGUgdXAgY2FuY2VsbGF0aW9uIGVycm9yc1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgaWYgKGlzQXNzZXRFcnJvcihlcnIpIHx8IGxvYWRFcnJvckZhaWwpIHtcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVyciwgYXMpXG5cbiAgICAgIC8vIElmIHdlIGNhbid0IGxvYWQgdGhlIHBhZ2UgaXQgY291bGQgYmUgb25lIG9mIGZvbGxvd2luZyByZWFzb25zXG4gICAgICAvLyAgMS4gUGFnZSBkb2Vzbid0IGV4aXN0c1xuICAgICAgLy8gIDIuIFBhZ2UgZG9lcyBleGlzdCBpbiBhIGRpZmZlcmVudCB6b25lXG4gICAgICAvLyAgMy4gSW50ZXJuYWwgZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgcGFnZVxuXG4gICAgICAvLyBTbywgZG9pbmcgYSBoYXJkIHJlbG9hZCBpcyB0aGUgcHJvcGVyIHdheSB0byBkZWFsIHdpdGggdGhpcy5cbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYXNcblxuICAgICAgLy8gQ2hhbmdpbmcgdGhlIFVSTCBkb2Vzbid0IGJsb2NrIGV4ZWN1dGluZyB0aGUgY3VycmVudCBjb2RlIHBhdGguXG4gICAgICAvLyBTbyBsZXQncyB0aHJvdyBhIGNhbmNlbGxhdGlvbiBlcnJvciBzdG9wIHRoZSByb3V0aW5nIGxvZ2ljLlxuICAgICAgdGhyb3cgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGxldCBDb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgICAgIGxldCBzdHlsZVNoZWV0czogU3R5bGVTaGVldFR1cGxlW11cbiAgICAgIGxldCBwcm9wczogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZFxuICAgICAgY29uc3Qgc3NnNDA0ID0gZXJyLm1lc3NhZ2UgPT09IFNTR19EQVRBX05PVF9GT1VORF9FUlJPUlxuXG4gICAgICBpZiAoc3NnNDA0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IG1vZDogYW55XG4gICAgICAgICAgOyh7IHBhZ2U6IENvbXBvbmVudCwgc3R5bGVTaGVldHMsIG1vZCB9ID0gYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChcbiAgICAgICAgICAgICcvNDA0J1xuICAgICAgICAgICkpXG5cbiAgICAgICAgICAvLyBUT0RPOiBzaG91bGQgd2UgdG9sZXJhdGUgdGhlc2UgcHJvcHMgbWlzc2luZyBhbmQgc3RpbGwgcmVuZGVyIHRoZVxuICAgICAgICAgIC8vIHBhZ2UgaW5zdGVhZCBvZiBmYWxsaW5nIGJhY2sgdG8gX2Vycm9yP1xuICAgICAgICAgIGlmIChtb2QgJiYgbW9kLl9fTl9TU0cpIHtcbiAgICAgICAgICAgIHByb3BzID0gYXdhaXQgdGhpcy5fZ2V0U3RhdGljRGF0YShcbiAgICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKCcvNDA0JywgJy80MDQnLCB0cnVlLCB0aGlzLmxvY2FsZSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgICAvLyBub24tZmF0YWwgZmFsbGJhY2sgdG8gX2Vycm9yXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgQ29tcG9uZW50ISA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgdHlwZW9mIHN0eWxlU2hlZXRzISA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICkge1xuICAgICAgICA7KHsgcGFnZTogQ29tcG9uZW50LCBzdHlsZVNoZWV0cyB9ID0gYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChcbiAgICAgICAgICAnL19lcnJvcidcbiAgICAgICAgKSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgcm91dGVJbmZvOiBDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8gPSB7XG4gICAgICAgIHByb3BzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIHN0eWxlU2hlZXRzLFxuICAgICAgICBlcnI6IHNzZzQwNCA/IHVuZGVmaW5lZCA6IGVycixcbiAgICAgICAgZXJyb3I6IHNzZzQwNCA/IHVuZGVmaW5lZCA6IGVycixcbiAgICAgIH1cblxuICAgICAgaWYgKCFyb3V0ZUluZm8ucHJvcHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSBhd2FpdCB0aGlzLmdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIHtcbiAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgfSBhcyBhbnkpXG4gICAgICAgIH0gY2F0Y2ggKGdpcEVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGVycm9yIHBhZ2UgYGdldEluaXRpYWxQcm9wc2A6ICcsIGdpcEVycilcbiAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSB7fVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByb3V0ZUluZm9cbiAgICB9IGNhdGNoIChyb3V0ZUluZm9FcnIpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKHJvdXRlSW5mb0VyciwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgdHJ1ZSlcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRSb3V0ZUluZm8oXG4gICAgcm91dGU6IHN0cmluZyxcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBhbnksXG4gICAgYXM6IHN0cmluZyxcbiAgICBzaGFsbG93OiBib29sZWFuID0gZmFsc2VcbiAgKTogUHJvbWlzZTxQcml2YXRlUm91dGVJbmZvPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nUm91dGVJbmZvOiBQcml2YXRlUm91dGVJbmZvIHwgdW5kZWZpbmVkID0gdGhpcy5jb21wb25lbnRzW1xuICAgICAgICByb3V0ZVxuICAgICAgXVxuICAgICAgaWYgKHNoYWxsb3cgJiYgZXhpc3RpbmdSb3V0ZUluZm8gJiYgdGhpcy5yb3V0ZSA9PT0gcm91dGUpIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nUm91dGVJbmZvXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNhY2hlZFJvdXRlSW5mbzogQ29tcGxldGVQcml2YXRlUm91dGVJbmZvIHwgdW5kZWZpbmVkID1cbiAgICAgICAgZXhpc3RpbmdSb3V0ZUluZm8gJiYgJ2luaXRpYWwnIGluIGV4aXN0aW5nUm91dGVJbmZvXG4gICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICA6IGV4aXN0aW5nUm91dGVJbmZvXG4gICAgICBjb25zdCByb3V0ZUluZm86IENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbyA9IGNhY2hlZFJvdXRlSW5mb1xuICAgICAgICA/IGNhY2hlZFJvdXRlSW5mb1xuICAgICAgICA6IGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQocm91dGUpLnRoZW4oKHJlcykgPT4gKHtcbiAgICAgICAgICAgIENvbXBvbmVudDogcmVzLnBhZ2UsXG4gICAgICAgICAgICBzdHlsZVNoZWV0czogcmVzLnN0eWxlU2hlZXRzLFxuICAgICAgICAgICAgX19OX1NTRzogcmVzLm1vZC5fX05fU1NHLFxuICAgICAgICAgICAgX19OX1NTUDogcmVzLm1vZC5fX05fU1NQLFxuICAgICAgICAgIH0pKVxuXG4gICAgICBjb25zdCB7IENvbXBvbmVudCwgX19OX1NTRywgX19OX1NTUCB9ID0gcm91dGVJbmZvXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlIH0gPSByZXF1aXJlKCdyZWFjdC1pcycpXG4gICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKENvbXBvbmVudCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVGhlIGRlZmF1bHQgZXhwb3J0IGlzIG5vdCBhIFJlYWN0IENvbXBvbmVudCBpbiBwYWdlOiBcIiR7cGF0aG5hbWV9XCJgXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBkYXRhSHJlZjogc3RyaW5nIHwgdW5kZWZpbmVkXG5cbiAgICAgIGlmIChfX05fU1NHIHx8IF9fTl9TU1ApIHtcbiAgICAgICAgZGF0YUhyZWYgPSB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoXG4gICAgICAgICAgZm9ybWF0V2l0aFZhbGlkYXRpb24oeyBwYXRobmFtZSwgcXVlcnkgfSksXG4gICAgICAgICAgZGVsQmFzZVBhdGgoYXMpLFxuICAgICAgICAgIF9fTl9TU0csXG4gICAgICAgICAgdGhpcy5sb2NhbGVcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwcm9wcyA9IGF3YWl0IHRoaXMuX2dldERhdGE8Q29tcGxldGVQcml2YXRlUm91dGVJbmZvPigoKSA9PlxuICAgICAgICBfX05fU1NHXG4gICAgICAgICAgPyB0aGlzLl9nZXRTdGF0aWNEYXRhKGRhdGFIcmVmISlcbiAgICAgICAgICA6IF9fTl9TU1BcbiAgICAgICAgICA/IHRoaXMuX2dldFNlcnZlckRhdGEoZGF0YUhyZWYhKVxuICAgICAgICAgIDogdGhpcy5nZXRJbml0aWFsUHJvcHMoXG4gICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgLy8gd2UgcHJvdmlkZSBBcHBUcmVlIGxhdGVyIHNvIHRoaXMgbmVlZHMgdG8gYmUgYGFueWBcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgIGFzUGF0aDogYXMsXG4gICAgICAgICAgICAgIH0gYXMgYW55XG4gICAgICAgICAgICApXG4gICAgICApXG5cbiAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzXG4gICAgICB0aGlzLmNvbXBvbmVudHNbcm91dGVdID0gcm91dGVJbmZvXG4gICAgICByZXR1cm4gcm91dGVJbmZvXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVSb3V0ZUluZm9FcnJvcihlcnIsIHBhdGhuYW1lLCBxdWVyeSwgYXMpXG4gICAgfVxuICB9XG5cbiAgc2V0KFxuICAgIHJvdXRlOiBzdHJpbmcsXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gICAgYXM6IHN0cmluZyxcbiAgICBkYXRhOiBQcml2YXRlUm91dGVJbmZvXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuaXNGYWxsYmFjayA9IGZhbHNlXG5cbiAgICB0aGlzLnJvdXRlID0gcm91dGVcbiAgICB0aGlzLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlcbiAgICB0aGlzLmFzUGF0aCA9IGFzXG4gICAgcmV0dXJuIHRoaXMubm90aWZ5KGRhdGEpXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgcmVwbGFjaW5nIHJvdXRlciBzdGF0ZVxuICAgKiBAcGFyYW0gY2IgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWRcbiAgICovXG4gIGJlZm9yZVBvcFN0YXRlKGNiOiBCZWZvcmVQb3BTdGF0ZUNhbGxiYWNrKSB7XG4gICAgdGhpcy5fYnBzID0gY2JcbiAgfVxuXG4gIG9ubHlBSGFzaENoYW5nZShhczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmFzUGF0aCkgcmV0dXJuIGZhbHNlXG4gICAgY29uc3QgW29sZFVybE5vSGFzaCwgb2xkSGFzaF0gPSB0aGlzLmFzUGF0aC5zcGxpdCgnIycpXG4gICAgY29uc3QgW25ld1VybE5vSGFzaCwgbmV3SGFzaF0gPSBhcy5zcGxpdCgnIycpXG5cbiAgICAvLyBNYWtlcyBzdXJlIHdlIHNjcm9sbCB0byB0aGUgcHJvdmlkZWQgaGFzaCBpZiB0aGUgdXJsL2hhc2ggYXJlIHRoZSBzYW1lXG4gICAgaWYgKG5ld0hhc2ggJiYgb2xkVXJsTm9IYXNoID09PSBuZXdVcmxOb0hhc2ggJiYgb2xkSGFzaCA9PT0gbmV3SGFzaCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdXJscyBhcmUgY2hhbmdlLCB0aGVyZSdzIG1vcmUgdGhhbiBhIGhhc2ggY2hhbmdlXG4gICAgaWYgKG9sZFVybE5vSGFzaCAhPT0gbmV3VXJsTm9IYXNoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgaGFzaCBoYXMgY2hhbmdlZCwgdGhlbiBpdCdzIGEgaGFzaCBvbmx5IGNoYW5nZS5cbiAgICAvLyBUaGlzIGNoZWNrIGlzIG5lY2Vzc2FyeSB0byBoYW5kbGUgYm90aCB0aGUgZW50ZXIgYW5kXG4gICAgLy8gbGVhdmUgaGFzaCA9PT0gJycgY2FzZXMuIFRoZSBpZGVudGl0eSBjYXNlIGZhbGxzIHRocm91Z2hcbiAgICAvLyBhbmQgaXMgdHJlYXRlZCBhcyBhIG5leHQgcmVsb2FkLlxuICAgIHJldHVybiBvbGRIYXNoICE9PSBuZXdIYXNoXG4gIH1cblxuICBzY3JvbGxUb0hhc2goYXM6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IFssIGhhc2hdID0gYXMuc3BsaXQoJyMnKVxuICAgIC8vIFNjcm9sbCB0byB0b3AgaWYgdGhlIGhhc2ggaXMganVzdCBgI2Agd2l0aCBubyB2YWx1ZVxuICAgIGlmIChoYXNoID09PSAnJykge1xuICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBGaXJzdCB3ZSBjaGVjayBpZiB0aGUgZWxlbWVudCBieSBpZCBpcyBmb3VuZFxuICAgIGNvbnN0IGlkRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYXNoKVxuICAgIGlmIChpZEVsKSB7XG4gICAgICBpZEVsLnNjcm9sbEludG9WaWV3KClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBJZiB0aGVyZSdzIG5vIGVsZW1lbnQgd2l0aCB0aGUgaWQsIHdlIGNoZWNrIHRoZSBgbmFtZWAgcHJvcGVydHlcbiAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICBjb25zdCBuYW1lRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShoYXNoKVswXVxuICAgIGlmIChuYW1lRWwpIHtcbiAgICAgIG5hbWVFbC5zY3JvbGxJbnRvVmlldygpXG4gICAgfVxuICB9XG5cbiAgdXJsSXNOZXcoYXNQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5hc1BhdGggIT09IGFzUGF0aFxuICB9XG5cbiAgX3Jlc29sdmVIcmVmKHBhcnNlZEhyZWY6IFVybE9iamVjdCwgcGFnZXM6IHN0cmluZ1tdLCBhcHBseUJhc2VQYXRoID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgcGF0aG5hbWUgfSA9IHBhcnNlZEhyZWZcbiAgICBjb25zdCBjbGVhblBhdGhuYW1lID0gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goXG4gICAgICBkZW5vcm1hbGl6ZVBhZ2VQYXRoKGFwcGx5QmFzZVBhdGggPyBkZWxCYXNlUGF0aChwYXRobmFtZSEpIDogcGF0aG5hbWUhKVxuICAgIClcblxuICAgIGlmIChjbGVhblBhdGhuYW1lID09PSAnLzQwNCcgfHwgY2xlYW5QYXRobmFtZSA9PT0gJy9fZXJyb3InKSB7XG4gICAgICByZXR1cm4gcGFyc2VkSHJlZlxuICAgIH1cblxuICAgIC8vIGhhbmRsZSByZXNvbHZpbmcgaHJlZiBmb3IgZHluYW1pYyByb3V0ZXNcbiAgICBpZiAoIXBhZ2VzLmluY2x1ZGVzKGNsZWFuUGF0aG5hbWUhKSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxuICAgICAgcGFnZXMuc29tZSgocGFnZSkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgaXNEeW5hbWljUm91dGUocGFnZSkgJiZcbiAgICAgICAgICBnZXRSb3V0ZVJlZ2V4KHBhZ2UpLnJlLnRlc3QoY2xlYW5QYXRobmFtZSEpXG4gICAgICAgICkge1xuICAgICAgICAgIHBhcnNlZEhyZWYucGF0aG5hbWUgPSBhcHBseUJhc2VQYXRoID8gYWRkQmFzZVBhdGgocGFnZSkgOiBwYWdlXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZEhyZWZcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVmZXRjaCBwYWdlIGNvZGUsIHlvdSBtYXkgd2FpdCBmb3IgdGhlIGRhdGEgZHVyaW5nIHBhZ2UgcmVuZGVyaW5nLlxuICAgKiBUaGlzIGZlYXR1cmUgb25seSB3b3JrcyBpbiBwcm9kdWN0aW9uIVxuICAgKiBAcGFyYW0gdXJsIHRoZSBocmVmIG9mIHByZWZldGNoZWQgcGFnZVxuICAgKiBAcGFyYW0gYXNQYXRoIHRoZSBhcyBwYXRoIG9mIHRoZSBwcmVmZXRjaGVkIHBhZ2VcbiAgICovXG4gIGFzeW5jIHByZWZldGNoKFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzUGF0aDogc3RyaW5nID0gdXJsLFxuICAgIG9wdGlvbnM6IFByZWZldGNoT3B0aW9ucyA9IHt9XG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxldCBwYXJzZWQgPSBwYXJzZVJlbGF0aXZlVXJsKHVybClcblxuICAgIGxldCB7IHBhdGhuYW1lIH0gPSBwYXJzZWRcblxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICBjb25zdCBub3JtYWxpemVMb2NhbGVQYXRoID0gcmVxdWlyZSgnLi4vaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGgnKVxuICAgICAgICAubm9ybWFsaXplTG9jYWxlUGF0aCBhcyB0eXBlb2YgaW1wb3J0KCcuLi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aCcpLm5vcm1hbGl6ZUxvY2FsZVBhdGhcblxuICAgICAgaWYgKG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICBwYXRobmFtZSA9IG5vcm1hbGl6ZUxvY2FsZVBhdGghKHBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lXG4gICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgICAgIHVybCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZClcblxuICAgICAgICBsZXQgcGFyc2VkQXMgPSBwYXJzZVJlbGF0aXZlVXJsKGFzUGF0aClcbiAgICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9IG5vcm1hbGl6ZUxvY2FsZVBhdGghKFxuICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lLFxuICAgICAgICAgIHRoaXMubG9jYWxlc1xuICAgICAgICApXG4gICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gbG9jYWxlUGF0aFJlc3VsdC5wYXRobmFtZVxuICAgICAgICBvcHRpb25zLmxvY2FsZSA9IGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlXG4gICAgICAgIGFzUGF0aCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZEFzKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KClcblxuICAgIHBhcnNlZCA9IHRoaXMuX3Jlc29sdmVIcmVmKHBhcnNlZCwgcGFnZXMsIGZhbHNlKSBhcyB0eXBlb2YgcGFyc2VkXG5cbiAgICBpZiAocGFyc2VkLnBhdGhuYW1lICE9PSBwYXRobmFtZSkge1xuICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWVcbiAgICAgIHVybCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZClcbiAgICB9XG5cbiAgICAvLyBQcmVmZXRjaCBpcyBub3Qgc3VwcG9ydGVkIGluIGRldmVsb3BtZW50IG1vZGUgYmVjYXVzZSBpdCB3b3VsZCB0cmlnZ2VyIG9uLWRlbWFuZC1lbnRyaWVzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJvdXRlID0gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aG5hbWUpXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy5wYWdlTG9hZGVyLl9pc1NzZyh1cmwpLnRoZW4oKGlzU3NnOiBib29sZWFuKSA9PiB7XG4gICAgICAgIHJldHVybiBpc1NzZ1xuICAgICAgICAgID8gdGhpcy5fZ2V0U3RhdGljRGF0YShcbiAgICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKFxuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBhc1BhdGgsXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICA/IG9wdGlvbnMubG9jYWxlXG4gICAgICAgICAgICAgICAgICA6IHRoaXMubG9jYWxlXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGZhbHNlXG4gICAgICB9KSxcbiAgICAgIHRoaXMucGFnZUxvYWRlcltvcHRpb25zLnByaW9yaXR5ID8gJ2xvYWRQYWdlJyA6ICdwcmVmZXRjaCddKHJvdXRlKSxcbiAgICBdKVxuICB9XG5cbiAgYXN5bmMgZmV0Y2hDb21wb25lbnQocm91dGU6IHN0cmluZyk6IFByb21pc2U8R29vZFBhZ2VDYWNoZT4ge1xuICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZVxuICAgIGNvbnN0IGNhbmNlbCA9ICh0aGlzLmNsYyA9ICgpID0+IHtcbiAgICAgIGNhbmNlbGxlZCA9IHRydWVcbiAgICB9KVxuXG4gICAgY29uc3QgY29tcG9uZW50UmVzdWx0ID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmxvYWRQYWdlKHJvdXRlKVxuXG4gICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcihcbiAgICAgICAgYEFib3J0IGZldGNoaW5nIGNvbXBvbmVudCBmb3Igcm91dGU6IFwiJHtyb3V0ZX1cImBcbiAgICAgIClcbiAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuXG4gICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgIHRoaXMuY2xjID0gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiBjb21wb25lbnRSZXN1bHRcbiAgfVxuXG4gIF9nZXREYXRhPFQ+KGZuOiAoKSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlXG4gICAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZVxuICAgIH1cbiAgICB0aGlzLmNsYyA9IGNhbmNlbFxuICAgIHJldHVybiBmbigpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIGlmIChjYW5jZWwgPT09IHRoaXMuY2xjKSB7XG4gICAgICAgIHRoaXMuY2xjID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgIGNvbnN0IGVycjogYW55ID0gbmV3IEVycm9yKCdMb2FkaW5nIGluaXRpYWwgcHJvcHMgY2FuY2VsbGVkJylcbiAgICAgICAgZXJyLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSlcbiAgfVxuXG4gIF9nZXRTdGF0aWNEYXRhKGRhdGFIcmVmOiBzdHJpbmcpOiBQcm9taXNlPG9iamVjdD4ge1xuICAgIGNvbnN0IHsgaHJlZjogY2FjaGVLZXkgfSA9IG5ldyBVUkwoZGF0YUhyZWYsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMuc2RjW2NhY2hlS2V5XSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnNkY1tjYWNoZUtleV0pXG4gICAgfVxuICAgIHJldHVybiBmZXRjaE5leHREYXRhKGRhdGFIcmVmLCB0aGlzLmlzU3NyKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICB0aGlzLnNkY1tjYWNoZUtleV0gPSBkYXRhXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0pXG4gIH1cblxuICBfZ2V0U2VydmVyRGF0YShkYXRhSHJlZjogc3RyaW5nKTogUHJvbWlzZTxvYmplY3Q+IHtcbiAgICByZXR1cm4gZmV0Y2hOZXh0RGF0YShkYXRhSHJlZiwgdGhpcy5pc1NzcilcbiAgfVxuXG4gIGdldEluaXRpYWxQcm9wcyhcbiAgICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGUsXG4gICAgY3R4OiBOZXh0UGFnZUNvbnRleHRcbiAgKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCB7IENvbXBvbmVudDogQXBwIH0gPSB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ11cbiAgICBjb25zdCBBcHBUcmVlID0gdGhpcy5fd3JhcEFwcChBcHAgYXMgQXBwQ29tcG9uZW50KVxuICAgIGN0eC5BcHBUcmVlID0gQXBwVHJlZVxuICAgIHJldHVybiBsb2FkR2V0SW5pdGlhbFByb3BzPEFwcENvbnRleHRUeXBlPFJvdXRlcj4+KEFwcCwge1xuICAgICAgQXBwVHJlZSxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgIGN0eCxcbiAgICB9KVxuICB9XG5cbiAgYWJvcnRDb21wb25lbnRMb2FkKGFzOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jbGMpIHtcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSwgYXMpXG4gICAgICB0aGlzLmNsYygpXG4gICAgICB0aGlzLmNsYyA9IG51bGxcbiAgICB9XG4gIH1cblxuICBub3RpZnkoZGF0YTogUHJpdmF0ZVJvdXRlSW5mbyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnN1YihkYXRhLCB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10uQ29tcG9uZW50IGFzIEFwcENvbXBvbmVudClcbiAgfVxufVxuIiwiLy8gZXNjYXBlIGRlbGltaXRlcnMgdXNlZCBieSBwYXRoLXRvLXJlZ2V4cFxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXNjYXBlUGF0aERlbGltaXRlcnMoc2VnbWVudDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHNlZ21lbnQucmVwbGFjZSgvWy8jP10vZywgKGNoYXI6IHN0cmluZykgPT4gZW5jb2RlVVJJQ29tcG9uZW50KGNoYXIpKVxufVxuIiwiLy8gRm9ybWF0IGZ1bmN0aW9uIG1vZGlmaWVkIGZyb20gbm9kZWpzXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCAqIGFzIHF1ZXJ5c3RyaW5nIGZyb20gJy4vcXVlcnlzdHJpbmcnXG5cbmNvbnN0IHNsYXNoZWRQcm90b2NvbHMgPSAvaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS9cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFVybCh1cmxPYmo6IFVybE9iamVjdCkge1xuICBsZXQgeyBhdXRoLCBob3N0bmFtZSB9ID0gdXJsT2JqXG4gIGxldCBwcm90b2NvbCA9IHVybE9iai5wcm90b2NvbCB8fCAnJ1xuICBsZXQgcGF0aG5hbWUgPSB1cmxPYmoucGF0aG5hbWUgfHwgJydcbiAgbGV0IGhhc2ggPSB1cmxPYmouaGFzaCB8fCAnJ1xuICBsZXQgcXVlcnkgPSB1cmxPYmoucXVlcnkgfHwgJydcbiAgbGV0IGhvc3Q6IHN0cmluZyB8IGZhbHNlID0gZmFsc2VcblxuICBhdXRoID0gYXV0aCA/IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKS5yZXBsYWNlKC8lM0EvaSwgJzonKSArICdAJyA6ICcnXG5cbiAgaWYgKHVybE9iai5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB1cmxPYmouaG9zdFxuICB9IGVsc2UgaWYgKGhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAofmhvc3RuYW1lLmluZGV4T2YoJzonKSA/IGBbJHtob3N0bmFtZX1dYCA6IGhvc3RuYW1lKVxuICAgIGlmICh1cmxPYmoucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB1cmxPYmoucG9ydFxuICAgIH1cbiAgfVxuXG4gIGlmIChxdWVyeSAmJiB0eXBlb2YgcXVlcnkgPT09ICdvYmplY3QnKSB7XG4gICAgcXVlcnkgPSBTdHJpbmcocXVlcnlzdHJpbmcudXJsUXVlcnlUb1NlYXJjaFBhcmFtcyhxdWVyeSBhcyBQYXJzZWRVcmxRdWVyeSkpXG4gIH1cblxuICBsZXQgc2VhcmNoID0gdXJsT2JqLnNlYXJjaCB8fCAocXVlcnkgJiYgYD8ke3F1ZXJ5fWApIHx8ICcnXG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonXG5cbiAgaWYgKFxuICAgIHVybE9iai5zbGFzaGVzIHx8XG4gICAgKCghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29scy50ZXN0KHByb3RvY29sKSkgJiYgaG9zdCAhPT0gZmFsc2UpXG4gICkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpXG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lWzBdICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWVcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJ1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaFswXSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaFxuICBpZiAoc2VhcmNoICYmIHNlYXJjaFswXSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2hcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZW5jb2RlVVJJQ29tcG9uZW50KVxuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKVxuXG4gIHJldHVybiBgJHtwcm90b2NvbH0ke2hvc3R9JHtwYXRobmFtZX0ke3NlYXJjaH0ke2hhc2h9YFxufVxuIiwiLy8gVHJhbnNsYXRlcyBhIGxvZ2ljYWwgcm91dGUgaW50byBpdHMgcGFnZXMgYXNzZXQgcGF0aCAocmVsYXRpdmUgZnJvbSBhIGNvbW1vbiBwcmVmaXgpXG4vLyBcImFzc2V0IHBhdGhcIiBiZWluZyBpdHMgamF2YXNjcmlwdCBmaWxlLCBkYXRhIGZpbGUsIHByZXJlbmRlcmVkIGh0bWwsLi4uXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRBc3NldFBhdGhGcm9tUm91dGUoXG4gIHJvdXRlOiBzdHJpbmcsXG4gIGV4dDogc3RyaW5nID0gJydcbik6IHN0cmluZyB7XG4gIGNvbnN0IHBhdGggPVxuICAgIHJvdXRlID09PSAnLydcbiAgICAgID8gJy9pbmRleCdcbiAgICAgIDogL15cXC9pbmRleChcXC98JCkvLnRlc3Qocm91dGUpXG4gICAgICA/IGAvaW5kZXgke3JvdXRlfWBcbiAgICAgIDogYCR7cm91dGV9YFxuICByZXR1cm4gcGF0aCArIGV4dFxufVxuIiwiLy8gSWRlbnRpZnkgL1twYXJhbV0vIGluIHJvdXRlIHN0cmluZ1xuY29uc3QgVEVTVF9ST1VURSA9IC9cXC9cXFtbXi9dKz9cXF0oPz1cXC98JCkvXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0R5bmFtaWNSb3V0ZShyb3V0ZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBURVNUX1JPVVRFLnRlc3Qocm91dGUpXG59XG4iLCJpbXBvcnQgeyBnZXRMb2NhdGlvbk9yaWdpbiB9IGZyb20gJy4uLy4uL3V0aWxzJ1xuaW1wb3J0IHsgc2VhcmNoUGFyYW1zVG9VcmxRdWVyeSB9IGZyb20gJy4vcXVlcnlzdHJpbmcnXG5cbi8qKlxuICogUGFyc2VzIHBhdGgtcmVsYXRpdmUgdXJscyAoZS5nLiBgL2hlbGxvL3dvcmxkP2Zvbz1iYXJgKS4gSWYgdXJsIGlzbid0IHBhdGgtcmVsYXRpdmVcbiAqIChlLmcuIGAuL2hlbGxvYCkgdGhlbiBhdCBsZWFzdCBiYXNlIG11c3QgYmUuXG4gKiBBYnNvbHV0ZSB1cmxzIGFyZSByZWplY3RlZCB3aXRoIG9uZSBleGNlcHRpb24sIGluIHRoZSBicm93c2VyLCBhYnNvbHV0ZSB1cmxzIHRoYXQgYXJlIG9uXG4gKiB0aGUgY3VycmVudCBvcmlnaW4gd2lsbCBiZSBwYXJzZWQgYXMgcmVsYXRpdmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUmVsYXRpdmVVcmwodXJsOiBzdHJpbmcsIGJhc2U/OiBzdHJpbmcpIHtcbiAgY29uc3QgZ2xvYmFsQmFzZSA9IG5ldyBVUkwoXG4gICAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAnaHR0cDovL24nIDogZ2V0TG9jYXRpb25PcmlnaW4oKVxuICApXG4gIGNvbnN0IHJlc29sdmVkQmFzZSA9IGJhc2UgPyBuZXcgVVJMKGJhc2UsIGdsb2JhbEJhc2UpIDogZ2xvYmFsQmFzZVxuICBjb25zdCB7IHBhdGhuYW1lLCBzZWFyY2hQYXJhbXMsIHNlYXJjaCwgaGFzaCwgaHJlZiwgb3JpZ2luIH0gPSBuZXcgVVJMKFxuICAgIHVybCxcbiAgICByZXNvbHZlZEJhc2VcbiAgKVxuICBpZiAob3JpZ2luICE9PSBnbG9iYWxCYXNlLm9yaWdpbikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50OiBpbnZhbGlkIHJlbGF0aXZlIFVSTCcpXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZSxcbiAgICBxdWVyeTogc2VhcmNoUGFyYW1zVG9VcmxRdWVyeShzZWFyY2hQYXJhbXMpLFxuICAgIHNlYXJjaCxcbiAgICBoYXNoLFxuICAgIGhyZWY6IGhyZWYuc2xpY2UoZ2xvYmFsQmFzZS5vcmlnaW4ubGVuZ3RoKSxcbiAgfVxufVxuIiwiaW1wb3J0ICogYXMgcGF0aFRvUmVnZXhwIGZyb20gJ25leHQvZGlzdC9jb21waWxlZC9wYXRoLXRvLXJlZ2V4cCdcblxuZXhwb3J0IHsgcGF0aFRvUmVnZXhwIH1cblxuZXhwb3J0IGNvbnN0IG1hdGNoZXJPcHRpb25zOiBwYXRoVG9SZWdleHAuVG9rZW5zVG9SZWdleHBPcHRpb25zICZcbiAgcGF0aFRvUmVnZXhwLlBhcnNlT3B0aW9ucyA9IHtcbiAgc2Vuc2l0aXZlOiBmYWxzZSxcbiAgZGVsaW1pdGVyOiAnLycsXG59XG5cbmV4cG9ydCBjb25zdCBjdXN0b21Sb3V0ZU1hdGNoZXJPcHRpb25zOiBwYXRoVG9SZWdleHAuVG9rZW5zVG9SZWdleHBPcHRpb25zICZcbiAgcGF0aFRvUmVnZXhwLlBhcnNlT3B0aW9ucyA9IHtcbiAgLi4ubWF0Y2hlck9wdGlvbnMsXG4gIHN0cmljdDogdHJ1ZSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgKGN1c3RvbVJvdXRlID0gZmFsc2UpID0+IHtcbiAgcmV0dXJuIChwYXRoOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBrZXlzOiBwYXRoVG9SZWdleHAuS2V5W10gPSBbXVxuICAgIGNvbnN0IG1hdGNoZXJSZWdleCA9IHBhdGhUb1JlZ2V4cC5wYXRoVG9SZWdleHAoXG4gICAgICBwYXRoLFxuICAgICAga2V5cyxcbiAgICAgIGN1c3RvbVJvdXRlID8gY3VzdG9tUm91dGVNYXRjaGVyT3B0aW9ucyA6IG1hdGNoZXJPcHRpb25zXG4gICAgKVxuICAgIGNvbnN0IG1hdGNoZXIgPSBwYXRoVG9SZWdleHAucmVnZXhwVG9GdW5jdGlvbihtYXRjaGVyUmVnZXgsIGtleXMpXG5cbiAgICByZXR1cm4gKHBhdGhuYW1lOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkLCBwYXJhbXM/OiBhbnkpID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IHBhdGhuYW1lID09IG51bGwgPyBmYWxzZSA6IG1hdGNoZXIocGF0aG5hbWUpXG4gICAgICBpZiAoIXJlcykge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKGN1c3RvbVJvdXRlKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAvLyB1bm5hbWVkIHBhcmFtcyBzaG91bGQgYmUgcmVtb3ZlZCBhcyB0aGV5XG4gICAgICAgICAgLy8gYXJlIG5vdCBhbGxvd2VkIHRvIGJlIHVzZWQgaW4gdGhlIGRlc3RpbmF0aW9uXG4gICAgICAgICAgaWYgKHR5cGVvZiBrZXkubmFtZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGRlbGV0ZSAocmVzLnBhcmFtcyBhcyBhbnkpW2tleS5uYW1lXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyAuLi5wYXJhbXMsIC4uLnJlcy5wYXJhbXMgfVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCB7IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkgfSBmcm9tICcuL3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHsgcGFyc2VSZWxhdGl2ZVVybCB9IGZyb20gJy4vcGFyc2UtcmVsYXRpdmUtdXJsJ1xuaW1wb3J0ICogYXMgcGF0aFRvUmVnZXhwIGZyb20gJ25leHQvZGlzdC9jb21waWxlZC9wYXRoLXRvLXJlZ2V4cCdcblxudHlwZSBQYXJhbXMgPSB7IFtwYXJhbTogc3RyaW5nXTogYW55IH1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGVOb25QYXRoKHZhbHVlOiBzdHJpbmcsIHBhcmFtczogUGFyYW1zKTogc3RyaW5nIHtcbiAgaWYgKCF2YWx1ZS5pbmNsdWRlcygnOicpKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwYXJhbXMpKSB7XG4gICAgaWYgKHZhbHVlLmluY2x1ZGVzKGA6JHtrZXl9YCkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWVcbiAgICAgICAgLnJlcGxhY2UoXG4gICAgICAgICAgbmV3IFJlZ0V4cChgOiR7a2V5fVxcXFwqYCwgJ2cnKSxcbiAgICAgICAgICBgOiR7a2V5fS0tRVNDQVBFRF9QQVJBTV9BU1RFUklTS1NgXG4gICAgICAgIClcbiAgICAgICAgLnJlcGxhY2UoXG4gICAgICAgICAgbmV3IFJlZ0V4cChgOiR7a2V5fVxcXFw/YCwgJ2cnKSxcbiAgICAgICAgICBgOiR7a2V5fS0tRVNDQVBFRF9QQVJBTV9RVUVTVElPTmBcbiAgICAgICAgKVxuICAgICAgICAucmVwbGFjZShuZXcgUmVnRXhwKGA6JHtrZXl9XFxcXCtgLCAnZycpLCBgOiR7a2V5fS0tRVNDQVBFRF9QQVJBTV9QTFVTYClcbiAgICAgICAgLnJlcGxhY2UoXG4gICAgICAgICAgbmV3IFJlZ0V4cChgOiR7a2V5fSg/IVxcXFx3KWAsICdnJyksXG4gICAgICAgICAgYC0tRVNDQVBFRF9QQVJBTV9DT0xPTiR7a2V5fWBcbiAgICAgICAgKVxuICAgIH1cbiAgfVxuICB2YWx1ZSA9IHZhbHVlXG4gICAgLnJlcGxhY2UoLyg6fFxcKnxcXD98XFwrfFxcKHxcXCl8XFx7fFxcfSkvZywgJ1xcXFwkMScpXG4gICAgLnJlcGxhY2UoLy0tRVNDQVBFRF9QQVJBTV9QTFVTL2csICcrJylcbiAgICAucmVwbGFjZSgvLS1FU0NBUEVEX1BBUkFNX0NPTE9OL2csICc6JylcbiAgICAucmVwbGFjZSgvLS1FU0NBUEVEX1BBUkFNX1FVRVNUSU9OL2csICc/JylcbiAgICAucmVwbGFjZSgvLS1FU0NBUEVEX1BBUkFNX0FTVEVSSVNLUy9nLCAnKicpXG5cbiAgLy8gdGhlIHZhbHVlIG5lZWRzIHRvIHN0YXJ0IHdpdGggYSBmb3J3YXJkLXNsYXNoIHRvIGJlIGNvbXBpbGVkXG4gIC8vIGNvcnJlY3RseVxuICByZXR1cm4gcGF0aFRvUmVnZXhwXG4gICAgLmNvbXBpbGUoYC8ke3ZhbHVlfWAsIHsgdmFsaWRhdGU6IGZhbHNlIH0pKHBhcmFtcylcbiAgICAuc3Vic3RyKDEpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHByZXBhcmVEZXN0aW5hdGlvbihcbiAgZGVzdGluYXRpb246IHN0cmluZyxcbiAgcGFyYW1zOiBQYXJhbXMsXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSxcbiAgYXBwZW5kUGFyYW1zVG9RdWVyeTogYm9vbGVhbixcbiAgYmFzZVBhdGg6IHN0cmluZ1xuKSB7XG4gIGxldCBwYXJzZWREZXN0aW5hdGlvbjoge1xuICAgIHF1ZXJ5PzogUGFyc2VkVXJsUXVlcnlcbiAgICBwcm90b2NvbD86IHN0cmluZ1xuICAgIGhvc3RuYW1lPzogc3RyaW5nXG4gICAgcG9ydD86IHN0cmluZ1xuICB9ICYgUmV0dXJuVHlwZTx0eXBlb2YgcGFyc2VSZWxhdGl2ZVVybD4gPSB7fSBhcyBhbnlcblxuICAvLyBjbG9uZSBxdWVyeSBzbyB3ZSBkb24ndCBtb2RpZnkgdGhlIG9yaWdpbmFsXG4gIHF1ZXJ5ID0gT2JqZWN0LmFzc2lnbih7fSwgcXVlcnkpXG4gIGNvbnN0IGhhZExvY2FsZSA9IHF1ZXJ5Ll9fbmV4dExvY2FsZVxuICBkZWxldGUgcXVlcnkuX19uZXh0TG9jYWxlXG4gIGRlbGV0ZSBxdWVyeS5fX25leHREZWZhdWx0TG9jYWxlXG5cbiAgaWYgKGRlc3RpbmF0aW9uLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgIHBhcnNlZERlc3RpbmF0aW9uID0gcGFyc2VSZWxhdGl2ZVVybChkZXN0aW5hdGlvbilcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIHNlYXJjaFBhcmFtcyxcbiAgICAgIGhhc2gsXG4gICAgICBob3N0bmFtZSxcbiAgICAgIHBvcnQsXG4gICAgICBwcm90b2NvbCxcbiAgICAgIHNlYXJjaCxcbiAgICAgIGhyZWYsXG4gICAgfSA9IG5ldyBVUkwoZGVzdGluYXRpb24pXG5cbiAgICBwYXJzZWREZXN0aW5hdGlvbiA9IHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgcXVlcnk6IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoc2VhcmNoUGFyYW1zKSxcbiAgICAgIGhhc2gsXG4gICAgICBwcm90b2NvbCxcbiAgICAgIGhvc3RuYW1lLFxuICAgICAgcG9ydCxcbiAgICAgIHNlYXJjaCxcbiAgICAgIGhyZWYsXG4gICAgfVxuICB9XG5cbiAgY29uc3QgZGVzdFF1ZXJ5ID0gcGFyc2VkRGVzdGluYXRpb24ucXVlcnlcbiAgY29uc3QgZGVzdFBhdGggPSBgJHtwYXJzZWREZXN0aW5hdGlvbi5wYXRobmFtZSF9JHtcbiAgICBwYXJzZWREZXN0aW5hdGlvbi5oYXNoIHx8ICcnXG4gIH1gXG4gIGNvbnN0IGRlc3RQYXRoUGFyYW1LZXlzOiBwYXRoVG9SZWdleHAuS2V5W10gPSBbXVxuICBwYXRoVG9SZWdleHAucGF0aFRvUmVnZXhwKGRlc3RQYXRoLCBkZXN0UGF0aFBhcmFtS2V5cylcblxuICBjb25zdCBkZXN0UGF0aFBhcmFtcyA9IGRlc3RQYXRoUGFyYW1LZXlzLm1hcCgoa2V5KSA9PiBrZXkubmFtZSlcblxuICBsZXQgZGVzdGluYXRpb25Db21waWxlciA9IHBhdGhUb1JlZ2V4cC5jb21waWxlKFxuICAgIGRlc3RQYXRoLFxuICAgIC8vIHdlIGRvbid0IHZhbGlkYXRlIHdoaWxlIGNvbXBpbGluZyB0aGUgZGVzdGluYXRpb24gc2luY2Ugd2Ugc2hvdWxkXG4gICAgLy8gaGF2ZSBhbHJlYWR5IHZhbGlkYXRlZCBiZWZvcmUgd2UgZ290IHRvIHRoaXMgcG9pbnQgYW5kIHZhbGlkYXRpbmdcbiAgICAvLyBicmVha3MgY29tcGlsaW5nIGRlc3RpbmF0aW9ucyB3aXRoIG5hbWVkIHBhdHRlcm4gcGFyYW1zIGZyb20gdGhlIHNvdXJjZVxuICAgIC8vIGUuZy4gL3NvbWV0aGluZzpoZWxsbyguKikgLT4gL2Fub3RoZXIvOmhlbGxvIGlzIGJyb2tlbiB3aXRoIHZhbGlkYXRpb25cbiAgICAvLyBzaW5jZSBjb21waWxlIHZhbGlkYXRpb24gaXMgbWVhbnQgZm9yIHJldmVyc2luZyBhbmQgbm90IGZvciBpbnNlcnRpbmdcbiAgICAvLyBwYXJhbXMgZnJvbSBhIHNlcGFyYXRlIHBhdGgtcmVnZXggaW50byBhbm90aGVyXG4gICAgeyB2YWxpZGF0ZTogZmFsc2UgfVxuICApXG4gIGxldCBuZXdVcmxcblxuICAvLyB1cGRhdGUgYW55IHBhcmFtcyBpbiBxdWVyeSB2YWx1ZXNcbiAgZm9yIChjb25zdCBba2V5LCBzdHJPckFycmF5XSBvZiBPYmplY3QuZW50cmllcyhkZXN0UXVlcnkpKSB7XG4gICAgbGV0IHZhbHVlID0gQXJyYXkuaXNBcnJheShzdHJPckFycmF5KSA/IHN0ck9yQXJyYXlbMF0gOiBzdHJPckFycmF5XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAvLyB0aGUgdmFsdWUgbmVlZHMgdG8gc3RhcnQgd2l0aCBhIGZvcndhcmQtc2xhc2ggdG8gYmUgY29tcGlsZWRcbiAgICAgIC8vIGNvcnJlY3RseVxuICAgICAgdmFsdWUgPSBjb21waWxlTm9uUGF0aCh2YWx1ZSwgcGFyYW1zKVxuICAgIH1cbiAgICBkZXN0UXVlcnlba2V5XSA9IHZhbHVlXG4gIH1cblxuICAvLyBhZGQgcGF0aCBwYXJhbXMgdG8gcXVlcnkgaWYgaXQncyBub3QgYSByZWRpcmVjdCBhbmQgbm90XG4gIC8vIGFscmVhZHkgZGVmaW5lZCBpbiBkZXN0aW5hdGlvbiBxdWVyeSBvciBwYXRoXG4gIGxldCBwYXJhbUtleXMgPSBPYmplY3Qua2V5cyhwYXJhbXMpXG5cbiAgLy8gcmVtb3ZlIGludGVybmFsIHBhcmFtIGZvciBpMThuXG4gIGlmIChoYWRMb2NhbGUpIHtcbiAgICBwYXJhbUtleXMgPSBwYXJhbUtleXMuZmlsdGVyKChuYW1lKSA9PiBuYW1lICE9PSAnbmV4dEludGVybmFsTG9jYWxlJylcbiAgfVxuXG4gIGlmIChcbiAgICBhcHBlbmRQYXJhbXNUb1F1ZXJ5ICYmXG4gICAgIXBhcmFtS2V5cy5zb21lKChrZXkpID0+IGRlc3RQYXRoUGFyYW1zLmluY2x1ZGVzKGtleSkpXG4gICkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHBhcmFtS2V5cykge1xuICAgICAgaWYgKCEoa2V5IGluIGRlc3RRdWVyeSkpIHtcbiAgICAgICAgZGVzdFF1ZXJ5W2tleV0gPSBwYXJhbXNba2V5XVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNob3VsZEFkZEJhc2VQYXRoID0gZGVzdGluYXRpb24uc3RhcnRzV2l0aCgnLycpICYmIGJhc2VQYXRoXG5cbiAgdHJ5IHtcbiAgICBuZXdVcmwgPSBgJHtzaG91bGRBZGRCYXNlUGF0aCA/IGJhc2VQYXRoIDogJyd9JHtkZXN0aW5hdGlvbkNvbXBpbGVyKFxuICAgICAgcGFyYW1zXG4gICAgKX1gXG5cbiAgICBjb25zdCBbcGF0aG5hbWUsIGhhc2hdID0gbmV3VXJsLnNwbGl0KCcjJylcbiAgICBwYXJzZWREZXN0aW5hdGlvbi5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgcGFyc2VkRGVzdGluYXRpb24uaGFzaCA9IGAke2hhc2ggPyAnIycgOiAnJ30ke2hhc2ggfHwgJyd9YFxuICAgIGRlbGV0ZSAocGFyc2VkRGVzdGluYXRpb24gYXMgYW55KS5zZWFyY2hcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5tZXNzYWdlLm1hdGNoKC9FeHBlY3RlZCAuKj8gdG8gbm90IHJlcGVhdCwgYnV0IGdvdCBhbiBhcnJheS8pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBUbyB1c2UgYSBtdWx0aS1tYXRjaCBpbiB0aGUgZGVzdGluYXRpb24geW91IG11c3QgYWRkIFxcYCpcXGAgYXQgdGhlIGVuZCBvZiB0aGUgcGFyYW0gbmFtZSB0byBzaWduaWZ5IGl0IHNob3VsZCByZXBlYXQuIGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzL2ludmFsaWQtbXVsdGktbWF0Y2hgXG4gICAgICApXG4gICAgfVxuICAgIHRocm93IGVyclxuICB9XG5cbiAgLy8gUXVlcnkgbWVyZ2Ugb3JkZXIgbG93ZXN0IHByaW9yaXR5IHRvIGhpZ2hlc3RcbiAgLy8gMS4gaW5pdGlhbCBVUkwgcXVlcnkgdmFsdWVzXG4gIC8vIDIuIHBhdGggc2VnbWVudCB2YWx1ZXNcbiAgLy8gMy4gZGVzdGluYXRpb24gc3BlY2lmaWVkIHF1ZXJ5IHZhbHVlc1xuICBwYXJzZWREZXN0aW5hdGlvbi5xdWVyeSA9IHtcbiAgICAuLi5xdWVyeSxcbiAgICAuLi5wYXJzZWREZXN0aW5hdGlvbi5xdWVyeSxcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmV3VXJsLFxuICAgIHBhcnNlZERlc3RpbmF0aW9uLFxuICB9XG59XG4iLCJpbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuXG5leHBvcnQgZnVuY3Rpb24gc2VhcmNoUGFyYW1zVG9VcmxRdWVyeShcbiAgc2VhcmNoUGFyYW1zOiBVUkxTZWFyY2hQYXJhbXNcbik6IFBhcnNlZFVybFF1ZXJ5IHtcbiAgY29uc3QgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5ID0ge31cbiAgc2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBpZiAodHlwZW9mIHF1ZXJ5W2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBxdWVyeVtrZXldID0gdmFsdWVcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocXVlcnlba2V5XSkpIHtcbiAgICAgIDsocXVlcnlba2V5XSBhcyBzdHJpbmdbXSkucHVzaCh2YWx1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnlba2V5XSA9IFtxdWVyeVtrZXldIGFzIHN0cmluZywgdmFsdWVdXG4gICAgfVxuICB9KVxuICByZXR1cm4gcXVlcnlcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5VXJsUXVlcnlQYXJhbShwYXJhbTogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKFxuICAgIHR5cGVvZiBwYXJhbSA9PT0gJ3N0cmluZycgfHxcbiAgICAodHlwZW9mIHBhcmFtID09PSAnbnVtYmVyJyAmJiAhaXNOYU4ocGFyYW0pKSB8fFxuICAgIHR5cGVvZiBwYXJhbSA9PT0gJ2Jvb2xlYW4nXG4gICkge1xuICAgIHJldHVybiBTdHJpbmcocGFyYW0pXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcnXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMoXG4gIHVybFF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpXG4gIE9iamVjdC5lbnRyaWVzKHVybFF1ZXJ5KS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0pID0+IHJlc3VsdC5hcHBlbmQoa2V5LCBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKGl0ZW0pKSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnNldChrZXksIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0odmFsdWUpKVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKFxuICB0YXJnZXQ6IFVSTFNlYXJjaFBhcmFtcyxcbiAgLi4uc2VhcmNoUGFyYW1zTGlzdDogVVJMU2VhcmNoUGFyYW1zW11cbik6IFVSTFNlYXJjaFBhcmFtcyB7XG4gIHNlYXJjaFBhcmFtc0xpc3QuZm9yRWFjaCgoc2VhcmNoUGFyYW1zKSA9PiB7XG4gICAgQXJyYXkuZnJvbShzZWFyY2hQYXJhbXMua2V5cygpKS5mb3JFYWNoKChrZXkpID0+IHRhcmdldC5kZWxldGUoa2V5KSlcbiAgICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gdGFyZ2V0LmFwcGVuZChrZXksIHZhbHVlKSlcbiAgfSlcbiAgcmV0dXJuIHRhcmdldFxufVxuIiwiaW1wb3J0IHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCBwYXRoTWF0Y2ggZnJvbSAnLi9wYXRoLW1hdGNoJ1xuaW1wb3J0IHByZXBhcmVEZXN0aW5hdGlvbiBmcm9tICcuL3ByZXBhcmUtZGVzdGluYXRpb24nXG5pbXBvcnQgeyBSZXdyaXRlIH0gZnJvbSAnLi4vLi4vLi4vLi4vbGliL2xvYWQtY3VzdG9tLXJvdXRlcydcbmltcG9ydCB7IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoIH0gZnJvbSAnLi4vLi4vLi4vLi4vY2xpZW50L25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaCdcblxuY29uc3QgY3VzdG9tUm91dGVNYXRjaGVyID0gcGF0aE1hdGNoKHRydWUpXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlc29sdmVSZXdyaXRlcyhcbiAgYXNQYXRoOiBzdHJpbmcsXG4gIHBhZ2VzOiBzdHJpbmdbXSxcbiAgYmFzZVBhdGg6IHN0cmluZyxcbiAgcmV3cml0ZXM6IFJld3JpdGVbXSxcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICByZXNvbHZlSHJlZjogKHBhdGg6IHN0cmluZykgPT4gc3RyaW5nXG4pIHtcbiAgaWYgKCFwYWdlcy5pbmNsdWRlcyhhc1BhdGgpKSB7XG4gICAgZm9yIChjb25zdCByZXdyaXRlIG9mIHJld3JpdGVzKSB7XG4gICAgICBjb25zdCBtYXRjaGVyID0gY3VzdG9tUm91dGVNYXRjaGVyKHJld3JpdGUuc291cmNlKVxuICAgICAgY29uc3QgcGFyYW1zID0gbWF0Y2hlcihhc1BhdGgpXG5cbiAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFyZXdyaXRlLmRlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyBhIHByb3hpZWQgcmV3cml0ZSB3aGljaCBpc24ndCBoYW5kbGVkIG9uIHRoZSBjbGllbnRcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlc3RSZXMgPSBwcmVwYXJlRGVzdGluYXRpb24oXG4gICAgICAgICAgcmV3cml0ZS5kZXN0aW5hdGlvbixcbiAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgcXVlcnksXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICByZXdyaXRlLmJhc2VQYXRoID09PSBmYWxzZSA/ICcnIDogYmFzZVBhdGhcbiAgICAgICAgKVxuICAgICAgICBhc1BhdGggPSBkZXN0UmVzLnBhcnNlZERlc3RpbmF0aW9uLnBhdGhuYW1lIVxuICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCBkZXN0UmVzLnBhcnNlZERlc3RpbmF0aW9uLnF1ZXJ5KVxuXG4gICAgICAgIGlmIChwYWdlcy5pbmNsdWRlcyhyZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChhc1BhdGgpKSkge1xuICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIG5vdyBtYXRjaCBhIHBhZ2UgYXMgdGhpcyBtZWFucyB3ZSBhcmUgZG9uZVxuICAgICAgICAgIC8vIHJlc29sdmluZyB0aGUgcmV3cml0ZXNcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgbWF0Y2ggYSBkeW5hbWljLXJvdXRlLCBpZiBzbyB3ZSBicmVhayB0aGUgcmV3cml0ZXMgY2hhaW5cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gcmVzb2x2ZUhyZWYoYXNQYXRoKVxuXG4gICAgICAgIGlmIChyZXNvbHZlZEhyZWYgIT09IGFzUGF0aCAmJiBwYWdlcy5pbmNsdWRlcyhyZXNvbHZlZEhyZWYpKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYXNQYXRoXG59XG4iLCJpbXBvcnQgeyBnZXRSb3V0ZVJlZ2V4IH0gZnJvbSAnLi9yb3V0ZS1yZWdleCdcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJvdXRlTWF0Y2hlcihyb3V0ZVJlZ2V4OiBSZXR1cm5UeXBlPHR5cGVvZiBnZXRSb3V0ZVJlZ2V4Pikge1xuICBjb25zdCB7IHJlLCBncm91cHMgfSA9IHJvdXRlUmVnZXhcbiAgcmV0dXJuIChwYXRobmFtZTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4ge1xuICAgIGNvbnN0IHJvdXRlTWF0Y2ggPSByZS5leGVjKHBhdGhuYW1lISlcbiAgICBpZiAoIXJvdXRlTWF0Y2gpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IGRlY29kZSA9IChwYXJhbTogc3RyaW5nKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHBhcmFtKVxuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICBjb25zdCBlcnI6IEVycm9yICYgeyBjb2RlPzogc3RyaW5nIH0gPSBuZXcgRXJyb3IoXG4gICAgICAgICAgJ2ZhaWxlZCB0byBkZWNvZGUgcGFyYW0nXG4gICAgICAgIClcbiAgICAgICAgZXJyLmNvZGUgPSAnREVDT0RFX0ZBSUxFRCdcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtczogeyBbcGFyYW1OYW1lOiBzdHJpbmddOiBzdHJpbmcgfCBzdHJpbmdbXSB9ID0ge31cblxuICAgIE9iamVjdC5rZXlzKGdyb3VwcykuZm9yRWFjaCgoc2x1Z05hbWU6IHN0cmluZykgPT4ge1xuICAgICAgY29uc3QgZyA9IGdyb3Vwc1tzbHVnTmFtZV1cbiAgICAgIGNvbnN0IG0gPSByb3V0ZU1hdGNoW2cucG9zXVxuICAgICAgaWYgKG0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJhbXNbc2x1Z05hbWVdID0gfm0uaW5kZXhPZignLycpXG4gICAgICAgICAgPyBtLnNwbGl0KCcvJykubWFwKChlbnRyeSkgPT4gZGVjb2RlKGVudHJ5KSlcbiAgICAgICAgICA6IGcucmVwZWF0XG4gICAgICAgICAgPyBbZGVjb2RlKG0pXVxuICAgICAgICAgIDogZGVjb2RlKG0pXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gcGFyYW1zXG4gIH1cbn1cbiIsImludGVyZmFjZSBHcm91cCB7XG4gIHBvczogbnVtYmVyXG4gIHJlcGVhdDogYm9vbGVhblxuICBvcHRpb25hbDogYm9vbGVhblxufVxuXG4vLyB0aGlzIGlzbid0IGltcG9ydGluZyB0aGUgZXNjYXBlLXN0cmluZy1yZWdleCBtb2R1bGVcbi8vIHRvIHJlZHVjZSBieXRlc1xuZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKyo/Li1dL2csICdcXFxcJCYnKVxufVxuXG5mdW5jdGlvbiBwYXJzZVBhcmFtZXRlcihwYXJhbTogc3RyaW5nKSB7XG4gIGNvbnN0IG9wdGlvbmFsID0gcGFyYW0uc3RhcnRzV2l0aCgnWycpICYmIHBhcmFtLmVuZHNXaXRoKCddJylcbiAgaWYgKG9wdGlvbmFsKSB7XG4gICAgcGFyYW0gPSBwYXJhbS5zbGljZSgxLCAtMSlcbiAgfVxuICBjb25zdCByZXBlYXQgPSBwYXJhbS5zdGFydHNXaXRoKCcuLi4nKVxuICBpZiAocmVwZWF0KSB7XG4gICAgcGFyYW0gPSBwYXJhbS5zbGljZSgzKVxuICB9XG4gIHJldHVybiB7IGtleTogcGFyYW0sIHJlcGVhdCwgb3B0aW9uYWwgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um91dGVSZWdleChcbiAgbm9ybWFsaXplZFJvdXRlOiBzdHJpbmdcbik6IHtcbiAgcmU6IFJlZ0V4cFxuICBuYW1lZFJlZ2V4Pzogc3RyaW5nXG4gIHJvdXRlS2V5cz86IHsgW25hbWVkOiBzdHJpbmddOiBzdHJpbmcgfVxuICBncm91cHM6IHsgW2dyb3VwTmFtZTogc3RyaW5nXTogR3JvdXAgfVxufSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gKG5vcm1hbGl6ZWRSb3V0ZS5yZXBsYWNlKC9cXC8kLywgJycpIHx8ICcvJylcbiAgICAuc2xpY2UoMSlcbiAgICAuc3BsaXQoJy8nKVxuXG4gIGNvbnN0IGdyb3VwczogeyBbZ3JvdXBOYW1lOiBzdHJpbmddOiBHcm91cCB9ID0ge31cbiAgbGV0IGdyb3VwSW5kZXggPSAxXG4gIGNvbnN0IHBhcmFtZXRlcml6ZWRSb3V0ZSA9IHNlZ21lbnRzXG4gICAgLm1hcCgoc2VnbWVudCkgPT4ge1xuICAgICAgaWYgKHNlZ21lbnQuc3RhcnRzV2l0aCgnWycpICYmIHNlZ21lbnQuZW5kc1dpdGgoJ10nKSkge1xuICAgICAgICBjb25zdCB7IGtleSwgb3B0aW9uYWwsIHJlcGVhdCB9ID0gcGFyc2VQYXJhbWV0ZXIoc2VnbWVudC5zbGljZSgxLCAtMSkpXG4gICAgICAgIGdyb3Vwc1trZXldID0geyBwb3M6IGdyb3VwSW5kZXgrKywgcmVwZWF0LCBvcHRpb25hbCB9XG4gICAgICAgIHJldHVybiByZXBlYXQgPyAob3B0aW9uYWwgPyAnKD86LyguKz8pKT8nIDogJy8oLis/KScpIDogJy8oW14vXSs/KSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBgLyR7ZXNjYXBlUmVnZXgoc2VnbWVudCl9YFxuICAgICAgfVxuICAgIH0pXG4gICAgLmpvaW4oJycpXG5cbiAgLy8gZGVhZCBjb2RlIGVsaW1pbmF0ZSBmb3IgYnJvd3NlciBzaW5jZSBpdCdzIG9ubHkgbmVlZGVkXG4gIC8vIHdoaWxlIGdlbmVyYXRpbmcgcm91dGVzLW1hbmlmZXN0XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIGxldCByb3V0ZUtleUNoYXJDb2RlID0gOTdcbiAgICBsZXQgcm91dGVLZXlDaGFyTGVuZ3RoID0gMVxuXG4gICAgLy8gYnVpbGRzIGEgbWluaW1hbCByb3V0ZUtleSB1c2luZyBvbmx5IGEteiBhbmQgbWluaW1hbCBudW1iZXIgb2YgY2hhcmFjdGVyc1xuICAgIGNvbnN0IGdldFNhZmVSb3V0ZUtleSA9ICgpID0+IHtcbiAgICAgIGxldCByb3V0ZUtleSA9ICcnXG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGVLZXlDaGFyTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcm91dGVLZXkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShyb3V0ZUtleUNoYXJDb2RlKVxuICAgICAgICByb3V0ZUtleUNoYXJDb2RlKytcblxuICAgICAgICBpZiAocm91dGVLZXlDaGFyQ29kZSA+IDEyMikge1xuICAgICAgICAgIHJvdXRlS2V5Q2hhckxlbmd0aCsrXG4gICAgICAgICAgcm91dGVLZXlDaGFyQ29kZSA9IDk3XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByb3V0ZUtleVxuICAgIH1cblxuICAgIGNvbnN0IHJvdXRlS2V5czogeyBbbmFtZWQ6IHN0cmluZ106IHN0cmluZyB9ID0ge31cblxuICAgIGxldCBuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSA9IHNlZ21lbnRzXG4gICAgICAubWFwKChzZWdtZW50KSA9PiB7XG4gICAgICAgIGlmIChzZWdtZW50LnN0YXJ0c1dpdGgoJ1snKSAmJiBzZWdtZW50LmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgICBjb25zdCB7IGtleSwgb3B0aW9uYWwsIHJlcGVhdCB9ID0gcGFyc2VQYXJhbWV0ZXIoc2VnbWVudC5zbGljZSgxLCAtMSkpXG4gICAgICAgICAgLy8gcmVwbGFjZSBhbnkgbm9uLXdvcmQgY2hhcmFjdGVycyBzaW5jZSB0aGV5IGNhbiBicmVha1xuICAgICAgICAgIC8vIHRoZSBuYW1lZCByZWdleFxuICAgICAgICAgIGxldCBjbGVhbmVkS2V5ID0ga2V5LnJlcGxhY2UoL1xcVy9nLCAnJylcbiAgICAgICAgICBsZXQgaW52YWxpZEtleSA9IGZhbHNlXG5cbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGUga2V5IGlzIHN0aWxsIGludmFsaWQgYW5kIGZhbGxiYWNrIHRvIHVzaW5nIGEga25vd25cbiAgICAgICAgICAvLyBzYWZlIGtleVxuICAgICAgICAgIGlmIChjbGVhbmVkS2V5Lmxlbmd0aCA9PT0gMCB8fCBjbGVhbmVkS2V5Lmxlbmd0aCA+IDMwKSB7XG4gICAgICAgICAgICBpbnZhbGlkS2V5ID0gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzTmFOKHBhcnNlSW50KGNsZWFuZWRLZXkuc3Vic3RyKDAsIDEpKSkpIHtcbiAgICAgICAgICAgIGludmFsaWRLZXkgPSB0cnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGludmFsaWRLZXkpIHtcbiAgICAgICAgICAgIGNsZWFuZWRLZXkgPSBnZXRTYWZlUm91dGVLZXkoKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJvdXRlS2V5c1tjbGVhbmVkS2V5XSA9IGtleVxuICAgICAgICAgIHJldHVybiByZXBlYXRcbiAgICAgICAgICAgID8gb3B0aW9uYWxcbiAgICAgICAgICAgICAgPyBgKD86Lyg/PCR7Y2xlYW5lZEtleX0+Lis/KSk/YFxuICAgICAgICAgICAgICA6IGAvKD88JHtjbGVhbmVkS2V5fT4uKz8pYFxuICAgICAgICAgICAgOiBgLyg/PCR7Y2xlYW5lZEtleX0+W14vXSs/KWBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYC8ke2VzY2FwZVJlZ2V4KHNlZ21lbnQpfWBcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5qb2luKCcnKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlOiBuZXcgUmVnRXhwKGBeJHtwYXJhbWV0ZXJpemVkUm91dGV9KD86Lyk/JGApLFxuICAgICAgZ3JvdXBzLFxuICAgICAgcm91dGVLZXlzLFxuICAgICAgbmFtZWRSZWdleDogYF4ke25hbWVkUGFyYW1ldGVyaXplZFJvdXRlfSg/Oi8pPyRgLFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcmU6IG5ldyBSZWdFeHAoYF4ke3BhcmFtZXRlcml6ZWRSb3V0ZX0oPzovKT8kYCksXG4gICAgZ3JvdXBzLFxuICB9XG59XG4iLCJpbXBvcnQgeyBJbmNvbWluZ01lc3NhZ2UsIFNlcnZlclJlc3BvbnNlIH0gZnJvbSAnaHR0cCdcbmltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQgeyBmb3JtYXRVcmwgfSBmcm9tICcuL3JvdXRlci91dGlscy9mb3JtYXQtdXJsJ1xuaW1wb3J0IHsgTWFuaWZlc3RJdGVtIH0gZnJvbSAnLi4vc2VydmVyL2xvYWQtY29tcG9uZW50cydcbmltcG9ydCB7IE5leHRSb3V0ZXIgfSBmcm9tICcuL3JvdXRlci9yb3V0ZXInXG5pbXBvcnQgeyBFbnYgfSBmcm9tICdAbmV4dC9lbnYnXG5pbXBvcnQgeyBCdWlsZE1hbmlmZXN0IH0gZnJvbSAnLi4vc2VydmVyL2dldC1wYWdlLWZpbGVzJ1xuXG4vKipcbiAqIFR5cGVzIHVzZWQgYnkgYm90aCBuZXh0IGFuZCBuZXh0LXNlcnZlclxuICovXG5cbmV4cG9ydCB0eXBlIE5leHRDb21wb25lbnRUeXBlPFxuICBDIGV4dGVuZHMgQmFzZUNvbnRleHQgPSBOZXh0UGFnZUNvbnRleHQsXG4gIElQID0ge30sXG4gIFAgPSB7fVxuPiA9IENvbXBvbmVudFR5cGU8UD4gJiB7XG4gIC8qKlxuICAgKiBVc2VkIGZvciBpbml0aWFsIHBhZ2UgbG9hZCBkYXRhIHBvcHVsYXRpb24uIERhdGEgcmV0dXJuZWQgZnJvbSBgZ2V0SW5pdGlhbFByb3BzYCBpcyBzZXJpYWxpemVkIHdoZW4gc2VydmVyIHJlbmRlcmVkLlxuICAgKiBNYWtlIHN1cmUgdG8gcmV0dXJuIHBsYWluIGBPYmplY3RgIHdpdGhvdXQgdXNpbmcgYERhdGVgLCBgTWFwYCwgYFNldGAuXG4gICAqIEBwYXJhbSBjdHggQ29udGV4dCBvZiBgcGFnZWBcbiAgICovXG4gIGdldEluaXRpYWxQcm9wcz8oY29udGV4dDogQyk6IElQIHwgUHJvbWlzZTxJUD5cbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRUeXBlID0gTmV4dENvbXBvbmVudFR5cGU8XG4gIERvY3VtZW50Q29udGV4dCxcbiAgRG9jdW1lbnRJbml0aWFsUHJvcHMsXG4gIERvY3VtZW50UHJvcHNcbj4gJiB7XG4gIHJlbmRlckRvY3VtZW50KFxuICAgIERvY3VtZW50OiBEb2N1bWVudFR5cGUsXG4gICAgcHJvcHM6IERvY3VtZW50UHJvcHNcbiAgKTogUmVhY3QuUmVhY3RFbGVtZW50XG59XG5cbmV4cG9ydCB0eXBlIEFwcFR5cGUgPSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgQXBwQ29udGV4dFR5cGUsXG4gIEFwcEluaXRpYWxQcm9wcyxcbiAgQXBwUHJvcHNUeXBlXG4+XG5cbmV4cG9ydCB0eXBlIEFwcFRyZWVUeXBlID0gQ29tcG9uZW50VHlwZTxcbiAgQXBwSW5pdGlhbFByb3BzICYgeyBbbmFtZTogc3RyaW5nXTogYW55IH1cbj5cblxuLyoqXG4gKiBXZWIgdml0YWxzIHByb3ZpZGVkIHRvIF9hcHAucmVwb3J0V2ViVml0YWxzIGJ5IENvcmUgV2ViIFZpdGFscyBwbHVnaW4gZGV2ZWxvcGVkIGJ5IEdvb2dsZSBDaHJvbWUgdGVhbS5cbiAqIGh0dHBzOi8vbmV4dGpzLm9yZy9ibG9nL25leHQtOS00I2ludGVncmF0ZWQtd2ViLXZpdGFscy1yZXBvcnRpbmdcbiAqL1xuZXhwb3J0IHR5cGUgTmV4dFdlYlZpdGFsc01ldHJpYyA9IHtcbiAgaWQ6IHN0cmluZ1xuICBsYWJlbDogc3RyaW5nXG4gIG5hbWU6IHN0cmluZ1xuICBzdGFydFRpbWU6IG51bWJlclxuICB2YWx1ZTogbnVtYmVyXG59XG5cbmV4cG9ydCB0eXBlIEVuaGFuY2VyPEM+ID0gKENvbXBvbmVudDogQykgPT4gQ1xuXG5leHBvcnQgdHlwZSBDb21wb25lbnRzRW5oYW5jZXIgPVxuICB8IHtcbiAgICAgIGVuaGFuY2VBcHA/OiBFbmhhbmNlcjxBcHBUeXBlPlxuICAgICAgZW5oYW5jZUNvbXBvbmVudD86IEVuaGFuY2VyPE5leHRDb21wb25lbnRUeXBlPlxuICAgIH1cbiAgfCBFbmhhbmNlcjxOZXh0Q29tcG9uZW50VHlwZT5cblxuZXhwb3J0IHR5cGUgUmVuZGVyUGFnZVJlc3VsdCA9IHtcbiAgaHRtbDogc3RyaW5nXG4gIGhlYWQ/OiBBcnJheTxKU1guRWxlbWVudCB8IG51bGw+XG59XG5cbmV4cG9ydCB0eXBlIFJlbmRlclBhZ2UgPSAoXG4gIG9wdGlvbnM/OiBDb21wb25lbnRzRW5oYW5jZXJcbikgPT4gUmVuZGVyUGFnZVJlc3VsdCB8IFByb21pc2U8UmVuZGVyUGFnZVJlc3VsdD5cblxuZXhwb3J0IHR5cGUgQmFzZUNvbnRleHQgPSB7XG4gIHJlcz86IFNlcnZlclJlc3BvbnNlXG4gIFtrOiBzdHJpbmddOiBhbnlcbn1cblxuZXhwb3J0IHR5cGUgTkVYVF9EQVRBID0ge1xuICBwcm9wczogUmVjb3JkPHN0cmluZywgYW55PlxuICBwYWdlOiBzdHJpbmdcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIGJ1aWxkSWQ6IHN0cmluZ1xuICBhc3NldFByZWZpeD86IHN0cmluZ1xuICBydW50aW1lQ29uZmlnPzogeyBba2V5OiBzdHJpbmddOiBhbnkgfVxuICBuZXh0RXhwb3J0PzogYm9vbGVhblxuICBhdXRvRXhwb3J0PzogYm9vbGVhblxuICBpc0ZhbGxiYWNrPzogYm9vbGVhblxuICBkeW5hbWljSWRzPzogc3RyaW5nW11cbiAgZXJyPzogRXJyb3IgJiB7IHN0YXR1c0NvZGU/OiBudW1iZXIgfVxuICBnc3A/OiBib29sZWFuXG4gIGdzc3A/OiBib29sZWFuXG4gIGN1c3RvbVNlcnZlcj86IGJvb2xlYW5cbiAgZ2lwPzogYm9vbGVhblxuICBhcHBHaXA/OiBib29sZWFuXG4gIGxvY2FsZT86IHN0cmluZ1xuICBsb2NhbGVzPzogc3RyaW5nW11cbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xufVxuXG4vKipcbiAqIGBOZXh0YCBjb250ZXh0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV4dFBhZ2VDb250ZXh0IHtcbiAgLyoqXG4gICAqIEVycm9yIG9iamVjdCBpZiBlbmNvdW50ZXJlZCBkdXJpbmcgcmVuZGVyaW5nXG4gICAqL1xuICBlcnI/OiAoRXJyb3IgJiB7IHN0YXR1c0NvZGU/OiBudW1iZXIgfSkgfCBudWxsXG4gIC8qKlxuICAgKiBgSFRUUGAgcmVxdWVzdCBvYmplY3QuXG4gICAqL1xuICByZXE/OiBJbmNvbWluZ01lc3NhZ2VcbiAgLyoqXG4gICAqIGBIVFRQYCByZXNwb25zZSBvYmplY3QuXG4gICAqL1xuICByZXM/OiBTZXJ2ZXJSZXNwb25zZVxuICAvKipcbiAgICogUGF0aCBzZWN0aW9uIG9mIGBVUkxgLlxuICAgKi9cbiAgcGF0aG5hbWU6IHN0cmluZ1xuICAvKipcbiAgICogUXVlcnkgc3RyaW5nIHNlY3Rpb24gb2YgYFVSTGAgcGFyc2VkIGFzIGFuIG9iamVjdC5cbiAgICovXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICAvKipcbiAgICogYFN0cmluZ2Agb2YgdGhlIGFjdHVhbCBwYXRoIGluY2x1ZGluZyBxdWVyeS5cbiAgICovXG4gIGFzUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogYENvbXBvbmVudGAgdGhlIHRyZWUgb2YgdGhlIEFwcCB0byB1c2UgaWYgbmVlZGluZyB0byByZW5kZXIgc2VwYXJhdGVseVxuICAgKi9cbiAgQXBwVHJlZTogQXBwVHJlZVR5cGVcbn1cblxuZXhwb3J0IHR5cGUgQXBwQ29udGV4dFR5cGU8UiBleHRlbmRzIE5leHRSb3V0ZXIgPSBOZXh0Um91dGVyPiA9IHtcbiAgQ29tcG9uZW50OiBOZXh0Q29tcG9uZW50VHlwZTxOZXh0UGFnZUNvbnRleHQ+XG4gIEFwcFRyZWU6IEFwcFRyZWVUeXBlXG4gIGN0eDogTmV4dFBhZ2VDb250ZXh0XG4gIHJvdXRlcjogUlxufVxuXG5leHBvcnQgdHlwZSBBcHBJbml0aWFsUHJvcHMgPSB7XG4gIHBhZ2VQcm9wczogYW55XG59XG5cbmV4cG9ydCB0eXBlIEFwcFByb3BzVHlwZTxcbiAgUiBleHRlbmRzIE5leHRSb3V0ZXIgPSBOZXh0Um91dGVyLFxuICBQID0ge31cbj4gPSBBcHBJbml0aWFsUHJvcHMgJiB7XG4gIENvbXBvbmVudDogTmV4dENvbXBvbmVudFR5cGU8TmV4dFBhZ2VDb250ZXh0LCBhbnksIFA+XG4gIHJvdXRlcjogUlxuICBfX05fU1NHPzogYm9vbGVhblxuICBfX05fU1NQPzogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudENvbnRleHQgPSBOZXh0UGFnZUNvbnRleHQgJiB7XG4gIHJlbmRlclBhZ2U6IFJlbmRlclBhZ2Vcbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRJbml0aWFsUHJvcHMgPSBSZW5kZXJQYWdlUmVzdWx0ICYge1xuICBzdHlsZXM/OiBSZWFjdC5SZWFjdEVsZW1lbnRbXSB8IFJlYWN0LlJlYWN0RnJhZ21lbnRcbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRQcm9wcyA9IERvY3VtZW50SW5pdGlhbFByb3BzICYge1xuICBfX05FWFRfREFUQV9fOiBORVhUX0RBVEFcbiAgZGFuZ2Vyb3VzQXNQYXRoOiBzdHJpbmdcbiAgZG9jQ29tcG9uZW50c1JlbmRlcmVkOiB7XG4gICAgSHRtbD86IGJvb2xlYW5cbiAgICBNYWluPzogYm9vbGVhblxuICAgIEhlYWQ/OiBib29sZWFuXG4gICAgTmV4dFNjcmlwdD86IGJvb2xlYW5cbiAgfVxuICBidWlsZE1hbmlmZXN0OiBCdWlsZE1hbmlmZXN0XG4gIGFtcFBhdGg6IHN0cmluZ1xuICBpbkFtcE1vZGU6IGJvb2xlYW5cbiAgaHlicmlkQW1wOiBib29sZWFuXG4gIGlzRGV2ZWxvcG1lbnQ6IGJvb2xlYW5cbiAgZHluYW1pY0ltcG9ydHM6IE1hbmlmZXN0SXRlbVtdXG4gIGFzc2V0UHJlZml4Pzogc3RyaW5nXG4gIGNhbm9uaWNhbEJhc2U6IHN0cmluZ1xuICBoZWFkVGFnczogYW55W11cbiAgdW5zdGFibGVfcnVudGltZUpTPzogZmFsc2VcbiAgZGV2T25seUNhY2hlQnVzdGVyUXVlcnlTdHJpbmc6IHN0cmluZ1xuICBsb2NhbGU/OiBzdHJpbmdcbn1cblxuLyoqXG4gKiBOZXh0IGBBUElgIHJvdXRlIHJlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXh0QXBpUmVxdWVzdCBleHRlbmRzIEluY29taW5nTWVzc2FnZSB7XG4gIC8qKlxuICAgKiBPYmplY3Qgb2YgYHF1ZXJ5YCB2YWx1ZXMgZnJvbSB1cmxcbiAgICovXG4gIHF1ZXJ5OiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgc3RyaW5nW11cbiAgfVxuICAvKipcbiAgICogT2JqZWN0IG9mIGBjb29raWVzYCBmcm9tIGhlYWRlclxuICAgKi9cbiAgY29va2llczoge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZ1xuICB9XG5cbiAgYm9keTogYW55XG5cbiAgZW52OiBFbnZcblxuICBwcmV2aWV3PzogYm9vbGVhblxuICAvKipcbiAgICogUHJldmlldyBkYXRhIHNldCBvbiB0aGUgcmVxdWVzdCwgaWYgYW55XG4gICAqICovXG4gIHByZXZpZXdEYXRhPzogYW55XG59XG5cbi8qKlxuICogU2VuZCBib2R5IG9mIHJlc3BvbnNlXG4gKi9cbnR5cGUgU2VuZDxUPiA9IChib2R5OiBUKSA9PiB2b2lkXG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSByZXNwb25zZVxuICovXG5leHBvcnQgdHlwZSBOZXh0QXBpUmVzcG9uc2U8VCA9IGFueT4gPSBTZXJ2ZXJSZXNwb25zZSAmIHtcbiAgLyoqXG4gICAqIFNlbmQgZGF0YSBgYW55YCBkYXRhIGluIHJlc3BvbnNlXG4gICAqL1xuICBzZW5kOiBTZW5kPFQ+XG4gIC8qKlxuICAgKiBTZW5kIGRhdGEgYGpzb25gIGRhdGEgaW4gcmVzcG9uc2VcbiAgICovXG4gIGpzb246IFNlbmQ8VD5cbiAgc3RhdHVzOiAoc3RhdHVzQ29kZTogbnVtYmVyKSA9PiBOZXh0QXBpUmVzcG9uc2U8VD5cbiAgcmVkaXJlY3QodXJsOiBzdHJpbmcpOiBOZXh0QXBpUmVzcG9uc2U8VD5cbiAgcmVkaXJlY3Qoc3RhdHVzOiBudW1iZXIsIHVybDogc3RyaW5nKTogTmV4dEFwaVJlc3BvbnNlPFQ+XG5cbiAgLyoqXG4gICAqIFNldCBwcmV2aWV3IGRhdGEgZm9yIE5leHQuanMnIHByZXJlbmRlciBtb2RlXG4gICAqL1xuICBzZXRQcmV2aWV3RGF0YTogKFxuICAgIGRhdGE6IG9iamVjdCB8IHN0cmluZyxcbiAgICBvcHRpb25zPzoge1xuICAgICAgLyoqXG4gICAgICAgKiBTcGVjaWZpZXMgdGhlIG51bWJlciAoaW4gc2Vjb25kcykgZm9yIHRoZSBwcmV2aWV3IHNlc3Npb24gdG8gbGFzdCBmb3IuXG4gICAgICAgKiBUaGUgZ2l2ZW4gbnVtYmVyIHdpbGwgYmUgY29udmVydGVkIHRvIGFuIGludGVnZXIgYnkgcm91bmRpbmcgZG93bi5cbiAgICAgICAqIEJ5IGRlZmF1bHQsIG5vIG1heGltdW0gYWdlIGlzIHNldCBhbmQgdGhlIHByZXZpZXcgc2Vzc2lvbiBmaW5pc2hlc1xuICAgICAgICogd2hlbiB0aGUgY2xpZW50IHNodXRzIGRvd24gKGJyb3dzZXIgaXMgY2xvc2VkKS5cbiAgICAgICAqL1xuICAgICAgbWF4QWdlPzogbnVtYmVyXG4gICAgfVxuICApID0+IE5leHRBcGlSZXNwb25zZTxUPlxuICBjbGVhclByZXZpZXdEYXRhOiAoKSA9PiBOZXh0QXBpUmVzcG9uc2U8VD5cbn1cblxuLyoqXG4gKiBOZXh0IGBBUElgIHJvdXRlIGhhbmRsZXJcbiAqL1xuZXhwb3J0IHR5cGUgTmV4dEFwaUhhbmRsZXI8VCA9IGFueT4gPSAoXG4gIHJlcTogTmV4dEFwaVJlcXVlc3QsXG4gIHJlczogTmV4dEFwaVJlc3BvbnNlPFQ+XG4pID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+XG5cbi8qKlxuICogVXRpbHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWNPbmNlPFQgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IFJldHVyblR5cGU8VD4+KFxuICBmbjogVFxuKTogVCB7XG4gIGxldCB1c2VkID0gZmFsc2VcbiAgbGV0IHJlc3VsdDogUmV0dXJuVHlwZTxUPlxuXG4gIHJldHVybiAoKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgaWYgKCF1c2VkKSB7XG4gICAgICB1c2VkID0gdHJ1ZVxuICAgICAgcmVzdWx0ID0gZm4oLi4uYXJncylcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KSBhcyBUXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2NhdGlvbk9yaWdpbigpIHtcbiAgY29uc3QgeyBwcm90b2NvbCwgaG9zdG5hbWUsIHBvcnQgfSA9IHdpbmRvdy5sb2NhdGlvblxuICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2hvc3RuYW1lfSR7cG9ydCA/ICc6JyArIHBvcnQgOiAnJ31gXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVUkwoKSB7XG4gIGNvbnN0IHsgaHJlZiB9ID0gd2luZG93LmxvY2F0aW9uXG4gIGNvbnN0IG9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKClcbiAgcmV0dXJuIGhyZWYuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXNwbGF5TmFtZTxQPihDb21wb25lbnQ6IENvbXBvbmVudFR5cGU8UD4pIHtcbiAgcmV0dXJuIHR5cGVvZiBDb21wb25lbnQgPT09ICdzdHJpbmcnXG4gICAgPyBDb21wb25lbnRcbiAgICA6IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnVW5rbm93bidcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVzU2VudChyZXM6IFNlcnZlclJlc3BvbnNlKSB7XG4gIHJldHVybiByZXMuZmluaXNoZWQgfHwgcmVzLmhlYWRlcnNTZW50XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkR2V0SW5pdGlhbFByb3BzPFxuICBDIGV4dGVuZHMgQmFzZUNvbnRleHQsXG4gIElQID0ge30sXG4gIFAgPSB7fVxuPihBcHA6IE5leHRDb21wb25lbnRUeXBlPEMsIElQLCBQPiwgY3R4OiBDKTogUHJvbWlzZTxJUD4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChBcHAucHJvdG90eXBlPy5nZXRJbml0aWFsUHJvcHMpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgXCIke2dldERpc3BsYXlOYW1lKFxuICAgICAgICBBcHBcbiAgICAgICl9LmdldEluaXRpYWxQcm9wcygpXCIgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgLSB2aXNpdCBodHRwczovL2Vyci5zaC92ZXJjZWwvbmV4dC5qcy9nZXQtaW5pdGlhbC1wcm9wcy1hcy1hbi1pbnN0YW5jZS1tZXRob2QgZm9yIG1vcmUgaW5mb3JtYXRpb24uYFxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gICAgfVxuICB9XG4gIC8vIHdoZW4gY2FsbGVkIGZyb20gX2FwcCBgY3R4YCBpcyBuZXN0ZWQgaW4gYGN0eGBcbiAgY29uc3QgcmVzID0gY3R4LnJlcyB8fCAoY3R4LmN0eCAmJiBjdHguY3R4LnJlcylcblxuICBpZiAoIUFwcC5nZXRJbml0aWFsUHJvcHMpIHtcbiAgICBpZiAoY3R4LmN0eCAmJiBjdHguQ29tcG9uZW50KSB7XG4gICAgICAvLyBAdHMtaWdub3JlIHBhZ2VQcm9wcyBkZWZhdWx0XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYWdlUHJvcHM6IGF3YWl0IGxvYWRHZXRJbml0aWFsUHJvcHMoY3R4LkNvbXBvbmVudCwgY3R4LmN0eCksXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7fSBhcyBJUFxuICB9XG5cbiAgY29uc3QgcHJvcHMgPSBhd2FpdCBBcHAuZ2V0SW5pdGlhbFByb3BzKGN0eClcblxuICBpZiAocmVzICYmIGlzUmVzU2VudChyZXMpKSB7XG4gICAgcmV0dXJuIHByb3BzXG4gIH1cblxuICBpZiAoIXByb3BzKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGBcIiR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICBBcHBcbiAgICApfS5nZXRJbml0aWFsUHJvcHMoKVwiIHNob3VsZCByZXNvbHZlIHRvIGFuIG9iamVjdC4gQnV0IGZvdW5kIFwiJHtwcm9wc31cIiBpbnN0ZWFkLmBcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGggPT09IDAgJiYgIWN0eC5jdHgpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYCR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICAgICAgQXBwXG4gICAgICAgICl9IHJldHVybmVkIGFuIGVtcHR5IG9iamVjdCBmcm9tIFxcYGdldEluaXRpYWxQcm9wc1xcYC4gVGhpcyBkZS1vcHRpbWl6ZXMgYW5kIHByZXZlbnRzIGF1dG9tYXRpYyBzdGF0aWMgb3B0aW1pemF0aW9uLiBodHRwczovL2Vyci5zaC92ZXJjZWwvbmV4dC5qcy9lbXB0eS1vYmplY3QtZ2V0SW5pdGlhbFByb3BzYFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9wc1xufVxuXG5leHBvcnQgY29uc3QgdXJsT2JqZWN0S2V5cyA9IFtcbiAgJ2F1dGgnLFxuICAnaGFzaCcsXG4gICdob3N0JyxcbiAgJ2hvc3RuYW1lJyxcbiAgJ2hyZWYnLFxuICAncGF0aCcsXG4gICdwYXRobmFtZScsXG4gICdwb3J0JyxcbiAgJ3Byb3RvY29sJyxcbiAgJ3F1ZXJ5JyxcbiAgJ3NlYXJjaCcsXG4gICdzbGFzaGVzJyxcbl1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHVybDogVXJsT2JqZWN0KTogc3RyaW5nIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgaWYgKHVybCAhPT0gbnVsbCAmJiB0eXBlb2YgdXJsID09PSAnb2JqZWN0Jykge1xuICAgICAgT2JqZWN0LmtleXModXJsKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgaWYgKHVybE9iamVjdEtleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBVbmtub3duIGtleSBwYXNzZWQgdmlhIHVybE9iamVjdCBpbnRvIHVybC5mb3JtYXQ6ICR7a2V5fWBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvcm1hdFVybCh1cmwpXG59XG5cbmV4cG9ydCBjb25zdCBTUCA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCdcbmV4cG9ydCBjb25zdCBTVCA9XG4gIFNQICYmXG4gIHR5cGVvZiBwZXJmb3JtYW5jZS5tYXJrID09PSAnZnVuY3Rpb24nICYmXG4gIHR5cGVvZiBwZXJmb3JtYW5jZS5tZWFzdXJlID09PSAnZnVuY3Rpb24nXG4iLCJcInVzZSBzdHJpY3RcIjtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzLm5vcm1hbGl6ZVBhdGhTZXA9bm9ybWFsaXplUGF0aFNlcDtleHBvcnRzLmRlbm9ybWFsaXplUGFnZVBhdGg9ZGVub3JtYWxpemVQYWdlUGF0aDtmdW5jdGlvbiBub3JtYWxpemVQYXRoU2VwKHBhdGgpe3JldHVybiBwYXRoLnJlcGxhY2UoL1xcXFwvZywnLycpO31mdW5jdGlvbiBkZW5vcm1hbGl6ZVBhZ2VQYXRoKHBhZ2Upe3BhZ2U9bm9ybWFsaXplUGF0aFNlcChwYWdlKTtpZihwYWdlLnN0YXJ0c1dpdGgoJy9pbmRleC8nKSl7cGFnZT1wYWdlLnNsaWNlKDYpO31lbHNlIGlmKHBhZ2U9PT0nL2luZGV4Jyl7cGFnZT0nLyc7fXJldHVybiBwYWdlO31cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbm9ybWFsaXplLXBhZ2UtcGF0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzT2xkSUUgPSBmdW5jdGlvbiBpc09sZElFKCkge1xuICB2YXIgbWVtbztcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4gICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufSgpO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICB2YXIgbWVtbyA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUodGFyZ2V0KSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gIH07XG59KCk7XG5cbnZhciBzdHlsZXNJbkRvbSA9IFtdO1xuXG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRG9tLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRG9tW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM11cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlc0luRG9tLnB1c2goe1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiBhZGRTdHlsZShvYmosIG9wdGlvbnMpLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICB2YXIgYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcyB8fCB7fTtcblxuICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMubm9uY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICAgIGlmIChub25jZSkge1xuICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gIH0pO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zLmluc2VydChzdHlsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhcmdldCA9IGdldFRhcmdldChvcHRpb25zLmluc2VydCB8fCAnaGVhZCcpO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxudmFyIHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLm1lZGlhID8gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKS5jb25jYXQob2JqLmNzcywgXCJ9XCIpIDogb2JqLmNzczsgLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlLCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3M7XG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYTtcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7XG4gIH1cblxuICBpZiAoc291cmNlTWFwICYmIGJ0b2EpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfSAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlO1xuICB2YXIgdXBkYXRlO1xuICB2YXIgcmVtb3ZlO1xuXG4gIGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuICAgIHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUgPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZShvYmopO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuICAvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cbiAgaWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09ICdib29sZWFuJykge1xuICAgIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuICB9XG5cbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdMaXN0KSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG5cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG5cbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG5cbiAgICAgIGlmIChzdHlsZXNJbkRvbVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5Eb21bX2luZGV4XS51cGRhdGVyKCk7XG5cbiAgICAgICAgc3R5bGVzSW5Eb20uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsTW9kdWxlKSB7XG5cdGlmICghb3JpZ2luYWxNb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0dmFyIG1vZHVsZSA9IE9iamVjdC5jcmVhdGUob3JpZ2luYWxNb2R1bGUpO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImV4cG9ydHNcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheUxpa2VUb0FycmF5OyIsImZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRoSG9sZXM7IiwiZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FzeW5jVG9HZW5lcmF0b3I7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY2xhc3NDYWxsQ2hlY2s7IiwidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2ZcIik7XG5cbnZhciBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSByZXF1aXJlKFwiLi9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3RcIik7XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIHNldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3Q7IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jcmVhdGVDbGFzczsiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHk7IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59IiwiZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBcImRlZmF1bHRcIjogb2JqXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdDsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkge1xuICBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7XG4gIHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkge1xuICAgIHJldHVybiBjYWNoZTtcbiAgfTtcblxuICByZXR1cm4gY2FjaGU7XG59XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikge1xuICBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB7XG4gICAgICBcImRlZmF1bHRcIjogb2JqXG4gICAgfTtcbiAgfVxuXG4gIHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpO1xuXG4gIGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkge1xuICAgIHJldHVybiBjYWNoZS5nZXQob2JqKTtcbiAgfVxuXG4gIHZhciBuZXdPYmogPSB7fTtcbiAgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7XG5cbiAgICAgIGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajtcblxuICBpZiAoY2FjaGUpIHtcbiAgICBjYWNoZS5zZXQob2JqLCBuZXdPYmopO1xuICB9XG5cbiAgcmV0dXJuIG5ld09iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZDsiLCJmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdDsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheUxpbWl0OyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlUmVzdDsiLCJmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZjsiLCJ2YXIgYXJyYXlXaXRoSG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhIb2xlc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5TGltaXRcIik7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgbm9uSXRlcmFibGVSZXN0ID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVSZXN0XCIpO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zbGljZWRUb0FycmF5OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZjsiLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXlcIik7XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgYXJlQ29va2llc0F1dGhvcml6ZWQgfSBmcm9tICcuLi9icm93c2VyL2Nvb2tpZSc7XG5pbXBvcnQgeyBidWlsZENvbmZpZ3VyYXRpb24gfSBmcm9tICcuLi9kb21haW4vY29uZmlndXJhdGlvbic7XG5pbXBvcnQgeyBzZXREZWJ1Z01vZGUsIHN0YXJ0SW50ZXJuYWxNb25pdG9yaW5nIH0gZnJvbSAnLi4vZG9tYWluL2ludGVybmFsTW9uaXRvcmluZyc7XG5pbXBvcnQgeyBjYXRjaFVzZXJFcnJvcnMgfSBmcm9tICcuLi90b29scy9jYXRjaFVzZXJFcnJvcnMnO1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQdWJsaWNBcGkoc3R1Yikge1xuICAgIHZhciBwdWJsaWNBcGkgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3R1YiksIHsgXG4gICAgICAgIC8vIFRoaXMgQVBJIG1ldGhvZCBpcyBpbnRlbnRpb25hbGx5IG5vdCBtb25pdG9yZWQsIHNpbmNlIHRoZSBvbmx5IHRoaW5nIGV4ZWN1dGVkIGlzIHRoZVxuICAgICAgICAvLyB1c2VyLXByb3ZpZGVkICdjYWxsYmFjaycuICBBbGwgU0RLIHVzYWdlcyBleGVjdXRlZCBpbiB0aGUgY2FsbGJhY2sgc2hvdWxkIGJlIG1vbml0b3JlZCwgYW5kXG4gICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gaW50ZXJmZXIgd2l0aCB0aGUgdXNlciB1bmNhdWdodCBleGNlcHRpb25zLlxuICAgICAgICBvblJlYWR5OiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0gfSk7XG4gICAgLy8gQWRkIGFuIFwiaGlkZGVuXCIgcHJvcGVydHkgdG8gc2V0IGRlYnVnIG1vZGUuIFdlIGRlZmluZSBpdCB0aGF0IHdheSB0byBoaWRlIGl0XG4gICAgLy8gYXMgbXVjaCBhcyBwb3NzaWJsZSBidXQgb2YgY291cnNlIGl0J3Mgbm90IGEgcmVhbCBwcm90ZWN0aW9uLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwdWJsaWNBcGksICdfc2V0RGVidWcnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNldERlYnVnTW9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgfSk7XG4gICAgcmV0dXJuIHB1YmxpY0FwaTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVHbG9iYWwoZ2xvYmFsLCBuYW1lLCBhcGkpIHtcbiAgICB2YXIgZXhpc3RpbmdHbG9iYWxWYXJpYWJsZSA9IGdsb2JhbFtuYW1lXTtcbiAgICBnbG9iYWxbbmFtZV0gPSBhcGk7XG4gICAgaWYgKGV4aXN0aW5nR2xvYmFsVmFyaWFibGUgJiYgZXhpc3RpbmdHbG9iYWxWYXJpYWJsZS5xKSB7XG4gICAgICAgIGV4aXN0aW5nR2xvYmFsVmFyaWFibGUucS5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gY2F0Y2hVc2VyRXJyb3JzKGZuLCAnb25SZWFkeSBjYWxsYmFjayB0aHJldyBhbiBlcnJvcjonKSgpOyB9KTtcbiAgICB9XG59XG5leHBvcnQgdmFyIEJ1aWxkTW9kZTtcbihmdW5jdGlvbiAoQnVpbGRNb2RlKSB7XG4gICAgQnVpbGRNb2RlW1wiUkVMRUFTRVwiXSA9IFwicmVsZWFzZVwiO1xuICAgIEJ1aWxkTW9kZVtcIlNUQUdJTkdcIl0gPSBcInN0YWdpbmdcIjtcbiAgICBCdWlsZE1vZGVbXCJFMkVfVEVTVFwiXSA9IFwiZTJlLXRlc3RcIjtcbn0pKEJ1aWxkTW9kZSB8fCAoQnVpbGRNb2RlID0ge30pKTtcbmV4cG9ydCBmdW5jdGlvbiBjb21tb25Jbml0KHVzZXJDb25maWd1cmF0aW9uLCBidWlsZEVudikge1xuICAgIHZhciBjb25maWd1cmF0aW9uID0gYnVpbGRDb25maWd1cmF0aW9uKHVzZXJDb25maWd1cmF0aW9uLCBidWlsZEVudik7XG4gICAgdmFyIGludGVybmFsTW9uaXRvcmluZyA9IHN0YXJ0SW50ZXJuYWxNb25pdG9yaW5nKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbmZpZ3VyYXRpb246IGNvbmZpZ3VyYXRpb24sXG4gICAgICAgIGludGVybmFsTW9uaXRvcmluZzogaW50ZXJuYWxNb25pdG9yaW5nLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tDb29raWVzQXV0aG9yaXplZChvcHRpb25zKSB7XG4gICAgaWYgKCFhcmVDb29raWVzQXV0aG9yaXplZChvcHRpb25zKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0Nvb2tpZXMgYXJlIG5vdCBhdXRob3JpemVkLCB3ZSB3aWxsIG5vdCBzZW5kIGFueSBkYXRhLicpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrSXNOb3RMb2NhbEZpbGUoKSB7XG4gICAgaWYgKGlzTG9jYWxGaWxlKCkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXhlY3V0aW9uIGlzIG5vdCBhbGxvd2VkIGluIHRoZSBjdXJyZW50IGNvbnRleHQuJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBpc0xvY2FsRmlsZSgpIHtcbiAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAnZmlsZTonO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5pdC5qcy5tYXAiLCJpbXBvcnQgeyBmaW5kQ29tbWFTZXBhcmF0ZWRWYWx1ZSwgZ2VuZXJhdGVVVUlELCBPTkVfU0VDT05EIH0gZnJvbSAnLi4vdG9vbHMvdXRpbHMnO1xuZXhwb3J0IHZhciBDT09LSUVfQUNDRVNTX0RFTEFZID0gT05FX1NFQ09ORDtcbmV4cG9ydCBmdW5jdGlvbiBjYWNoZUNvb2tpZUFjY2VzcyhuYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIHRpbWVvdXQ7XG4gICAgdmFyIGNhY2hlO1xuICAgIHZhciBoYXNDYWNoZSA9IGZhbHNlO1xuICAgIHZhciBjYWNoZUFjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaGFzQ2FjaGUgPSB0cnVlO1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGhhc0NhY2hlID0gZmFsc2U7XG4gICAgICAgIH0sIENPT0tJRV9BQ0NFU1NfREVMQVkpO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaGFzQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWNoZSA9IGdldENvb2tpZShuYW1lKTtcbiAgICAgICAgICAgIGNhY2hlQWNjZXNzKCk7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlLCBleHBpcmVEZWxheSkge1xuICAgICAgICAgICAgc2V0Q29va2llKG5hbWUsIHZhbHVlLCBleHBpcmVEZWxheSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjYWNoZSA9IHZhbHVlO1xuICAgICAgICAgICAgY2FjaGVBY2Nlc3MoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldENvb2tpZShuYW1lLCB2YWx1ZSwgZXhwaXJlRGVsYXksIG9wdGlvbnMpIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgZXhwaXJlRGVsYXkpO1xuICAgIHZhciBleHBpcmVzID0gXCJleHBpcmVzPVwiICsgZGF0ZS50b1VUQ1N0cmluZygpO1xuICAgIHZhciBzYW1lU2l0ZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jcm9zc1NpdGUgPyAnbm9uZScgOiAnc3RyaWN0JztcbiAgICB2YXIgZG9tYWluID0gb3B0aW9ucyAmJiBvcHRpb25zLmRvbWFpbiA/IFwiO2RvbWFpbj1cIiArIG9wdGlvbnMuZG9tYWluIDogJyc7XG4gICAgdmFyIHNlY3VyZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zZWN1cmUgPyBcIjtzZWN1cmVcIiA6ICcnO1xuICAgIGRvY3VtZW50LmNvb2tpZSA9IG5hbWUgKyBcIj1cIiArIHZhbHVlICsgXCI7XCIgKyBleHBpcmVzICsgXCI7cGF0aD0vO3NhbWVzaXRlPVwiICsgc2FtZVNpdGUgKyBkb21haW4gKyBzZWN1cmU7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29va2llKG5hbWUpIHtcbiAgICByZXR1cm4gZmluZENvbW1hU2VwYXJhdGVkVmFsdWUoZG9jdW1lbnQuY29va2llLCBuYW1lKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcmVDb29raWVzQXV0aG9yaXplZChvcHRpb25zKSB7XG4gICAgaWYgKGRvY3VtZW50LmNvb2tpZSA9PT0gdW5kZWZpbmVkIHx8IGRvY3VtZW50LmNvb2tpZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIFVzZSBhIHVuaXF1ZSBjb29raWUgbmFtZSB0byBhdm9pZCBpc3N1ZXMgd2hlbiB0aGUgU0RLIGlzIGluaXRpYWxpemVkIG11bHRpcGxlIHRpbWVzIGR1cmluZ1xuICAgICAgICAvLyB0aGUgdGVzdCBjb29raWUgbGlmZXRpbWVcbiAgICAgICAgdmFyIHRlc3RDb29raWVOYW1lID0gXCJkZF9jb29raWVfdGVzdF9cIiArIGdlbmVyYXRlVVVJRCgpO1xuICAgICAgICB2YXIgdGVzdENvb2tpZVZhbHVlID0gJ3Rlc3QnO1xuICAgICAgICBzZXRDb29raWUodGVzdENvb2tpZU5hbWUsIHRlc3RDb29raWVWYWx1ZSwgT05FX1NFQ09ORCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBnZXRDb29raWUodGVzdENvb2tpZU5hbWUpID09PSB0ZXN0Q29va2llVmFsdWU7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogTm8gQVBJIHRvIHJldHJpZXZlIGl0LCBudW1iZXIgb2YgbGV2ZWxzIGZvciBzdWJkb21haW4gYW5kIHN1ZmZpeCBhcmUgdW5rbm93blxuICogc3RyYXRlZ3k6IGZpbmQgdGhlIG1pbmltYWwgZG9tYWluIG9uIHdoaWNoIGNvb2tpZXMgYXJlIGFsbG93ZWQgdG8gYmUgc2V0XG4gKiBodHRwczovL3dlYi5kZXYvc2FtZS1zaXRlLXNhbWUtb3JpZ2luLyNzaXRlXG4gKi9cbnZhciBnZXRDdXJyZW50U2l0ZUNhY2hlO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRTaXRlKCkge1xuICAgIGlmIChnZXRDdXJyZW50U2l0ZUNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gVXNlIGEgdW5pcXVlIGNvb2tpZSBuYW1lIHRvIGF2b2lkIGlzc3VlcyB3aGVuIHRoZSBTREsgaXMgaW5pdGlhbGl6ZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nXG4gICAgICAgIC8vIHRoZSB0ZXN0IGNvb2tpZSBsaWZldGltZVxuICAgICAgICB2YXIgdGVzdENvb2tpZU5hbWUgPSBcImRkX3NpdGVfdGVzdF9cIiArIGdlbmVyYXRlVVVJRCgpO1xuICAgICAgICB2YXIgdGVzdENvb2tpZVZhbHVlID0gJ3Rlc3QnO1xuICAgICAgICB2YXIgZG9tYWluTGV2ZWxzID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciBjYW5kaWRhdGVEb21haW4gPSBkb21haW5MZXZlbHMucG9wKCk7XG4gICAgICAgIHdoaWxlIChkb21haW5MZXZlbHMubGVuZ3RoICYmICFnZXRDb29raWUodGVzdENvb2tpZU5hbWUpKSB7XG4gICAgICAgICAgICBjYW5kaWRhdGVEb21haW4gPSBkb21haW5MZXZlbHMucG9wKCkgKyBcIi5cIiArIGNhbmRpZGF0ZURvbWFpbjtcbiAgICAgICAgICAgIHNldENvb2tpZSh0ZXN0Q29va2llTmFtZSwgdGVzdENvb2tpZVZhbHVlLCBPTkVfU0VDT05ELCB7IGRvbWFpbjogY2FuZGlkYXRlRG9tYWluIH0pO1xuICAgICAgICB9XG4gICAgICAgIGdldEN1cnJlbnRTaXRlQ2FjaGUgPSBjYW5kaWRhdGVEb21haW47XG4gICAgfVxuICAgIHJldHVybiBnZXRDdXJyZW50U2l0ZUNhY2hlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29va2llLmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciwgX19nZW5lcmF0b3IgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IG1vbml0b3IsIGNhbGxNb25pdG9yZWQgfSBmcm9tICcuLi9kb21haW4vaW50ZXJuYWxNb25pdG9yaW5nJztcbmltcG9ydCB7IGNvbXB1dGVTdGFja1RyYWNlIH0gZnJvbSAnLi4vZG9tYWluL3RyYWNla2l0JztcbmltcG9ydCB7IHRvU3RhY2tUcmFjZVN0cmluZyB9IGZyb20gJy4uL3Rvb2xzL2Vycm9yJztcbmltcG9ydCB7IGVsYXBzZWQsIHJlbGF0aXZlTm93IH0gZnJvbSAnLi4vdG9vbHMvdGltZVV0aWxzJztcbmltcG9ydCB7IG5vcm1hbGl6ZVVybCB9IGZyb20gJy4uL3Rvb2xzL3VybFBvbHlmaWxsJztcbnZhciBmZXRjaFByb3h5U2luZ2xldG9uO1xudmFyIG9yaWdpbmFsRmV0Y2g7XG52YXIgYmVmb3JlU2VuZENhbGxiYWNrcyA9IFtdO1xudmFyIG9uUmVxdWVzdENvbXBsZXRlQ2FsbGJhY2tzID0gW107XG5leHBvcnQgZnVuY3Rpb24gc3RhcnRGZXRjaFByb3h5KCkge1xuICAgIGlmICghZmV0Y2hQcm94eVNpbmdsZXRvbikge1xuICAgICAgICBwcm94eUZldGNoKCk7XG4gICAgICAgIGZldGNoUHJveHlTaW5nbGV0b24gPSB7XG4gICAgICAgICAgICBiZWZvcmVTZW5kOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBiZWZvcmVTZW5kQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVxdWVzdENvbXBsZXRlOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBvblJlcXVlc3RDb21wbGV0ZUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmZXRjaFByb3h5U2luZ2xldG9uO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0RmV0Y2hQcm94eSgpIHtcbiAgICBpZiAoZmV0Y2hQcm94eVNpbmdsZXRvbikge1xuICAgICAgICBmZXRjaFByb3h5U2luZ2xldG9uID0gdW5kZWZpbmVkO1xuICAgICAgICBiZWZvcmVTZW5kQ2FsbGJhY2tzLnNwbGljZSgwLCBiZWZvcmVTZW5kQ2FsbGJhY2tzLmxlbmd0aCk7XG4gICAgICAgIG9uUmVxdWVzdENvbXBsZXRlQ2FsbGJhY2tzLnNwbGljZSgwLCBvblJlcXVlc3RDb21wbGV0ZUNhbGxiYWNrcy5sZW5ndGgpO1xuICAgICAgICB3aW5kb3cuZmV0Y2ggPSBvcmlnaW5hbEZldGNoO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByb3h5RmV0Y2goKSB7XG4gICAgaWYgKCF3aW5kb3cuZmV0Y2gpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvcmlnaW5hbEZldGNoID0gd2luZG93LmZldGNoO1xuICAgIHdpbmRvdy5mZXRjaCA9IGZ1bmN0aW9uIChpbnB1dCwgaW5pdCkge1xuICAgICAgICB2YXIgcmVzcG9uc2VQcm9taXNlO1xuICAgICAgICB2YXIgY29udGV4dCA9IGNhbGxNb25pdG9yZWQoYmVmb3JlU2VuZCwgbnVsbCwgW2lucHV0LCBpbml0XSk7XG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICByZXNwb25zZVByb21pc2UgPSBvcmlnaW5hbEZldGNoLmNhbGwodGhpcywgY29udGV4dC5pbnB1dCwgY29udGV4dC5pbml0KTtcbiAgICAgICAgICAgIGNhbGxNb25pdG9yZWQoYWZ0ZXJTZW5kLCBudWxsLCBbcmVzcG9uc2VQcm9taXNlLCBjb250ZXh0XSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNwb25zZVByb21pc2UgPSBvcmlnaW5hbEZldGNoLmNhbGwodGhpcywgaW5wdXQsIGluaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZVByb21pc2U7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJlZm9yZVNlbmQoaW5wdXQsIGluaXQpIHtcbiAgICB2YXIgbWV0aG9kID0gKGluaXQgJiYgaW5pdC5tZXRob2QpIHx8ICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0Lm1ldGhvZCkgfHwgJ0dFVCc7XG4gICAgdmFyIHVybCA9IG5vcm1hbGl6ZVVybCgodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dC51cmwpIHx8IGlucHV0KTtcbiAgICB2YXIgc3RhcnRUaW1lID0gcmVsYXRpdmVOb3coKTtcbiAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgaW5pdDogaW5pdCxcbiAgICAgICAgaW5wdXQ6IGlucHV0LFxuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgICAgIHVybDogdXJsLFxuICAgIH07XG4gICAgYmVmb3JlU2VuZENhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykgeyByZXR1cm4gY2FsbGJhY2soY29udGV4dCk7IH0pO1xuICAgIHJldHVybiBjb250ZXh0O1xufVxuZnVuY3Rpb24gYWZ0ZXJTZW5kKHJlc3BvbnNlUHJvbWlzZSwgY29udGV4dCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIHJlcG9ydEZldGNoID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ZXh0LCBlXzE7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZHVyYXRpb24gPSBlbGFwc2VkKGNvbnRleHQuc3RhcnRUaW1lLCByZWxhdGl2ZU5vdygpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoJ3N0YWNrJyBpbiByZXNwb25zZSB8fCByZXNwb25zZSBpbnN0YW5jZW9mIEVycm9yKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3RhdHVzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZXNwb25zZSA9IHRvU3RhY2tUcmFjZVN0cmluZyhjb21wdXRlU3RhY2tUcmFjZShyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmlzQWJvcnRlZCA9IHJlc3BvbnNlIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uICYmIHJlc3BvbnNlLmNvZGUgPT09IERPTUV4Y2VwdGlvbi5BQk9SVF9FUlI7XG4gICAgICAgICAgICAgICAgICAgIG9uUmVxdWVzdENvbXBsZXRlQ2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHJldHVybiBjYWxsYmFjayhjb250ZXh0KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoJ3N0YXR1cycgaW4gcmVzcG9uc2UpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsyLCA0LCAsIDVdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzcG9uc2UuY2xvbmUoKS50ZXh0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBlXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSBcIlVuYWJsZSB0byByZXRyaWV2ZSByZXNwb25zZTogXCIgKyBlXzE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZXNwb25zZSA9IHRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVzcG9uc2VUeXBlID0gcmVzcG9uc2UudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdGF0dXMgPSByZXNwb25zZS5zdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuaXNBYm9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIG9uUmVxdWVzdENvbXBsZXRlQ2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHJldHVybiBjYWxsYmFjayhjb250ZXh0KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNjtcbiAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7IH07XG4gICAgcmVzcG9uc2VQcm9taXNlLnRoZW4obW9uaXRvcihyZXBvcnRGZXRjaCksIG1vbml0b3IocmVwb3J0RmV0Y2gpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoUHJveHkuanMubWFwIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tIFwidHNsaWJcIjtcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVyc2NvcmUtZGFuZ2xlICovXG5pbXBvcnQgeyBtb25pdG9yLCBjYWxsTW9uaXRvcmVkIH0gZnJvbSAnLi4vZG9tYWluL2ludGVybmFsTW9uaXRvcmluZyc7XG5pbXBvcnQgeyBlbGFwc2VkLCByZWxhdGl2ZU5vdyB9IGZyb20gJy4uL3Rvb2xzL3RpbWVVdGlscyc7XG5pbXBvcnQgeyBub3JtYWxpemVVcmwgfSBmcm9tICcuLi90b29scy91cmxQb2x5ZmlsbCc7XG52YXIgeGhyUHJveHlTaW5nbGV0b247XG52YXIgYmVmb3JlU2VuZENhbGxiYWNrcyA9IFtdO1xudmFyIG9uUmVxdWVzdENvbXBsZXRlQ2FsbGJhY2tzID0gW107XG52YXIgb3JpZ2luYWxYaHJPcGVuO1xudmFyIG9yaWdpbmFsWGhyU2VuZDtcbnZhciBvcmlnaW5hbFhockFib3J0O1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0WGhyUHJveHkoKSB7XG4gICAgaWYgKCF4aHJQcm94eVNpbmdsZXRvbikge1xuICAgICAgICBwcm94eVhocigpO1xuICAgICAgICB4aHJQcm94eVNpbmdsZXRvbiA9IHtcbiAgICAgICAgICAgIGJlZm9yZVNlbmQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGJlZm9yZVNlbmRDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZXF1ZXN0Q29tcGxldGU6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIG9uUmVxdWVzdENvbXBsZXRlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHhoclByb3h5U2luZ2xldG9uO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0WGhyUHJveHkoKSB7XG4gICAgaWYgKHhoclByb3h5U2luZ2xldG9uKSB7XG4gICAgICAgIHhoclByb3h5U2luZ2xldG9uID0gdW5kZWZpbmVkO1xuICAgICAgICBiZWZvcmVTZW5kQ2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICAgIG9uUmVxdWVzdENvbXBsZXRlQ2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5vcGVuID0gb3JpZ2luYWxYaHJPcGVuO1xuICAgICAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuc2VuZCA9IG9yaWdpbmFsWGhyU2VuZDtcbiAgICAgICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gb3JpZ2luYWxYaHJBYm9ydDtcbiAgICB9XG59XG5mdW5jdGlvbiBwcm94eVhocigpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgb3JpZ2luYWxYaHJPcGVuID0gWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLm9wZW47XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgIG9yaWdpbmFsWGhyU2VuZCA9IFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5zZW5kO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICBvcmlnaW5hbFhockFib3J0ID0gWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLmFib3J0O1xuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKG1ldGhvZCwgdXJsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNhbGxNb25pdG9yZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gV0FSTjogc2luY2UgdGhpcyBkYXRhIHN0cnVjdHVyZSBpcyB0aWVkIHRvIHRoZSBpbnN0YW5jZSwgaXQgaXMgc2hhcmVkIGJ5IGJvdGggbG9ncyBhbmQgcnVtXG4gICAgICAgICAgICAvLyBhbmQgY2FuIGJlIHVzZWQgYnkgZGlmZmVyZW50IGNvZGUgdmVyc2lvbnMgZGVwZW5kaW5nIG9uIGN1c3RvbWVyIHNldHVwXG4gICAgICAgICAgICAvLyBzbyBpdCBzaG91bGQgc3RheSBjb21wYXRpYmxlIHdpdGggb2xkZXIgdmVyc2lvbnNcbiAgICAgICAgICAgIF90aGlzLl9kYXRhZG9nX3hociA9IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWU6IC0xLFxuICAgICAgICAgICAgICAgIHVybDogbm9ybWFsaXplVXJsKHVybCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsWGhyT3Blbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNhbGxNb25pdG9yZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLl9kYXRhZG9nX3hocikge1xuICAgICAgICAgICAgICAgIHZhciB4aHJQZW5kaW5nQ29udGV4dF8xID0gX3RoaXMuX2RhdGFkb2dfeGhyO1xuICAgICAgICAgICAgICAgIHhoclBlbmRpbmdDb250ZXh0XzEuc3RhcnRUaW1lID0gcmVsYXRpdmVOb3coKTtcbiAgICAgICAgICAgICAgICB4aHJQZW5kaW5nQ29udGV4dF8xLmlzQWJvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbE9ucmVhZHlzdGF0ZWNoYW5nZV8xID0gX3RoaXMub25yZWFkeXN0YXRlY2hhbmdlO1xuICAgICAgICAgICAgICAgIF90aGlzLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gWE1MSHR0cFJlcXVlc3QuRE9ORSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHJlcG9ydCB0aGUgWEhSIGFzIHNvb24gYXMgcG9zc2libGUsIGJlY2F1c2UgdGhlIFhIUiBtYXkgYmUgbXV0YXRlZCBieSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFwcGxpY2F0aW9uIGR1cmluZyBhIGZ1dHVyZSBldmVudC4gRm9yIGV4YW1wbGUsIEFuZ3VsYXIgaXMgY2FsbGluZyAuYWJvcnQoKSBvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tcGxldGVkIHJlcXVlc3RzIGR1cmluZyBhIG9ucmVhZHlzdGF0ZWNoYW5nZSBldmVudCwgc28gdGhlIHN0YXR1cyBiZWNvbWVzICcwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmVmb3JlIHRoZSByZXF1ZXN0IGlzIGNvbGxlY3RlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxNb25pdG9yZWQocmVwb3J0WGhyXzEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbE9ucmVhZHlzdGF0ZWNoYW5nZV8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbE9ucmVhZHlzdGF0ZWNoYW5nZV8xLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBoYXNCZWVuUmVwb3J0ZWRfMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciByZXBvcnRYaHJfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0JlZW5SZXBvcnRlZF8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFzQmVlblJlcG9ydGVkXzEgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeGhyQ29tcGxldGVDb250ZXh0ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHhoclBlbmRpbmdDb250ZXh0XzEpLCB7IGR1cmF0aW9uOiBlbGFwc2VkKHhoclBlbmRpbmdDb250ZXh0XzEuc3RhcnRUaW1lLCByZWxhdGl2ZU5vdygpKSwgcmVzcG9uc2U6IF90aGlzLnJlc3BvbnNlLCBzdGF0dXM6IF90aGlzLnN0YXR1cyB9KTtcbiAgICAgICAgICAgICAgICAgICAgb25SZXF1ZXN0Q29tcGxldGVDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHsgcmV0dXJuIGNhbGxiYWNrKHhockNvbXBsZXRlQ29udGV4dCk7IH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX3RoaXMuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIG1vbml0b3IocmVwb3J0WGhyXzEpKTtcbiAgICAgICAgICAgICAgICBiZWZvcmVTZW5kQ2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHJldHVybiBjYWxsYmFjayh4aHJQZW5kaW5nQ29udGV4dF8xLCBfdGhpcyk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsWGhyU2VuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjYWxsTW9uaXRvcmVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fZGF0YWRvZ194aHIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZGF0YWRvZ194aHIuaXNBYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFhockFib3J0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXhoclByb3h5LmpzLm1hcCIsImltcG9ydCB7IF9fYXNzaWduLCBfX3NwcmVhZEFycmF5cyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgcmVzZXRGZXRjaFByb3h5LCBzdGFydEZldGNoUHJveHkgfSBmcm9tICcuLi9icm93c2VyL2ZldGNoUHJveHknO1xuaW1wb3J0IHsgcmVzZXRYaHJQcm94eSwgc3RhcnRYaHJQcm94eSB9IGZyb20gJy4uL2Jyb3dzZXIveGhyUHJveHknO1xuaW1wb3J0IHsgRXJyb3JTb3VyY2UsIGZvcm1hdFVua25vd25FcnJvciwgdG9TdGFja1RyYWNlU3RyaW5nLCBmb3JtYXRFcnJvck1lc3NhZ2UgfSBmcm9tICcuLi90b29scy9lcnJvcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vdG9vbHMvb2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyByZWxhdGl2ZU5vdyB9IGZyb20gJy4uL3Rvb2xzL3RpbWVVdGlscyc7XG5pbXBvcnQgeyBqc29uU3RyaW5naWZ5LCBPTkVfTUlOVVRFLCBSZXF1ZXN0VHlwZSwgZmluZCB9IGZyb20gJy4uL3Rvb2xzL3V0aWxzJztcbmltcG9ydCB7IG1vbml0b3IgfSBmcm9tICcuL2ludGVybmFsTW9uaXRvcmluZyc7XG5pbXBvcnQgeyBjb21wdXRlU3RhY2tUcmFjZSwgc3Vic2NyaWJlLCB1bnN1YnNjcmliZSB9IGZyb20gJy4vdHJhY2VraXQnO1xudmFyIGZpbHRlcmVkRXJyb3JzT2JzZXJ2YWJsZTtcbmV4cG9ydCBmdW5jdGlvbiBzdGFydEF1dG9tYXRpY0Vycm9yQ29sbGVjdGlvbihjb25maWd1cmF0aW9uKSB7XG4gICAgaWYgKCFmaWx0ZXJlZEVycm9yc09ic2VydmFibGUpIHtcbiAgICAgICAgdmFyIGVycm9yT2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRyYWNrTmV0d29ya0Vycm9yKGNvbmZpZ3VyYXRpb24sIGVycm9yT2JzZXJ2YWJsZSk7XG4gICAgICAgIHN0YXJ0Q29uc29sZVRyYWNraW5nKGVycm9yT2JzZXJ2YWJsZSk7XG4gICAgICAgIHN0YXJ0UnVudGltZUVycm9yVHJhY2tpbmcoZXJyb3JPYnNlcnZhYmxlKTtcbiAgICAgICAgZmlsdGVyZWRFcnJvcnNPYnNlcnZhYmxlID0gZmlsdGVyRXJyb3JzKGNvbmZpZ3VyYXRpb24sIGVycm9yT2JzZXJ2YWJsZSk7XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJlZEVycm9yc09ic2VydmFibGU7XG59XG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyRXJyb3JzKGNvbmZpZ3VyYXRpb24sIGVycm9yT2JzZXJ2YWJsZSkge1xuICAgIHZhciBlcnJvckNvdW50ID0gMDtcbiAgICB2YXIgZmlsdGVyZWRFcnJvck9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgpO1xuICAgIGVycm9yT2JzZXJ2YWJsZS5zdWJzY3JpYmUoZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvckNvdW50IDwgY29uZmlndXJhdGlvbi5tYXhFcnJvcnNCeU1pbnV0ZSkge1xuICAgICAgICAgICAgZXJyb3JDb3VudCArPSAxO1xuICAgICAgICAgICAgZmlsdGVyZWRFcnJvck9ic2VydmFibGUubm90aWZ5KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlcnJvckNvdW50ID09PSBjb25maWd1cmF0aW9uLm1heEVycm9yc0J5TWludXRlKSB7XG4gICAgICAgICAgICBlcnJvckNvdW50ICs9IDE7XG4gICAgICAgICAgICBmaWx0ZXJlZEVycm9yT2JzZXJ2YWJsZS5ub3RpZnkoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiUmVhY2hlZCBtYXggbnVtYmVyIG9mIGVycm9ycyBieSBtaW51dGU6IFwiICsgY29uZmlndXJhdGlvbi5tYXhFcnJvcnNCeU1pbnV0ZSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IEVycm9yU291cmNlLkFHRU5ULFxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogcmVsYXRpdmVOb3coKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkgeyByZXR1cm4gKGVycm9yQ291bnQgPSAwKTsgfSwgT05FX01JTlVURSk7XG4gICAgcmV0dXJuIGZpbHRlcmVkRXJyb3JPYnNlcnZhYmxlO1xufVxudmFyIG9yaWdpbmFsQ29uc29sZUVycm9yO1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0Q29uc29sZVRyYWNraW5nKGVycm9yT2JzZXJ2YWJsZSkge1xuICAgIG9yaWdpbmFsQ29uc29sZUVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICBjb25zb2xlLmVycm9yID0gbW9uaXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHBhcmFtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIG9yaWdpbmFsQ29uc29sZUVycm9yLmFwcGx5KGNvbnNvbGUsIHBhcmFtcyk7XG4gICAgICAgIGVycm9yT2JzZXJ2YWJsZS5ub3RpZnkoX19hc3NpZ24oX19hc3NpZ24oe30sIGJ1aWxkRXJyb3JGcm9tUGFyYW1zKHBhcmFtcykpLCB7IHNvdXJjZTogRXJyb3JTb3VyY2UuQ09OU09MRSwgc3RhcnRUaW1lOiByZWxhdGl2ZU5vdygpIH0pKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXJyb3JGcm9tUGFyYW1zKHBhcmFtcykge1xuICAgIHZhciBmaXJzdEVycm9yUGFyYW0gPSBmaW5kKHBhcmFtcywgZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbSBpbnN0YW5jZW9mIEVycm9yOyB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtZXNzYWdlOiBfX3NwcmVhZEFycmF5cyhbJ2NvbnNvbGUgZXJyb3I6J10sIHBhcmFtcykubWFwKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gZm9ybWF0Q29uc29sZVBhcmFtZXRlcnMocGFyYW0pOyB9KS5qb2luKCcgJyksXG4gICAgICAgIHN0YWNrOiBmaXJzdEVycm9yUGFyYW0gPyB0b1N0YWNrVHJhY2VTdHJpbmcoY29tcHV0ZVN0YWNrVHJhY2UoZmlyc3RFcnJvclBhcmFtKSkgOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdG9wQ29uc29sZVRyYWNraW5nKCkge1xuICAgIGNvbnNvbGUuZXJyb3IgPSBvcmlnaW5hbENvbnNvbGVFcnJvcjtcbn1cbmZ1bmN0aW9uIGZvcm1hdENvbnNvbGVQYXJhbWV0ZXJzKHBhcmFtKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgIH1cbiAgICBpZiAocGFyYW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gZm9ybWF0RXJyb3JNZXNzYWdlKGNvbXB1dGVTdGFja1RyYWNlKHBhcmFtKSk7XG4gICAgfVxuICAgIHJldHVybiBqc29uU3RyaW5naWZ5KHBhcmFtLCB1bmRlZmluZWQsIDIpO1xufVxudmFyIHRyYWNlS2l0UmVwb3J0SGFuZGxlcjtcbmV4cG9ydCBmdW5jdGlvbiBzdGFydFJ1bnRpbWVFcnJvclRyYWNraW5nKGVycm9yT2JzZXJ2YWJsZSkge1xuICAgIHRyYWNlS2l0UmVwb3J0SGFuZGxlciA9IGZ1bmN0aW9uIChzdGFja1RyYWNlLCBfLCBlcnJvck9iamVjdCkge1xuICAgICAgICB2YXIgX2EgPSBmb3JtYXRVbmtub3duRXJyb3Ioc3RhY2tUcmFjZSwgZXJyb3JPYmplY3QsICdVbmNhdWdodCcpLCBzdGFjayA9IF9hLnN0YWNrLCBtZXNzYWdlID0gX2EubWVzc2FnZSwgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgIGVycm9yT2JzZXJ2YWJsZS5ub3RpZnkoe1xuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgIHN0YWNrOiBzdGFjayxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBzb3VyY2U6IEVycm9yU291cmNlLlNPVVJDRSxcbiAgICAgICAgICAgIHN0YXJ0VGltZTogcmVsYXRpdmVOb3coKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBzdWJzY3JpYmUodHJhY2VLaXRSZXBvcnRIYW5kbGVyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdG9wUnVudGltZUVycm9yVHJhY2tpbmcoKSB7XG4gICAgdW5zdWJzY3JpYmUodHJhY2VLaXRSZXBvcnRIYW5kbGVyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0cmFja05ldHdvcmtFcnJvcihjb25maWd1cmF0aW9uLCBlcnJvck9ic2VydmFibGUpIHtcbiAgICBzdGFydFhoclByb3h5KCkub25SZXF1ZXN0Q29tcGxldGUoZnVuY3Rpb24gKGNvbnRleHQpIHsgcmV0dXJuIGhhbmRsZUNvbXBsZXRlUmVxdWVzdChSZXF1ZXN0VHlwZS5YSFIsIGNvbnRleHQpOyB9KTtcbiAgICBzdGFydEZldGNoUHJveHkoKS5vblJlcXVlc3RDb21wbGV0ZShmdW5jdGlvbiAoY29udGV4dCkgeyByZXR1cm4gaGFuZGxlQ29tcGxldGVSZXF1ZXN0KFJlcXVlc3RUeXBlLkZFVENILCBjb250ZXh0KTsgfSk7XG4gICAgZnVuY3Rpb24gaGFuZGxlQ29tcGxldGVSZXF1ZXN0KHR5cGUsIHJlcXVlc3QpIHtcbiAgICAgICAgaWYgKCFjb25maWd1cmF0aW9uLmlzSW50YWtlVXJsKHJlcXVlc3QudXJsKSAmJlxuICAgICAgICAgICAgKCFjb25maWd1cmF0aW9uLmlzRW5hYmxlZCgncmVtb3ZlLW5ldHdvcmstZXJyb3JzJykgfHwgIXJlcXVlc3QuaXNBYm9ydGVkKSAmJlxuICAgICAgICAgICAgKGlzUmVqZWN0ZWQocmVxdWVzdCkgfHwgaXNTZXJ2ZXJFcnJvcihyZXF1ZXN0KSkpIHtcbiAgICAgICAgICAgIGVycm9yT2JzZXJ2YWJsZS5ub3RpZnkoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGZvcm1hdCh0eXBlKSArIFwiIGVycm9yIFwiICsgcmVxdWVzdC5tZXRob2QgKyBcIiBcIiArIHJlcXVlc3QudXJsLFxuICAgICAgICAgICAgICAgIHJlc291cmNlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHJlcXVlc3QudXJsLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc291cmNlOiBFcnJvclNvdXJjZS5ORVRXT1JLLFxuICAgICAgICAgICAgICAgIHN0YWNrOiB0cnVuY2F0ZVJlc3BvbnNlKHJlcXVlc3QucmVzcG9uc2UsIGNvbmZpZ3VyYXRpb24pIHx8ICdGYWlsZWQgdG8gbG9hZCcsXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lOiByZXF1ZXN0LnN0YXJ0VGltZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc2V0WGhyUHJveHkoKTtcbiAgICAgICAgICAgIHJlc2V0RmV0Y2hQcm94eSgpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBpc1JlamVjdGVkKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gcmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgcmVxdWVzdC5yZXNwb25zZVR5cGUgIT09ICdvcGFxdWUnO1xufVxuZnVuY3Rpb24gaXNTZXJ2ZXJFcnJvcihyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHJlcXVlc3Quc3RhdHVzID49IDUwMDtcbn1cbmZ1bmN0aW9uIHRydW5jYXRlUmVzcG9uc2UocmVzcG9uc2UsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UubGVuZ3RoID4gY29uZmlndXJhdGlvbi5yZXF1ZXN0RXJyb3JSZXNwb25zZUxlbmd0aExpbWl0KSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5zdWJzdHJpbmcoMCwgY29uZmlndXJhdGlvbi5yZXF1ZXN0RXJyb3JSZXNwb25zZUxlbmd0aExpbWl0KSArIFwiLi4uXCI7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbn1cbmZ1bmN0aW9uIGZvcm1hdCh0eXBlKSB7XG4gICAgaWYgKFJlcXVlc3RUeXBlLlhIUiA9PT0gdHlwZSkge1xuICAgICAgICByZXR1cm4gJ1hIUic7XG4gICAgfVxuICAgIHJldHVybiAnRmV0Y2gnO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0b21hdGljRXJyb3JDb2xsZWN0aW9uLmpzLm1hcCIsImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBnZXRDdXJyZW50U2l0ZSB9IGZyb20gJy4uL2Jyb3dzZXIvY29va2llJztcbmltcG9ydCB7IGNhdGNoVXNlckVycm9ycyB9IGZyb20gJy4uL3Rvb2xzL2NhdGNoVXNlckVycm9ycyc7XG5pbXBvcnQgeyBpbmNsdWRlcywgT05FX0tJTE9fQllURSwgT05FX1NFQ09ORCB9IGZyb20gJy4uL3Rvb2xzL3V0aWxzJztcbmltcG9ydCB7IGNvbXB1dGVUcmFuc3BvcnRDb25maWd1cmF0aW9uIH0gZnJvbSAnLi90cmFuc3BvcnRDb25maWd1cmF0aW9uJztcbmV4cG9ydCB2YXIgREVGQVVMVF9DT05GSUdVUkFUSU9OID0ge1xuICAgIGFsbG93ZWRUcmFjaW5nT3JpZ2luczogW10sXG4gICAgbWF4RXJyb3JzQnlNaW51dGU6IDMwMDAsXG4gICAgbWF4SW50ZXJuYWxNb25pdG9yaW5nTWVzc2FnZXNQZXJQYWdlOiAxNSxcbiAgICByZXNvdXJjZVNhbXBsZVJhdGU6IDEwMCxcbiAgICBzYW1wbGVSYXRlOiAxMDAsXG4gICAgc2lsZW50TXVsdGlwbGVJbml0OiBmYWxzZSxcbiAgICB0cmFja0ludGVyYWN0aW9uczogZmFsc2UsXG4gICAgLyoqXG4gICAgICogYXJiaXRyYXJ5IHZhbHVlLCBieXRlIHByZWNpc2lvbiBub3QgbmVlZGVkXG4gICAgICovXG4gICAgcmVxdWVzdEVycm9yUmVzcG9uc2VMZW5ndGhMaW1pdDogMzIgKiBPTkVfS0lMT19CWVRFLFxuICAgIC8qKlxuICAgICAqIGZsdXNoIGF1dG9tYXRpY2FsbHksIGFpbSB0byBiZSBsb3dlciB0aGFuIEFMQiBjb25uZWN0aW9uIHRpbWVvdXRcbiAgICAgKiB0byBtYXhpbWl6ZSBjb25uZWN0aW9uIHJldXNlLlxuICAgICAqL1xuICAgIGZsdXNoVGltZW91dDogMzAgKiBPTkVfU0VDT05ELFxuICAgIC8qKlxuICAgICAqIExvZ3MgaW50YWtlIGxpbWl0XG4gICAgICovXG4gICAgbWF4QmF0Y2hTaXplOiA1MCxcbiAgICBtYXhNZXNzYWdlU2l6ZTogMjU2ICogT05FX0tJTE9fQllURSxcbiAgICAvKipcbiAgICAgKiBiZWFjb24gcGF5bG9hZCBtYXggcXVldWUgc2l6ZSBpbXBsZW1lbnRhdGlvbiBpcyA2NGtiXG4gICAgICogZW5zdXJlIHRoYXQgd2UgbGVhdmUgcm9vbSBmb3IgbG9ncywgcnVtIGFuZCBwb3RlbnRpYWwgb3RoZXIgdXNlcnNcbiAgICAgKi9cbiAgICBiYXRjaEJ5dGVzTGltaXQ6IDE2ICogT05FX0tJTE9fQllURSxcbn07XG5leHBvcnQgZnVuY3Rpb24gYnVpbGRDb25maWd1cmF0aW9uKHVzZXJDb25maWd1cmF0aW9uLCBidWlsZEVudikge1xuICAgIHZhciBlbmFibGVFeHBlcmltZW50YWxGZWF0dXJlcyA9IEFycmF5LmlzQXJyYXkodXNlckNvbmZpZ3VyYXRpb24uZW5hYmxlRXhwZXJpbWVudGFsRmVhdHVyZXMpXG4gICAgICAgID8gdXNlckNvbmZpZ3VyYXRpb24uZW5hYmxlRXhwZXJpbWVudGFsRmVhdHVyZXNcbiAgICAgICAgOiBbXTtcbiAgICB2YXIgY29uZmlndXJhdGlvbiA9IF9fYXNzaWduKF9fYXNzaWduKHsgYmVmb3JlU2VuZDogdXNlckNvbmZpZ3VyYXRpb24uYmVmb3JlU2VuZCAmJiBjYXRjaFVzZXJFcnJvcnModXNlckNvbmZpZ3VyYXRpb24uYmVmb3JlU2VuZCwgJ2JlZm9yZVNlbmQgdGhyZXcgYW4gZXJyb3I6JyksIGNvb2tpZU9wdGlvbnM6IGJ1aWxkQ29va2llT3B0aW9ucyh1c2VyQ29uZmlndXJhdGlvbiksIGlzRW5hYmxlZDogZnVuY3Rpb24gKGZlYXR1cmUpIHsgcmV0dXJuIGluY2x1ZGVzKGVuYWJsZUV4cGVyaW1lbnRhbEZlYXR1cmVzLCBmZWF0dXJlKTsgfSwgc2VydmljZTogdXNlckNvbmZpZ3VyYXRpb24uc2VydmljZSB9LCBjb21wdXRlVHJhbnNwb3J0Q29uZmlndXJhdGlvbih1c2VyQ29uZmlndXJhdGlvbiwgYnVpbGRFbnYpKSwgREVGQVVMVF9DT05GSUdVUkFUSU9OKTtcbiAgICBpZiAoJ2FsbG93ZWRUcmFjaW5nT3JpZ2lucycgaW4gdXNlckNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgY29uZmlndXJhdGlvbi5hbGxvd2VkVHJhY2luZ09yaWdpbnMgPSB1c2VyQ29uZmlndXJhdGlvbi5hbGxvd2VkVHJhY2luZ09yaWdpbnM7XG4gICAgfVxuICAgIGlmICgnc2FtcGxlUmF0ZScgaW4gdXNlckNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgY29uZmlndXJhdGlvbi5zYW1wbGVSYXRlID0gdXNlckNvbmZpZ3VyYXRpb24uc2FtcGxlUmF0ZTtcbiAgICB9XG4gICAgaWYgKCdyZXNvdXJjZVNhbXBsZVJhdGUnIGluIHVzZXJDb25maWd1cmF0aW9uKSB7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24ucmVzb3VyY2VTYW1wbGVSYXRlID0gdXNlckNvbmZpZ3VyYXRpb24ucmVzb3VyY2VTYW1wbGVSYXRlO1xuICAgIH1cbiAgICBpZiAoJ3RyYWNrSW50ZXJhY3Rpb25zJyBpbiB1c2VyQ29uZmlndXJhdGlvbikge1xuICAgICAgICBjb25maWd1cmF0aW9uLnRyYWNrSW50ZXJhY3Rpb25zID0gISF1c2VyQ29uZmlndXJhdGlvbi50cmFja0ludGVyYWN0aW9ucztcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb247XG59XG5leHBvcnQgZnVuY3Rpb24gYnVpbGRDb29raWVPcHRpb25zKHVzZXJDb25maWd1cmF0aW9uKSB7XG4gICAgdmFyIGNvb2tpZU9wdGlvbnMgPSB7fTtcbiAgICBjb29raWVPcHRpb25zLnNlY3VyZSA9IG11c3RVc2VTZWN1cmVDb29raWUodXNlckNvbmZpZ3VyYXRpb24pO1xuICAgIGNvb2tpZU9wdGlvbnMuY3Jvc3NTaXRlID0gISF1c2VyQ29uZmlndXJhdGlvbi51c2VDcm9zc1NpdGVTZXNzaW9uQ29va2llO1xuICAgIGlmICghIXVzZXJDb25maWd1cmF0aW9uLnRyYWNrU2Vzc2lvbkFjcm9zc1N1YmRvbWFpbnMpIHtcbiAgICAgICAgY29va2llT3B0aW9ucy5kb21haW4gPSBnZXRDdXJyZW50U2l0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gY29va2llT3B0aW9ucztcbn1cbmZ1bmN0aW9uIG11c3RVc2VTZWN1cmVDb29raWUodXNlckNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4gISF1c2VyQ29uZmlndXJhdGlvbi51c2VTZWN1cmVTZXNzaW9uQ29va2llIHx8ICEhdXNlckNvbmZpZ3VyYXRpb24udXNlQ3Jvc3NTaXRlU2Vzc2lvbkNvb2tpZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmZpZ3VyYXRpb24uanMubWFwIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGNvbWJpbmUgfSBmcm9tICcuLi90b29scy9jb250ZXh0JztcbmltcG9ydCB7IHRvU3RhY2tUcmFjZVN0cmluZyB9IGZyb20gJy4uL3Rvb2xzL2Vycm9yJztcbmltcG9ydCB7IGFzc2lnbiwganNvblN0cmluZ2lmeSwgT05FX01JTlVURSwgT05FX1NFQ09ORCB9IGZyb20gJy4uL3Rvb2xzL3V0aWxzJztcbmltcG9ydCB7IGdldFRpbWVTdGFtcCwgcmVsYXRpdmVOb3cgfSBmcm9tICcuLi90b29scy90aW1lVXRpbHMnO1xuaW1wb3J0IHsgQmF0Y2gsIEh0dHBSZXF1ZXN0IH0gZnJvbSAnLi4vdHJhbnNwb3J0L3RyYW5zcG9ydCc7XG5pbXBvcnQgeyBjb21wdXRlU3RhY2tUcmFjZSB9IGZyb20gJy4vdHJhY2VraXQnO1xudmFyIFN0YXR1c1R5cGU7XG4oZnVuY3Rpb24gKFN0YXR1c1R5cGUpIHtcbiAgICBTdGF0dXNUeXBlW1wiaW5mb1wiXSA9IFwiaW5mb1wiO1xuICAgIFN0YXR1c1R5cGVbXCJlcnJvclwiXSA9IFwiZXJyb3JcIjtcbn0pKFN0YXR1c1R5cGUgfHwgKFN0YXR1c1R5cGUgPSB7fSkpO1xudmFyIG1vbml0b3JpbmdDb25maWd1cmF0aW9uID0geyBtYXhNZXNzYWdlc1BlclBhZ2U6IDAsIHNlbnRNZXNzYWdlQ291bnQ6IDAgfTtcbnZhciBleHRlcm5hbENvbnRleHRQcm92aWRlcjtcbmV4cG9ydCBmdW5jdGlvbiBzdGFydEludGVybmFsTW9uaXRvcmluZyhjb25maWd1cmF0aW9uKSB7XG4gICAgaWYgKGNvbmZpZ3VyYXRpb24uaW50ZXJuYWxNb25pdG9yaW5nRW5kcG9pbnQpIHtcbiAgICAgICAgdmFyIGJhdGNoID0gc3RhcnRNb25pdG9yaW5nQmF0Y2goY29uZmlndXJhdGlvbik7XG4gICAgICAgIGFzc2lnbihtb25pdG9yaW5nQ29uZmlndXJhdGlvbiwge1xuICAgICAgICAgICAgYmF0Y2g6IGJhdGNoLFxuICAgICAgICAgICAgbWF4TWVzc2FnZXNQZXJQYWdlOiBjb25maWd1cmF0aW9uLm1heEludGVybmFsTW9uaXRvcmluZ01lc3NhZ2VzUGVyUGFnZSxcbiAgICAgICAgICAgIHNlbnRNZXNzYWdlQ291bnQ6IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBzdGFydE1vbml0b3JpbmdDbG9ja0RyaWZ0KCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNldEV4dGVybmFsQ29udGV4dFByb3ZpZGVyOiBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGV4dGVybmFsQ29udGV4dFByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN0YXJ0TW9uaXRvcmluZ0JhdGNoKGNvbmZpZ3VyYXRpb24pIHtcbiAgICB2YXIgcHJpbWFyeUJhdGNoID0gY3JlYXRlTW9uaXRvcmluZ0JhdGNoKGNvbmZpZ3VyYXRpb24uaW50ZXJuYWxNb25pdG9yaW5nRW5kcG9pbnQpO1xuICAgIHZhciByZXBsaWNhQmF0Y2g7XG4gICAgaWYgKGNvbmZpZ3VyYXRpb24ucmVwbGljYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcGxpY2FCYXRjaCA9IGNyZWF0ZU1vbml0b3JpbmdCYXRjaChjb25maWd1cmF0aW9uLnJlcGxpY2EuaW50ZXJuYWxNb25pdG9yaW5nRW5kcG9pbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVNb25pdG9yaW5nQmF0Y2goZW5kcG9pbnRVcmwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCYXRjaChuZXcgSHR0cFJlcXVlc3QoZW5kcG9pbnRVcmwsIGNvbmZpZ3VyYXRpb24uYmF0Y2hCeXRlc0xpbWl0KSwgY29uZmlndXJhdGlvbi5tYXhCYXRjaFNpemUsIGNvbmZpZ3VyYXRpb24uYmF0Y2hCeXRlc0xpbWl0LCBjb25maWd1cmF0aW9uLm1heE1lc3NhZ2VTaXplLCBjb25maWd1cmF0aW9uLmZsdXNoVGltZW91dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdpdGhDb250ZXh0KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmUoe1xuICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS5nZXRUaW1lKCksXG4gICAgICAgICAgICB2aWV3OiB7XG4gICAgICAgICAgICAgICAgcmVmZXJyZXI6IGRvY3VtZW50LnJlZmVycmVyLFxuICAgICAgICAgICAgICAgIHVybDogd2luZG93LmxvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LCBleHRlcm5hbENvbnRleHRQcm92aWRlciAhPT0gdW5kZWZpbmVkID8gZXh0ZXJuYWxDb250ZXh0UHJvdmlkZXIoKSA6IHt9LCBtZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkOiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHR1YWxpemVkTWVzc2FnZSA9IHdpdGhDb250ZXh0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgcHJpbWFyeUJhdGNoLmFkZChjb250ZXh0dWFsaXplZE1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKHJlcGxpY2FCYXRjaCkge1xuICAgICAgICAgICAgICAgIHJlcGxpY2FCYXRjaC5hZGQoY29udGV4dHVhbGl6ZWRNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0SW50ZXJuYWxNb25pdG9yaW5nKCkge1xuICAgIG1vbml0b3JpbmdDb25maWd1cmF0aW9uLmJhdGNoID0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gc3RhcnRNb25pdG9yaW5nQ2xvY2tEcmlmdCgpIHtcbiAgICB2YXIgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChtb25pdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRyaWZ0ID0gRGF0ZS5ub3coKSAtIGdldFRpbWVTdGFtcChyZWxhdGl2ZU5vdygpKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKGRyaWZ0KSA+IE9ORV9TRUNPTkQpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgdmFyIG5hdmlnYXRpb25TdGFydCA9IGdldFRpbWVTdGFtcCgwKTtcbiAgICAgICAgICAgIGFkZE1vbml0b3JpbmdNZXNzYWdlKCdjbG9jayBkcmlmdCBkZXRlY3RlZCcsIHtcbiAgICAgICAgICAgICAgICBkZWJ1Zzoge1xuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uU3RhcnRVVEM6IG5ldyBEYXRlKG5hdmlnYXRpb25TdGFydCkudG9VVENTdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgdGltZVNwZW50OiBEYXRlLm5vdygpIC0gbmF2aWdhdGlvblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBkcmlmdDogZHJpZnQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSksIE9ORV9NSU5VVEUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1vbml0b3JlZChfLCBfXywgZGVzY3JpcHRvcikge1xuICAgIHZhciBvcmlnaW5hbE1ldGhvZCA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVjb3JhdGVkID0gbW9uaXRvcmluZ0NvbmZpZ3VyYXRpb24uYmF0Y2ggPyBtb25pdG9yKG9yaWdpbmFsTWV0aG9kKSA6IG9yaWdpbmFsTWV0aG9kO1xuICAgICAgICByZXR1cm4gZGVjb3JhdGVkLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gbW9uaXRvcihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICByZXR1cm4gY2FsbE1vbml0b3JlZChmbiwgdGhpcywgYXJndW1lbnRzKTtcbiAgICB9OyAvLyBjb25zaWRlciBvdXRwdXQgdHlwZSBoYXMgaW5wdXQgdHlwZVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNhbGxNb25pdG9yZWQoZm4sIGNvbnRleHQsIGFyZ3MpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBsb2dFcnJvcklmRGVidWcoZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhZGRFcnJvclRvTW9uaXRvcmluZ0JhdGNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dFcnJvcklmRGVidWcoZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYWRkTW9uaXRvcmluZ01lc3NhZ2UobWVzc2FnZSwgY29udGV4dCkge1xuICAgIGxvZ01lc3NhZ2VJZkRlYnVnKG1lc3NhZ2UpO1xuICAgIGFkZFRvTW9uaXRvcmluZ0JhdGNoKF9fYXNzaWduKF9fYXNzaWduKHsgbWVzc2FnZTogbWVzc2FnZSB9LCBjb250ZXh0KSwgeyBzdGF0dXM6IFN0YXR1c1R5cGUuaW5mbyB9KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYWRkRXJyb3JUb01vbml0b3JpbmdCYXRjaChlKSB7XG4gICAgYWRkVG9Nb25pdG9yaW5nQmF0Y2goX19hc3NpZ24oX19hc3NpZ24oe30sIGZvcm1hdEVycm9yKGUpKSwgeyBzdGF0dXM6IFN0YXR1c1R5cGUuZXJyb3IgfSkpO1xufVxuZnVuY3Rpb24gYWRkVG9Nb25pdG9yaW5nQmF0Y2gobWVzc2FnZSkge1xuICAgIGlmIChtb25pdG9yaW5nQ29uZmlndXJhdGlvbi5iYXRjaCAmJlxuICAgICAgICBtb25pdG9yaW5nQ29uZmlndXJhdGlvbi5zZW50TWVzc2FnZUNvdW50IDwgbW9uaXRvcmluZ0NvbmZpZ3VyYXRpb24ubWF4TWVzc2FnZXNQZXJQYWdlKSB7XG4gICAgICAgIG1vbml0b3JpbmdDb25maWd1cmF0aW9uLnNlbnRNZXNzYWdlQ291bnQgKz0gMTtcbiAgICAgICAgbW9uaXRvcmluZ0NvbmZpZ3VyYXRpb24uYmF0Y2guYWRkKG1lc3NhZ2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHZhciBzdGFja1RyYWNlID0gY29tcHV0ZVN0YWNrVHJhY2UoZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgIGtpbmQ6IHN0YWNrVHJhY2UubmFtZSxcbiAgICAgICAgICAgICAgICBzdGFjazogdG9TdGFja1RyYWNlU3RyaW5nKHN0YWNrVHJhY2UpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHN0YWNrVHJhY2UubWVzc2FnZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgIHN0YWNrOiAnTm90IGFuIGluc3RhbmNlIG9mIGVycm9yJyxcbiAgICAgICAgfSxcbiAgICAgICAgbWVzc2FnZTogXCJVbmNhdWdodCBcIiArIGpzb25TdHJpbmdpZnkoZSksXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXREZWJ1Z01vZGUoZGVidWdNb2RlKSB7XG4gICAgbW9uaXRvcmluZ0NvbmZpZ3VyYXRpb24uZGVidWdNb2RlID0gZGVidWdNb2RlO1xufVxuZnVuY3Rpb24gbG9nRXJyb3JJZkRlYnVnKGUpIHtcbiAgICBpZiAobW9uaXRvcmluZ0NvbmZpZ3VyYXRpb24uZGVidWdNb2RlKSB7XG4gICAgICAgIC8vIExvZyBhcyB3YXJuIHRvIG5vdCBmb3J3YXJkIHRoZSBsb2dzLlxuICAgICAgICBjb25zb2xlLndhcm4oJ1tJTlRFUk5BTCBFUlJPUl0nLCBlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsb2dNZXNzYWdlSWZEZWJ1ZyhtZXNzYWdlKSB7XG4gICAgaWYgKG1vbml0b3JpbmdDb25maWd1cmF0aW9uLmRlYnVnTW9kZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnW01PTklUT1JJTkcgTUVTU0FHRV0nLCBtZXNzYWdlKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcm5hbE1vbml0b3JpbmcuanMubWFwIiwiaW1wb3J0IHsgZ2V0Q29va2llIH0gZnJvbSAnLi4vYnJvd3Nlci9jb29raWUnO1xuaW1wb3J0IHsgcGVyc2lzdFNlc3Npb24gfSBmcm9tICcuL3Nlc3Npb25NYW5hZ2VtZW50JztcbmV4cG9ydCB2YXIgT0xEX1NFU1NJT05fQ09PS0lFX05BTUUgPSAnX2RkJztcbmV4cG9ydCB2YXIgT0xEX1JVTV9DT09LSUVfTkFNRSA9ICdfZGRfcic7XG5leHBvcnQgdmFyIE9MRF9MT0dTX0NPT0tJRV9OQU1FID0gJ19kZF9sJztcbi8vIGR1cGxpY2F0ZSB2YWx1ZXMgdG8gYXZvaWQgZGVwZW5kZW5jeSBpc3N1ZXNcbmV4cG9ydCB2YXIgUlVNX1NFU1NJT05fS0VZID0gJ3J1bSc7XG5leHBvcnQgdmFyIExPR1NfU0VTU0lPTl9LRVkgPSAnbG9ncyc7XG4vKipcbiAqIFRoaXMgbWlncmF0aW9uIHNob3VsZCByZW1haW4gaW4gdGhlIGNvZGViYXNlIGFzIGxvbmcgYXMgb2xkZXIgdmVyc2lvbnMgYXJlIGF2YWlsYWJsZS9saXZlXG4gKiB0byBhbGxvdyBvbGRlciBzZGsgdmVyc2lvbnMgdG8gYmUgdXBncmFkZWQgdG8gbmV3ZXIgdmVyc2lvbnMgd2l0aG91dCBjb21wYXRpYmlsaXR5IGlzc3Vlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyeU9sZENvb2tpZXNNaWdyYXRpb24oc2Vzc2lvbkNvb2tpZSkge1xuICAgIHZhciBzZXNzaW9uU3RyaW5nID0gc2Vzc2lvbkNvb2tpZS5nZXQoKTtcbiAgICB2YXIgb2xkU2Vzc2lvbklkID0gZ2V0Q29va2llKE9MRF9TRVNTSU9OX0NPT0tJRV9OQU1FKTtcbiAgICB2YXIgb2xkUnVtVHlwZSA9IGdldENvb2tpZShPTERfUlVNX0NPT0tJRV9OQU1FKTtcbiAgICB2YXIgb2xkTG9nc1R5cGUgPSBnZXRDb29raWUoT0xEX0xPR1NfQ09PS0lFX05BTUUpO1xuICAgIGlmICghc2Vzc2lvblN0cmluZykge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHt9O1xuICAgICAgICBpZiAob2xkU2Vzc2lvbklkKSB7XG4gICAgICAgICAgICBzZXNzaW9uLmlkID0gb2xkU2Vzc2lvbklkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRMb2dzVHlwZSAmJiAvXlswMV0kLy50ZXN0KG9sZExvZ3NUeXBlKSkge1xuICAgICAgICAgICAgc2Vzc2lvbltMT0dTX1NFU1NJT05fS0VZXSA9IG9sZExvZ3NUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRSdW1UeXBlICYmIC9eWzAxMl0kLy50ZXN0KG9sZFJ1bVR5cGUpKSB7XG4gICAgICAgICAgICBzZXNzaW9uW1JVTV9TRVNTSU9OX0tFWV0gPSBvbGRSdW1UeXBlO1xuICAgICAgICB9XG4gICAgICAgIHBlcnNpc3RTZXNzaW9uKHNlc3Npb24sIHNlc3Npb25Db29raWUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9sZENvb2tpZXNNaWdyYXRpb24uanMubWFwIiwiaW1wb3J0IHsgY2FjaGVDb29raWVBY2Nlc3MsIENPT0tJRV9BQ0NFU1NfREVMQVkgfSBmcm9tICcuLi9icm93c2VyL2Nvb2tpZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vdG9vbHMvb2JzZXJ2YWJsZSc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi90b29scy91dGlscyc7XG5pbXBvcnQgeyBtb25pdG9yIH0gZnJvbSAnLi9pbnRlcm5hbE1vbml0b3JpbmcnO1xuaW1wb3J0IHsgdHJ5T2xkQ29va2llc01pZ3JhdGlvbiB9IGZyb20gJy4vb2xkQ29va2llc01pZ3JhdGlvbic7XG5leHBvcnQgdmFyIFNFU1NJT05fQ09PS0lFX05BTUUgPSAnX2RkX3MnO1xuZXhwb3J0IHZhciBTRVNTSU9OX0VYUElSQVRJT05fREVMQVkgPSAxNSAqIHV0aWxzLk9ORV9NSU5VVEU7XG5leHBvcnQgdmFyIFNFU1NJT05fVElNRV9PVVRfREVMQVkgPSA0ICogdXRpbHMuT05FX0hPVVI7XG5leHBvcnQgdmFyIFZJU0lCSUxJVFlfQ0hFQ0tfREVMQVkgPSB1dGlscy5PTkVfTUlOVVRFO1xuLyoqXG4gKiBMaW1pdCBhY2Nlc3MgdG8gY29va2llIHRvIGF2b2lkIHBlcmZvcm1hbmNlIGlzc3Vlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRTZXNzaW9uTWFuYWdlbWVudChvcHRpb25zLCBwcm9kdWN0S2V5LCBjb21wdXRlU2Vzc2lvblN0YXRlKSB7XG4gICAgdmFyIHNlc3Npb25Db29raWUgPSBjYWNoZUNvb2tpZUFjY2VzcyhTRVNTSU9OX0NPT0tJRV9OQU1FLCBvcHRpb25zKTtcbiAgICB0cnlPbGRDb29raWVzTWlncmF0aW9uKHNlc3Npb25Db29raWUpO1xuICAgIHZhciByZW5ld09ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgpO1xuICAgIHZhciBjdXJyZW50U2Vzc2lvbklkID0gcmV0cmlldmVBY3RpdmVTZXNzaW9uKHNlc3Npb25Db29raWUpLmlkO1xuICAgIHZhciBleHBhbmRPclJlbmV3U2Vzc2lvbiA9IHV0aWxzLnRocm90dGxlKG1vbml0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHJldHJpZXZlQWN0aXZlU2Vzc2lvbihzZXNzaW9uQ29va2llKTtcbiAgICAgICAgdmFyIF9hID0gY29tcHV0ZVNlc3Npb25TdGF0ZShzZXNzaW9uW3Byb2R1Y3RLZXldKSwgdHJhY2tpbmdUeXBlID0gX2EudHJhY2tpbmdUeXBlLCBpc1RyYWNrZWQgPSBfYS5pc1RyYWNrZWQ7XG4gICAgICAgIHNlc3Npb25bcHJvZHVjdEtleV0gPSB0cmFja2luZ1R5cGU7XG4gICAgICAgIGlmIChpc1RyYWNrZWQgJiYgIXNlc3Npb24uaWQpIHtcbiAgICAgICAgICAgIHNlc3Npb24uaWQgPSB1dGlscy5nZW5lcmF0ZVVVSUQoKTtcbiAgICAgICAgICAgIHNlc3Npb24uY3JlYXRlZCA9IFN0cmluZyhEYXRlLm5vdygpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzYXZlIGNoYW5nZXMgYW5kIGV4cGFuZCBzZXNzaW9uIGR1cmF0aW9uXG4gICAgICAgIHBlcnNpc3RTZXNzaW9uKHNlc3Npb24sIHNlc3Npb25Db29raWUpO1xuICAgICAgICAvLyBJZiB0aGUgc2Vzc2lvbiBpZCBoYXMgY2hhbmdlZCwgbm90aWZ5IHRoYXQgdGhlIHNlc3Npb24gaGFzIGJlZW4gcmVuZXdlZFxuICAgICAgICBpZiAoaXNUcmFja2VkICYmIGN1cnJlbnRTZXNzaW9uSWQgIT09IHNlc3Npb24uaWQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uSWQgPSBzZXNzaW9uLmlkO1xuICAgICAgICAgICAgcmVuZXdPYnNlcnZhYmxlLm5vdGlmeSgpO1xuICAgICAgICB9XG4gICAgfSksIENPT0tJRV9BQ0NFU1NfREVMQVkpLnRocm90dGxlZDtcbiAgICB2YXIgZXhwYW5kU2Vzc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlc3Npb24gPSByZXRyaWV2ZUFjdGl2ZVNlc3Npb24oc2Vzc2lvbkNvb2tpZSk7XG4gICAgICAgIHBlcnNpc3RTZXNzaW9uKHNlc3Npb24sIHNlc3Npb25Db29raWUpO1xuICAgIH07XG4gICAgZXhwYW5kT3JSZW5ld1Nlc3Npb24oKTtcbiAgICB0cmFja0FjdGl2aXR5KGV4cGFuZE9yUmVuZXdTZXNzaW9uKTtcbiAgICB0cmFja1Zpc2liaWxpdHkoZXhwYW5kU2Vzc2lvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0SWQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJldHJpZXZlQWN0aXZlU2Vzc2lvbihzZXNzaW9uQ29va2llKS5pZDsgfSxcbiAgICAgICAgZ2V0VHJhY2tpbmdUeXBlOiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXRyaWV2ZUFjdGl2ZVNlc3Npb24oc2Vzc2lvbkNvb2tpZSlbcHJvZHVjdEtleV07IH0sXG4gICAgICAgIHJlbmV3T2JzZXJ2YWJsZTogcmVuZXdPYnNlcnZhYmxlLFxuICAgIH07XG59XG52YXIgU0VTU0lPTl9FTlRSWV9SRUdFWFAgPSAvXihbYS16XSspPShbYS16MC05LV0rKSQvO1xudmFyIFNFU1NJT05fRU5UUllfU0VQQVJBVE9SID0gJyYnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRTZXNzaW9uU3RyaW5nKHNlc3Npb25TdHJpbmcpIHtcbiAgICByZXR1cm4gKHNlc3Npb25TdHJpbmcgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAoc2Vzc2lvblN0cmluZy5pbmRleE9mKFNFU1NJT05fRU5UUllfU0VQQVJBVE9SKSAhPT0gLTEgfHwgU0VTU0lPTl9FTlRSWV9SRUdFWFAudGVzdChzZXNzaW9uU3RyaW5nKSkpO1xufVxuZnVuY3Rpb24gcmV0cmlldmVBY3RpdmVTZXNzaW9uKHNlc3Npb25Db29raWUpIHtcbiAgICB2YXIgc2Vzc2lvbiA9IHJldHJpZXZlU2Vzc2lvbihzZXNzaW9uQ29va2llKTtcbiAgICBpZiAoaXNBY3RpdmVTZXNzaW9uKHNlc3Npb24pKSB7XG4gICAgICAgIHJldHVybiBzZXNzaW9uO1xuICAgIH1cbiAgICBjbGVhclNlc3Npb24oc2Vzc2lvbkNvb2tpZSk7XG4gICAgcmV0dXJuIHt9O1xufVxuZnVuY3Rpb24gaXNBY3RpdmVTZXNzaW9uKHNlc3Npb24pIHtcbiAgICAvLyBjcmVhdGVkIGFuZCBleHBpcmUgY2FuIGJlIHVuZGVmaW5lZCBmb3IgdmVyc2lvbnMgd2hpY2ggd2FzIG5vdCBzdG9yaW5nIHRoZW1cbiAgICAvLyB0aGVzZSBjaGVja3MgY291bGQgYmUgcmVtb3ZlZCB3aGVuIG9sZGVyIHZlcnNpb25zIHdpbGwgbm90IGJlIGF2YWlsYWJsZS9saXZlIGFueW1vcmVcbiAgICByZXR1cm4gKChzZXNzaW9uLmNyZWF0ZWQgPT09IHVuZGVmaW5lZCB8fCBEYXRlLm5vdygpIC0gTnVtYmVyKHNlc3Npb24uY3JlYXRlZCkgPCBTRVNTSU9OX1RJTUVfT1VUX0RFTEFZKSAmJlxuICAgICAgICAoc2Vzc2lvbi5leHBpcmUgPT09IHVuZGVmaW5lZCB8fCBEYXRlLm5vdygpIDwgTnVtYmVyKHNlc3Npb24uZXhwaXJlKSkpO1xufVxuZnVuY3Rpb24gcmV0cmlldmVTZXNzaW9uKHNlc3Npb25Db29raWUpIHtcbiAgICB2YXIgc2Vzc2lvblN0cmluZyA9IHNlc3Npb25Db29raWUuZ2V0KCk7XG4gICAgdmFyIHNlc3Npb24gPSB7fTtcbiAgICBpZiAoaXNWYWxpZFNlc3Npb25TdHJpbmcoc2Vzc2lvblN0cmluZykpIHtcbiAgICAgICAgc2Vzc2lvblN0cmluZy5zcGxpdChTRVNTSU9OX0VOVFJZX1NFUEFSQVRPUikuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gU0VTU0lPTl9FTlRSWV9SRUdFWFAuZXhlYyhlbnRyeSk7XG4gICAgICAgICAgICBpZiAobWF0Y2hlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBtYXRjaGVzWzFdLCB2YWx1ZSA9IG1hdGNoZXNbMl07XG4gICAgICAgICAgICAgICAgc2Vzc2lvbltrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc2Vzc2lvbjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwZXJzaXN0U2Vzc2lvbihzZXNzaW9uLCBjb29raWUpIHtcbiAgICBpZiAodXRpbHMuaXNFbXB0eU9iamVjdChzZXNzaW9uKSkge1xuICAgICAgICBjbGVhclNlc3Npb24oY29va2llKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXNzaW9uLmV4cGlyZSA9IFN0cmluZyhEYXRlLm5vdygpICsgU0VTU0lPTl9FWFBJUkFUSU9OX0RFTEFZKTtcbiAgICB2YXIgY29va2llU3RyaW5nID0gdXRpbHNcbiAgICAgICAgLm9iamVjdEVudHJpZXMoc2Vzc2lvbilcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGtleSA9IF9hWzBdLCB2YWx1ZSA9IF9hWzFdO1xuICAgICAgICByZXR1cm4ga2V5ICsgXCI9XCIgKyB2YWx1ZTtcbiAgICB9KVxuICAgICAgICAuam9pbihTRVNTSU9OX0VOVFJZX1NFUEFSQVRPUik7XG4gICAgY29va2llLnNldChjb29raWVTdHJpbmcsIFNFU1NJT05fRVhQSVJBVElPTl9ERUxBWSk7XG59XG5mdW5jdGlvbiBjbGVhclNlc3Npb24oY29va2llKSB7XG4gICAgY29va2llLnNldCgnJywgMCk7XG59XG5leHBvcnQgZnVuY3Rpb24gc3RvcFNlc3Npb25NYW5hZ2VtZW50KCkge1xuICAgIHN0b3BDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gZSgpOyB9KTtcbiAgICBzdG9wQ2FsbGJhY2tzID0gW107XG59XG52YXIgc3RvcENhbGxiYWNrcyA9IFtdO1xuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrQWN0aXZpdHkoZXhwYW5kT3JSZW5ld1Nlc3Npb24pIHtcbiAgICB2YXIgc3RvcCA9IHV0aWxzLmFkZEV2ZW50TGlzdGVuZXJzKHdpbmRvdywgW1wiY2xpY2tcIiAvKiBDTElDSyAqLywgXCJ0b3VjaHN0YXJ0XCIgLyogVE9VQ0hfU1RBUlQgKi8sIFwia2V5ZG93blwiIC8qIEtFWV9ET1dOICovLCBcInNjcm9sbFwiIC8qIFNDUk9MTCAqL10sIGV4cGFuZE9yUmVuZXdTZXNzaW9uLCB7IGNhcHR1cmU6IHRydWUsIHBhc3NpdmU6IHRydWUgfSkuc3RvcDtcbiAgICBzdG9wQ2FsbGJhY2tzLnB1c2goc3RvcCk7XG59XG5mdW5jdGlvbiB0cmFja1Zpc2liaWxpdHkoZXhwYW5kU2Vzc2lvbikge1xuICAgIHZhciBleHBhbmRTZXNzaW9uV2hlblZpc2libGUgPSBtb25pdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICAgICAgICBleHBhbmRTZXNzaW9uKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgc3RvcCA9IHV0aWxzLmFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsIFwidmlzaWJpbGl0eWNoYW5nZVwiIC8qIFZJU0lCSUxJVFlfQ0hBTkdFICovLCBleHBhbmRTZXNzaW9uV2hlblZpc2libGUpLnN0b3A7XG4gICAgc3RvcENhbGxiYWNrcy5wdXNoKHN0b3ApO1xuICAgIHZhciB2aXNpYmlsaXR5Q2hlY2tJbnRlcnZhbCA9IHNldEludGVydmFsKGV4cGFuZFNlc3Npb25XaGVuVmlzaWJsZSwgVklTSUJJTElUWV9DSEVDS19ERUxBWSk7XG4gICAgc3RvcENhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh2aXNpYmlsaXR5Q2hlY2tJbnRlcnZhbCk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXNzaW9uTWFuYWdlbWVudC5qcy5tYXAiLCJpbXBvcnQgeyByZXBvcnQgfSBmcm9tICcuL3JlcG9ydCc7XG52YXIgVU5LTk9XTl9GVU5DVElPTiA9ICc/Jztcbi8qKlxuICogY29tcHV0ZVN0YWNrVHJhY2U6IGNyb3NzLWJyb3dzZXIgc3RhY2sgdHJhY2VzIGluIEphdmFTY3JpcHRcbiAqXG4gKiBTeW50YXg6XG4gKiBgYGBqc1xuICogcyA9IGNvbXB1dGVTdGFja1RyYWNlT2ZDYWxsZXIoW2RlcHRoXSlcbiAqIHMgPSBjb21wdXRlU3RhY2tUcmFjZShleGNlcHRpb24pIC8vIGNvbnNpZGVyIHVzaW5nIHJlcG9ydCBpbnN0ZWFkIChzZWUgYmVsb3cpXG4gKiBgYGBcbiAqXG4gKiBTdXBwb3J0czpcbiAqICAgLSBGaXJlZm94OiAgZnVsbCBzdGFjayB0cmFjZSB3aXRoIGxpbmUgbnVtYmVycyBhbmQgdW5yZWxpYWJsZSBjb2x1bW5cbiAqICAgICAgICAgICAgICAgbnVtYmVyIG9uIHRvcCBmcmFtZVxuICogICAtIE9wZXJhIDEwOiBmdWxsIHN0YWNrIHRyYWNlIHdpdGggbGluZSBhbmQgY29sdW1uIG51bWJlcnNcbiAqICAgLSBPcGVyYSA5LTogZnVsbCBzdGFjayB0cmFjZSB3aXRoIGxpbmUgbnVtYmVyc1xuICogICAtIENocm9tZTogICBmdWxsIHN0YWNrIHRyYWNlIHdpdGggbGluZSBhbmQgY29sdW1uIG51bWJlcnNcbiAqICAgLSBTYWZhcmk6ICAgbGluZSBhbmQgY29sdW1uIG51bWJlciBmb3IgdGhlIHRvcG1vc3Qgc3RhY2t0cmFjZSBlbGVtZW50XG4gKiAgICAgICAgICAgICAgIG9ubHlcbiAqICAgLSBJRTogICAgICAgbm8gbGluZSBudW1iZXJzIHdoYXRzb2V2ZXJcbiAqXG4gKiBUcmllcyB0byBndWVzcyBuYW1lcyBvZiBhbm9ueW1vdXMgZnVuY3Rpb25zIGJ5IGxvb2tpbmcgZm9yIGFzc2lnbm1lbnRzXG4gKiBpbiB0aGUgc291cmNlIGNvZGUuIEluIElFIGFuZCBTYWZhcmksIHdlIGhhdmUgdG8gZ3Vlc3Mgc291cmNlIGZpbGUgbmFtZXNcbiAqIGJ5IHNlYXJjaGluZyBmb3IgZnVuY3Rpb24gYm9kaWVzIGluc2lkZSBhbGwgcGFnZSBzY3JpcHRzLiBUaGlzIHdpbGwgbm90XG4gKiB3b3JrIGZvciBzY3JpcHRzIHRoYXQgYXJlIGxvYWRlZCBjcm9zcy1kb21haW4uXG4gKiBIZXJlIGJlIGRyYWdvbnM6IHNvbWUgZnVuY3Rpb24gbmFtZXMgbWF5IGJlIGd1ZXNzZWQgaW5jb3JyZWN0bHksIGFuZFxuICogZHVwbGljYXRlIGZ1bmN0aW9ucyBtYXkgYmUgbWlzbWF0Y2hlZC5cbiAqXG4gKiBjb21wdXRlU3RhY2tUcmFjZSBzaG91bGQgb25seSBiZSB1c2VkIGZvciB0cmFjaW5nIHB1cnBvc2VzLlxuICogTG9nZ2luZyBvZiB1bmhhbmRsZWQgZXhjZXB0aW9ucyBzaG91bGQgYmUgZG9uZSB3aXRoIHJlcG9ydCxcbiAqIHdoaWNoIGJ1aWxkcyBvbiB0b3Agb2YgY29tcHV0ZVN0YWNrVHJhY2UgYW5kIHByb3ZpZGVzIGJldHRlclxuICogSUUgc3VwcG9ydCBieSB1dGlsaXppbmcgdGhlIHdpbmRvdy5vbmVycm9yIGV2ZW50IHRvIHJldHJpZXZlIGluZm9ybWF0aW9uXG4gKiBhYm91dCB0aGUgdG9wIG9mIHRoZSBzdGFjay5cbiAqXG4gKiBOb3RlOiBJbiBJRSBhbmQgU2FmYXJpLCBubyBzdGFjayB0cmFjZSBpcyByZWNvcmRlZCBvbiB0aGUgRXJyb3Igb2JqZWN0LFxuICogc28gY29tcHV0ZVN0YWNrVHJhY2UgaW5zdGVhZCB3YWxrcyBpdHMgKm93biogY2hhaW4gb2YgY2FsbGVycy5cbiAqIFRoaXMgbWVhbnMgdGhhdDpcbiAqICAqIGluIFNhZmFyaSwgc29tZSBtZXRob2RzIG1heSBiZSBtaXNzaW5nIGZyb20gdGhlIHN0YWNrIHRyYWNlO1xuICogICogaW4gSUUsIHRoZSB0b3Btb3N0IGZ1bmN0aW9uIGluIHRoZSBzdGFjayB0cmFjZSB3aWxsIGFsd2F5cyBiZSB0aGVcbiAqICAgIGNhbGxlciBvZiBjb21wdXRlU3RhY2tUcmFjZS5cbiAqXG4gKiBUaGlzIGlzIG9rYXkgZm9yIHRyYWNpbmcgKGJlY2F1c2UgeW91IGFyZSBsaWtlbHkgdG8gYmUgY2FsbGluZ1xuICogY29tcHV0ZVN0YWNrVHJhY2UgZnJvbSB0aGUgZnVuY3Rpb24geW91IHdhbnQgdG8gYmUgdGhlIHRvcG1vc3QgZWxlbWVudFxuICogb2YgdGhlIHN0YWNrIHRyYWNlIGFueXdheSksIGJ1dCBub3Qgb2theSBmb3IgbG9nZ2luZyB1bmhhbmRsZWRcbiAqIGV4Y2VwdGlvbnMgKGJlY2F1c2UgeW91ciBjYXRjaCBibG9jayB3aWxsIGxpa2VseSBiZSBmYXIgYXdheSBmcm9tIHRoZVxuICogaW5uZXIgZnVuY3Rpb24gdGhhdCBhY3R1YWxseSBjYXVzZWQgdGhlIGV4Y2VwdGlvbikuXG4gKlxuICogVHJhY2luZyBleGFtcGxlOlxuICogYGBganNcbiAqICAgICBmdW5jdGlvbiB0cmFjZShtZXNzYWdlKSB7XG4gKiAgICAgICAgIGxldCBzdGFja0luZm8gPSBjb21wdXRlU3RhY2tUcmFjZS5vZkNhbGxlcigpO1xuICogICAgICAgICBsZXQgZGF0YSA9IG1lc3NhZ2UgKyBcIlxcblwiO1xuICogICAgICAgICBmb3IobGV0IGkgaW4gc3RhY2tJbmZvLnN0YWNrKSB7XG4gKiAgICAgICAgICAgICBsZXQgaXRlbSA9IHN0YWNrSW5mby5zdGFja1tpXTtcbiAqICAgICAgICAgICAgIGRhdGEgKz0gKGl0ZW0uZnVuYyB8fCAnW2Fub255bW91c10nKSArIFwiKCkgaW4gXCIgKyBpdGVtLnVybCArIFwiOlwiICsgKGl0ZW0ubGluZSB8fCAnMCcpICsgXCJcXG5cIjtcbiAqICAgICAgICAgfVxuICogICAgICAgICBpZiAod2luZG93LmNvbnNvbGUpXG4gKiAgICAgICAgICAgICBjb25zb2xlLmluZm8oZGF0YSk7XG4gKiAgICAgICAgIGVsc2VcbiAqICAgICAgICAgICAgIGFsZXJ0KGRhdGEpO1xuICogICAgIH1cbiAqIGBgYFxuICogQG1lbWJlcm9mIFRyYWNlS2l0XG4gKiBAbmFtZXNwYWNlXG4gKi9cbi8qKlxuICogQ29tcHV0ZXMgYSBzdGFjayB0cmFjZSBmb3IgYW4gZXhjZXB0aW9uLlxuICogQHBhcmFtIHtFcnJvcn0gZXhcbiAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXIpPX0gZGVwdGhcbiAqIEBtZW1iZXJvZiBjb21wdXRlU3RhY2tUcmFjZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVN0YWNrVHJhY2UoZXgsIGRlcHRoKSB7XG4gICAgdmFyIHN0YWNrO1xuICAgIHZhciBub3JtYWxpemVkRGVwdGggPSBkZXB0aCA9PT0gdW5kZWZpbmVkID8gMCA6ICtkZXB0aDtcbiAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIG11c3QgYmUgdHJpZWQgZmlyc3QgYmVjYXVzZSBPcGVyYSAxMCAqZGVzdHJveXMqXG4gICAgICAgIC8vIGl0cyBzdGFja3RyYWNlIHByb3BlcnR5IGlmIHlvdSB0cnkgdG8gYWNjZXNzIHRoZSBzdGFja1xuICAgICAgICAvLyBwcm9wZXJ0eSBmaXJzdCEhXG4gICAgICAgIHN0YWNrID0gY29tcHV0ZVN0YWNrVHJhY2VGcm9tU3RhY2t0cmFjZVByb3AoZXgpO1xuICAgICAgICBpZiAoc3RhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgc3RhY2sgPSBjb21wdXRlU3RhY2tUcmFjZUZyb21TdGFja1Byb3AoZXgpO1xuICAgICAgICBpZiAoc3RhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgc3RhY2sgPSBjb21wdXRlU3RhY2tUcmFjZUZyb21PcGVyYU11bHRpTGluZU1lc3NhZ2UoZXgpO1xuICAgICAgICBpZiAoc3RhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgc3RhY2sgPSBjb21wdXRlU3RhY2tUcmFjZUJ5V2Fsa2luZ0NhbGxlckNoYWluKGV4LCBub3JtYWxpemVkRGVwdGggKyAxKTtcbiAgICAgICAgaWYgKHN0YWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG1lc3NhZ2U6IHRyeVRvR2V0U3RyaW5nKGV4LCAnbWVzc2FnZScpLFxuICAgICAgICBuYW1lOiB0cnlUb0dldFN0cmluZyhleCwgJ25hbWUnKSxcbiAgICAgICAgc3RhY2s6IFtdLFxuICAgIH07XG59XG52YXIgZGVidWcgPSBmYWxzZTtcbi8vIENvbnRlbnRzIG9mIEV4Y2VwdGlvbiBpbiB2YXJpb3VzIGJyb3dzZXJzLlxuLy9cbi8vIFNBRkFSSTpcbi8vIGV4Lm1lc3NhZ2UgPSBDYW4ndCBmaW5kIHZhcmlhYmxlOiBxcVxuLy8gZXgubGluZSA9IDU5XG4vLyBleC5zb3VyY2VJZCA9IDU4MDIzODE5MlxuLy8gZXguc291cmNlVVJMID0gaHR0cDovLy4uLlxuLy8gZXguZXhwcmVzc2lvbkJlZ2luT2Zmc2V0ID0gOTZcbi8vIGV4LmV4cHJlc3Npb25DYXJldE9mZnNldCA9IDk4XG4vLyBleC5leHByZXNzaW9uRW5kT2Zmc2V0ID0gOThcbi8vIGV4Lm5hbWUgPSBSZWZlcmVuY2VFcnJvclxuLy9cbi8vIEZJUkVGT1g6XG4vLyBleC5tZXNzYWdlID0gcXEgaXMgbm90IGRlZmluZWRcbi8vIGV4LmZpbGVOYW1lID0gaHR0cDovLy4uLlxuLy8gZXgubGluZU51bWJlciA9IDU5XG4vLyBleC5jb2x1bW5OdW1iZXIgPSA2OVxuLy8gZXguc3RhY2sgPSAuLi5zdGFjayB0cmFjZS4uLiAoc2VlIHRoZSBleGFtcGxlIGJlbG93KVxuLy8gZXgubmFtZSA9IFJlZmVyZW5jZUVycm9yXG4vL1xuLy8gQ0hST01FOlxuLy8gZXgubWVzc2FnZSA9IHFxIGlzIG5vdCBkZWZpbmVkXG4vLyBleC5uYW1lID0gUmVmZXJlbmNlRXJyb3Jcbi8vIGV4LnR5cGUgPSBub3RfZGVmaW5lZFxuLy8gZXguYXJndW1lbnRzID0gWydhYSddXG4vLyBleC5zdGFjayA9IC4uLnN0YWNrIHRyYWNlLi4uXG4vL1xuLy8gSU5URVJORVQgRVhQTE9SRVI6XG4vLyBleC5tZXNzYWdlID0gLi4uXG4vLyBleC5uYW1lID0gUmVmZXJlbmNlRXJyb3Jcbi8vXG4vLyBPUEVSQTpcbi8vIGV4Lm1lc3NhZ2UgPSAuLi5tZXNzYWdlLi4uIChzZWUgdGhlIGV4YW1wbGUgYmVsb3cpXG4vLyBleC5uYW1lID0gUmVmZXJlbmNlRXJyb3Jcbi8vIGV4Lm9wZXJhI3NvdXJjZWxvYyA9IDExICAocHJldHR5IG11Y2ggdXNlbGVzcywgZHVwbGljYXRlcyB0aGUgaW5mbyBpbiBleC5tZXNzYWdlKVxuLy8gZXguc3RhY2t0cmFjZSA9IG4vYTsgc2VlICdvcGVyYTpjb25maWcjVXNlclByZWZzfEV4Y2VwdGlvbnMgSGF2ZSBTdGFja3RyYWNlJ1xuLyoqXG4gKiBDb21wdXRlcyBzdGFjayB0cmFjZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBzdGFjayBwcm9wZXJ0eS5cbiAqIENocm9tZSBhbmQgR2Vja28gdXNlIHRoaXMgcHJvcGVydHkuXG4gKiBAcGFyYW0ge0Vycm9yfSBleFxuICogQHJldHVybiB7P1N0YWNrVHJhY2V9IFN0YWNrIHRyYWNlIGluZm9ybWF0aW9uLlxuICogQG1lbWJlcm9mIGNvbXB1dGVTdGFja1RyYWNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlU3RhY2tUcmFjZUZyb21TdGFja1Byb3AoZXgpIHtcbiAgICB2YXIgc3RhY2t0cmFjZSA9IHRyeVRvR2V0U3RyaW5nKGV4LCAnc3RhY2snKTtcbiAgICBpZiAoIXN0YWNrdHJhY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgIG1heC1sZW5cbiAgICB2YXIgY2hyb21lID0gL15cXHMqYXQgKC4qPykgP1xcKCgoPzpmaWxlfGh0dHBzP3xibG9ifGNocm9tZS1leHRlbnNpb258bmF0aXZlfGV2YWx8d2VicGFja3w8YW5vbnltb3VzPnxcXC8pLio/KSg/OjooXFxkKykpPyg/OjooXFxkKykpP1xcKT9cXHMqJC9pO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAgbWF4LWxlblxuICAgIHZhciBnZWNrbyA9IC9eXFxzKiguKj8pKD86XFwoKC4qPylcXCkpPyg/Ol58QCkoKD86ZmlsZXxodHRwcz98YmxvYnxjaHJvbWV8d2VicGFja3xyZXNvdXJjZXxjYXBhY2l0b3J8XFxbbmF0aXZlKS4qP3xbXkBdKmJ1bmRsZSkoPzo6KFxcZCspKT8oPzo6KFxcZCspKT9cXHMqJC9pO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAgbWF4LWxlblxuICAgIHZhciB3aW5qcyA9IC9eXFxzKmF0ICg/OigoPzpcXFtvYmplY3Qgb2JqZWN0XFxdKT8uKykgKT9cXCg/KCg/OmZpbGV8bXMtYXBweHxodHRwcz98d2VicGFja3xibG9iKTouKj8pOihcXGQrKSg/OjooXFxkKykpP1xcKT9cXHMqJC9pO1xuICAgIC8vIFVzZWQgdG8gYWRkaXRpb25hbGx5IHBhcnNlIFVSTC9saW5lL2NvbHVtbiBmcm9tIGV2YWwgZnJhbWVzXG4gICAgdmFyIGlzRXZhbDtcbiAgICB2YXIgZ2Vja29FdmFsID0gLyhcXFMrKSBsaW5lIChcXGQrKSg/OiA+IGV2YWwgbGluZSBcXGQrKSogPiBldmFsL2k7XG4gICAgdmFyIGNocm9tZUV2YWwgPSAvXFwoKFxcUyopKD86OihcXGQrKSkoPzo6KFxcZCspKVxcKS87XG4gICAgdmFyIGxpbmVzID0gc3RhY2t0cmFjZS5zcGxpdCgnXFxuJyk7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIHN1Ym1hdGNoO1xuICAgIHZhciBwYXJ0cztcbiAgICB2YXIgZWxlbWVudDtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGxpbmVzLmxlbmd0aDsgaSA8IGo7IGkgKz0gMSkge1xuICAgICAgICBpZiAoY2hyb21lLmV4ZWMobGluZXNbaV0pKSB7XG4gICAgICAgICAgICBwYXJ0cyA9IGNocm9tZS5leGVjKGxpbmVzW2ldKTtcbiAgICAgICAgICAgIHZhciBpc05hdGl2ZSA9IHBhcnRzWzJdICYmIHBhcnRzWzJdLmluZGV4T2YoJ25hdGl2ZScpID09PSAwOyAvLyBzdGFydCBvZiBsaW5lXG4gICAgICAgICAgICBpc0V2YWwgPSBwYXJ0c1syXSAmJiBwYXJ0c1syXS5pbmRleE9mKCdldmFsJykgPT09IDA7IC8vIHN0YXJ0IG9mIGxpbmVcbiAgICAgICAgICAgIHN1Ym1hdGNoID0gY2hyb21lRXZhbC5leGVjKHBhcnRzWzJdKTtcbiAgICAgICAgICAgIGlmIChpc0V2YWwgJiYgc3VibWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBvdXQgZXZhbCBsaW5lL2NvbHVtbiBhbmQgdXNlIHRvcC1tb3N0IGxpbmUvY29sdW1uIG51bWJlclxuICAgICAgICAgICAgICAgIHBhcnRzWzJdID0gc3VibWF0Y2hbMV07IC8vIHVybFxuICAgICAgICAgICAgICAgIHBhcnRzWzNdID0gc3VibWF0Y2hbMl07IC8vIGxpbmVcbiAgICAgICAgICAgICAgICBwYXJ0c1s0XSA9IHN1Ym1hdGNoWzNdOyAvLyBjb2x1bW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgYXJnczogaXNOYXRpdmUgPyBbcGFydHNbMl1dIDogW10sXG4gICAgICAgICAgICAgICAgY29sdW1uOiBwYXJ0c1s0XSA/ICtwYXJ0c1s0XSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBmdW5jOiBwYXJ0c1sxXSB8fCBVTktOT1dOX0ZVTkNUSU9OLFxuICAgICAgICAgICAgICAgIGxpbmU6IHBhcnRzWzNdID8gK3BhcnRzWzNdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHVybDogIWlzTmF0aXZlID8gcGFydHNbMl0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHdpbmpzLmV4ZWMobGluZXNbaV0pKSB7XG4gICAgICAgICAgICBwYXJ0cyA9IHdpbmpzLmV4ZWMobGluZXNbaV0pO1xuICAgICAgICAgICAgZWxlbWVudCA9IHtcbiAgICAgICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IHBhcnRzWzRdID8gK3BhcnRzWzRdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGZ1bmM6IHBhcnRzWzFdIHx8IFVOS05PV05fRlVOQ1RJT04sXG4gICAgICAgICAgICAgICAgbGluZTogK3BhcnRzWzNdLFxuICAgICAgICAgICAgICAgIHVybDogcGFydHNbMl0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGdlY2tvLmV4ZWMobGluZXNbaV0pKSB7XG4gICAgICAgICAgICBwYXJ0cyA9IGdlY2tvLmV4ZWMobGluZXNbaV0pO1xuICAgICAgICAgICAgaXNFdmFsID0gcGFydHNbM10gJiYgcGFydHNbM10uaW5kZXhPZignID4gZXZhbCcpID4gLTE7XG4gICAgICAgICAgICBzdWJtYXRjaCA9IGdlY2tvRXZhbC5leGVjKHBhcnRzWzNdKTtcbiAgICAgICAgICAgIGlmIChpc0V2YWwgJiYgc3VibWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBvdXQgZXZhbCBsaW5lL2NvbHVtbiBhbmQgdXNlIHRvcC1tb3N0IGxpbmUgbnVtYmVyXG4gICAgICAgICAgICAgICAgcGFydHNbM10gPSBzdWJtYXRjaFsxXTtcbiAgICAgICAgICAgICAgICBwYXJ0c1s0XSA9IHN1Ym1hdGNoWzJdO1xuICAgICAgICAgICAgICAgIHBhcnRzWzVdID0gdW5kZWZpbmVkOyAvLyBubyBjb2x1bW4gd2hlbiBldmFsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpID09PSAwICYmICFwYXJ0c1s1XSAmJiAhaXNVbmRlZmluZWQoZXguY29sdW1uTnVtYmVyKSkge1xuICAgICAgICAgICAgICAgIC8vIEZpcmVGb3ggdXNlcyB0aGlzIGF3ZXNvbWUgY29sdW1uTnVtYmVyIHByb3BlcnR5IGZvciBpdHMgdG9wIGZyYW1lXG4gICAgICAgICAgICAgICAgLy8gQWxzbyBub3RlLCBGaXJlZm94J3MgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkIGFuZCBldmVyeXRoaW5nIGVsc2UgZXhwZWN0cyAxLWJhc2VkLFxuICAgICAgICAgICAgICAgIC8vIHNvIGFkZGluZyAxXG4gICAgICAgICAgICAgICAgLy8gTk9URTogdGhpcyBoYWNrIGRvZXNuJ3Qgd29yayBpZiB0b3AtbW9zdCBmcmFtZSBpcyBldmFsXG4gICAgICAgICAgICAgICAgc3RhY2tbMF0uY29sdW1uID0gZXguY29sdW1uTnVtYmVyICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgYXJnczogcGFydHNbMl0gPyBwYXJ0c1syXS5zcGxpdCgnLCcpIDogW10sXG4gICAgICAgICAgICAgICAgY29sdW1uOiBwYXJ0c1s1XSA/ICtwYXJ0c1s1XSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBmdW5jOiBwYXJ0c1sxXSB8fCBVTktOT1dOX0ZVTkNUSU9OLFxuICAgICAgICAgICAgICAgIGxpbmU6IHBhcnRzWzRdID8gK3BhcnRzWzRdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHVybDogcGFydHNbM10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbGVtZW50LmZ1bmMgJiYgZWxlbWVudC5saW5lKSB7XG4gICAgICAgICAgICBlbGVtZW50LmZ1bmMgPSBVTktOT1dOX0ZVTkNUSU9OO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgfVxuICAgIGlmICghc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhY2s6IHN0YWNrLFxuICAgICAgICBtZXNzYWdlOiB0cnlUb0dldFN0cmluZyhleCwgJ21lc3NhZ2UnKSxcbiAgICAgICAgbmFtZTogdHJ5VG9HZXRTdHJpbmcoZXgsICduYW1lJyksXG4gICAgfTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgc3RhY2sgdHJhY2UgaW5mb3JtYXRpb24gZnJvbSB0aGUgc3RhY2t0cmFjZSBwcm9wZXJ0eS5cbiAqIE9wZXJhIDEwKyB1c2VzIHRoaXMgcHJvcGVydHkuXG4gKiBAcGFyYW0ge0Vycm9yfSBleFxuICogQHJldHVybiB7P1N0YWNrVHJhY2V9IFN0YWNrIHRyYWNlIGluZm9ybWF0aW9uLlxuICogQG1lbWJlcm9mIGNvbXB1dGVTdGFja1RyYWNlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVTdGFja1RyYWNlRnJvbVN0YWNrdHJhY2VQcm9wKGV4KSB7XG4gICAgLy8gQWNjZXNzIGFuZCBzdG9yZSB0aGUgc3RhY2t0cmFjZSBwcm9wZXJ0eSBiZWZvcmUgZG9pbmcgQU5ZVEhJTkdcbiAgICAvLyBlbHNlIHRvIGl0IGJlY2F1c2UgT3BlcmEgaXMgbm90IHZlcnkgZ29vZCBhdCBwcm92aWRpbmcgaXRcbiAgICAvLyByZWxpYWJseSBpbiBvdGhlciBjaXJjdW1zdGFuY2VzLlxuICAgIHZhciBzdGFja3RyYWNlID0gdHJ5VG9HZXRTdHJpbmcoZXgsICdzdGFja3RyYWNlJyk7XG4gICAgaWYgKCFzdGFja3RyYWNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG9wZXJhMTBSZWdleCA9IC8gbGluZSAoXFxkKykuKnNjcmlwdCAoPzppbiApPyhcXFMrKSg/OjogaW4gZnVuY3Rpb24gKFxcUyspKT8kL2k7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lICBtYXgtbGVuXG4gICAgdmFyIG9wZXJhMTFSZWdleCA9IC8gbGluZSAoXFxkKyksIGNvbHVtbiAoXFxkKylcXHMqKD86aW4gKD86PGFub255bW91cyBmdW5jdGlvbjogKFtePl0rKT58KFteXFwpXSspKVxcKCguKilcXCkpPyBpbiAoLiopOlxccyokL2k7XG4gICAgdmFyIGxpbmVzID0gc3RhY2t0cmFjZS5zcGxpdCgnXFxuJyk7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIHBhcnRzO1xuICAgIGZvciAodmFyIGxpbmUgPSAwOyBsaW5lIDwgbGluZXMubGVuZ3RoOyBsaW5lICs9IDIpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB2b2lkIDA7XG4gICAgICAgIGlmIChvcGVyYTEwUmVnZXguZXhlYyhsaW5lc1tsaW5lXSkpIHtcbiAgICAgICAgICAgIHBhcnRzID0gb3BlcmExMFJlZ2V4LmV4ZWMobGluZXNbbGluZV0pO1xuICAgICAgICAgICAgZWxlbWVudCA9IHtcbiAgICAgICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBmdW5jOiBwYXJ0c1szXSxcbiAgICAgICAgICAgICAgICBsaW5lOiArcGFydHNbMV0sXG4gICAgICAgICAgICAgICAgdXJsOiBwYXJ0c1syXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmExMVJlZ2V4LmV4ZWMobGluZXNbbGluZV0pKSB7XG4gICAgICAgICAgICBwYXJ0cyA9IG9wZXJhMTFSZWdleC5leGVjKGxpbmVzW2xpbmVdKTtcbiAgICAgICAgICAgIGVsZW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgYXJnczogcGFydHNbNV0gPyBwYXJ0c1s1XS5zcGxpdCgnLCcpIDogW10sXG4gICAgICAgICAgICAgICAgY29sdW1uOiArcGFydHNbMl0sXG4gICAgICAgICAgICAgICAgZnVuYzogcGFydHNbM10gfHwgcGFydHNbNF0sXG4gICAgICAgICAgICAgICAgbGluZTogK3BhcnRzWzFdLFxuICAgICAgICAgICAgICAgIHVybDogcGFydHNbNl0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQuZnVuYyAmJiBlbGVtZW50LmxpbmUpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmZ1bmMgPSBVTktOT1dOX0ZVTkNUSU9OO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudC5jb250ZXh0ID0gW2xpbmVzW2xpbmUgKyAxXV07XG4gICAgICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhY2s6IHN0YWNrLFxuICAgICAgICBtZXNzYWdlOiB0cnlUb0dldFN0cmluZyhleCwgJ21lc3NhZ2UnKSxcbiAgICAgICAgbmFtZTogdHJ5VG9HZXRTdHJpbmcoZXgsICduYW1lJyksXG4gICAgfTtcbn1cbi8qKlxuICogTk9UIFRFU1RFRC5cbiAqIENvbXB1dGVzIHN0YWNrIHRyYWNlIGluZm9ybWF0aW9uIGZyb20gYW4gZXJyb3IgbWVzc2FnZSB0aGF0IGluY2x1ZGVzXG4gKiB0aGUgc3RhY2sgdHJhY2UuXG4gKiBPcGVyYSA5IGFuZCBlYXJsaWVyIHVzZSB0aGlzIG1ldGhvZCBpZiB0aGUgb3B0aW9uIHRvIHNob3cgc3RhY2tcbiAqIHRyYWNlcyBpcyB0dXJuZWQgb24gaW4gb3BlcmE6Y29uZmlnLlxuICogQHBhcmFtIHtFcnJvcn0gZXhcbiAqIEByZXR1cm4gez9TdGFja1RyYWNlfSBTdGFjayBpbmZvcm1hdGlvbi5cbiAqIEBtZW1iZXJvZiBjb21wdXRlU3RhY2tUcmFjZVxuICovXG5mdW5jdGlvbiBjb21wdXRlU3RhY2tUcmFjZUZyb21PcGVyYU11bHRpTGluZU1lc3NhZ2UoZXgpIHtcbiAgICAvLyBUT0RPOiBDbGVhbiB0aGlzIGZ1bmN0aW9uIHVwXG4gICAgLy8gT3BlcmEgaW5jbHVkZXMgYSBzdGFjayB0cmFjZSBpbnRvIHRoZSBleGNlcHRpb24gbWVzc2FnZS4gQW4gZXhhbXBsZSBpczpcbiAgICAvL1xuICAgIC8vIFN0YXRlbWVudCBvbiBsaW5lIDM6IFVuZGVmaW5lZCB2YXJpYWJsZTogdW5kZWZpbmVkRnVuY1xuICAgIC8vIEJhY2t0cmFjZTpcbiAgICAvLyAgIExpbmUgMyBvZiBsaW5rZWQgc2NyaXB0IGZpbGU6Ly9sb2NhbGhvc3QvVXNlcnMvYW5kcmV5dml0L1Byb2plY3RzL1RyYWNlS2l0L2phdmFzY3JpcHQtY2xpZW50L3NhbXBsZS5qczpcbiAgICAvLyAgIEluIGZ1bmN0aW9uIHp6elxuICAgIC8vICAgICAgICAgdW5kZWZpbmVkRnVuYyhhKTtcbiAgICAvLyAgIExpbmUgNyBvZiBpbmxpbmUjMSBzY3JpcHQgaW4gZmlsZTovL2xvY2FsaG9zdC9Vc2Vycy9hbmRyZXl2aXQvUHJvamVjdHMvVHJhY2VLaXQvamF2YXNjcmlwdC1jbGllbnQvc2FtcGxlLmh0bWw6XG4gICAgLy8gICBJbiBmdW5jdGlvbiB5eXlcbiAgICAvLyAgICAgICAgICAgenp6KHgsIHksIHopO1xuICAgIC8vICAgTGluZSAzIG9mIGlubGluZSMxIHNjcmlwdCBpbiBmaWxlOi8vbG9jYWxob3N0L1VzZXJzL2FuZHJleXZpdC9Qcm9qZWN0cy9UcmFjZUtpdC9qYXZhc2NyaXB0LWNsaWVudC9zYW1wbGUuaHRtbDpcbiAgICAvLyAgIEluIGZ1bmN0aW9uIHh4eFxuICAgIC8vICAgICAgICAgICB5eXkoYSwgYSwgYSk7XG4gICAgLy8gICBMaW5lIDEgb2YgZnVuY3Rpb24gc2NyaXB0XG4gICAgLy8gICAgIHRyeSB7IHh4eCgnaGknKTsgcmV0dXJuIGZhbHNlOyB9IGNhdGNoKGV4KSB7IHJlcG9ydChleCk7IH1cbiAgICAvLyAgIC4uLlxuICAgIHZhciBtZXNzYWdlID0gdHJ5VG9HZXRTdHJpbmcoZXgsICdtZXNzYWdlJyk7XG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxpbmVzID0gbWVzc2FnZS5zcGxpdCgnXFxuJyk7XG4gICAgaWYgKGxpbmVzLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbGluZVJFMSA9IC9eXFxzKkxpbmUgKFxcZCspIG9mIGxpbmtlZCBzY3JpcHQgKCg/OmZpbGV8aHR0cHM/fGJsb2IpXFxTKykoPzo6IGluIGZ1bmN0aW9uIChcXFMrKSk/XFxzKiQvaTtcbiAgICB2YXIgbGluZVJFMiA9IC9eXFxzKkxpbmUgKFxcZCspIG9mIGlubGluZSMoXFxkKykgc2NyaXB0IGluICgoPzpmaWxlfGh0dHBzP3xibG9iKVxcUyspKD86OiBpbiBmdW5jdGlvbiAoXFxTKykpP1xccyokL2k7XG4gICAgdmFyIGxpbmVSRTMgPSAvXlxccypMaW5lIChcXGQrKSBvZiBmdW5jdGlvbiBzY3JpcHRcXHMqJC9pO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBzY3JpcHRzID0gd2luZG93ICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICAgIHZhciBpbmxpbmVTY3JpcHRCbG9ja3MgPSBbXTtcbiAgICB2YXIgcGFydHM7XG4gICAgZm9yICh2YXIgcyBpbiBzY3JpcHRzKSB7XG4gICAgICAgIGlmIChoYXMoc2NyaXB0cywgcykgJiYgIXNjcmlwdHNbc10uc3JjKSB7XG4gICAgICAgICAgICBpbmxpbmVTY3JpcHRCbG9ja3MucHVzaChzY3JpcHRzW3NdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBsaW5lID0gMjsgbGluZSA8IGxpbmVzLmxlbmd0aDsgbGluZSArPSAyKSB7XG4gICAgICAgIHZhciBpdGVtID0gdm9pZCAwO1xuICAgICAgICBpZiAobGluZVJFMS5leGVjKGxpbmVzW2xpbmVdKSkge1xuICAgICAgICAgICAgcGFydHMgPSBsaW5lUkUxLmV4ZWMobGluZXNbbGluZV0pO1xuICAgICAgICAgICAgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBmdW5jOiBwYXJ0c1szXSxcbiAgICAgICAgICAgICAgICBsaW5lOiArcGFydHNbMV0sXG4gICAgICAgICAgICAgICAgdXJsOiBwYXJ0c1syXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGluZVJFMi5leGVjKGxpbmVzW2xpbmVdKSkge1xuICAgICAgICAgICAgcGFydHMgPSBsaW5lUkUyLmV4ZWMobGluZXNbbGluZV0pO1xuICAgICAgICAgICAgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBmdW5jOiBwYXJ0c1s0XSxcbiAgICAgICAgICAgICAgICBsaW5lOiArcGFydHNbMV0sXG4gICAgICAgICAgICAgICAgdXJsOiBwYXJ0c1szXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGluZVJFMy5leGVjKGxpbmVzW2xpbmVdKSkge1xuICAgICAgICAgICAgcGFydHMgPSBsaW5lUkUzLmV4ZWMobGluZXNbbGluZV0pO1xuICAgICAgICAgICAgdmFyIHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLnJlcGxhY2UoLyMuKiQvLCAnJyk7XG4gICAgICAgICAgICBpdGVtID0ge1xuICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGZ1bmM6ICcnLFxuICAgICAgICAgICAgICAgIGxpbmU6ICtwYXJ0c1sxXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmICghaXRlbS5mdW5jKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5mdW5jID0gVU5LTk9XTl9GVU5DVElPTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW0uY29udGV4dCA9IFtsaW5lc1tsaW5lICsgMV1dO1xuICAgICAgICAgICAgc3RhY2sucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXN0YWNrLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47IC8vIGNvdWxkIG5vdCBwYXJzZSBtdWx0aWxpbmUgZXhjZXB0aW9uIG1lc3NhZ2UgYXMgT3BlcmEgc3RhY2sgdHJhY2VcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhY2s6IHN0YWNrLFxuICAgICAgICBtZXNzYWdlOiBsaW5lc1swXSxcbiAgICAgICAgbmFtZTogdHJ5VG9HZXRTdHJpbmcoZXgsICduYW1lJyksXG4gICAgfTtcbn1cbi8qKlxuICogQWRkcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZmlyc3QgZnJhbWUgdG8gaW5jb21wbGV0ZSBzdGFjayB0cmFjZXMuXG4gKiBTYWZhcmkgYW5kIElFIHJlcXVpcmUgdGhpcyB0byBnZXQgY29tcGxldGUgZGF0YSBvbiB0aGUgZmlyc3QgZnJhbWUuXG4gKiBAcGFyYW0ge1N0YWNrVHJhY2V9IHN0YWNrSW5mbyBTdGFjayB0cmFjZSBpbmZvcm1hdGlvbiBmcm9tXG4gKiBvbmUgb2YgdGhlIGNvbXB1dGUqIG1ldGhvZHMuXG4gKiBAcGFyYW0ge3N0cmluZz19IHVybCBUaGUgVVJMIG9mIHRoZSBzY3JpcHQgdGhhdCBjYXVzZWQgYW4gZXJyb3IuXG4gKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nKT19IGxpbmVObyBUaGUgbGluZSBudW1iZXIgb2YgdGhlIHNjcmlwdCB0aGF0XG4gKiBjYXVzZWQgYW4gZXJyb3IuXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIGVycm9yIGdlbmVyYXRlZCBieSB0aGUgYnJvd3Nlciwgd2hpY2hcbiAqIGhvcGVmdWxseSBjb250YWlucyB0aGUgbmFtZSBvZiB0aGUgb2JqZWN0IHRoYXQgY2F1c2VkIHRoZSBlcnJvci5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBzdGFjayBpbmZvcm1hdGlvbiB3YXNcbiAqIGF1Z21lbnRlZC5cbiAqIEBtZW1iZXJvZiBjb21wdXRlU3RhY2tUcmFjZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXVnbWVudFN0YWNrVHJhY2VXaXRoSW5pdGlhbEVsZW1lbnQoc3RhY2tJbmZvLCB1cmwsIGxpbmVObykge1xuICAgIHZhciBpbml0aWFsID0ge1xuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgbGluZTogbGluZU5vID8gK2xpbmVObyA6IHVuZGVmaW5lZCxcbiAgICB9O1xuICAgIGlmIChpbml0aWFsLnVybCAmJiBpbml0aWFsLmxpbmUpIHtcbiAgICAgICAgc3RhY2tJbmZvLmluY29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgdmFyIHN0YWNrID0gc3RhY2tJbmZvLnN0YWNrO1xuICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHN0YWNrWzBdLnVybCA9PT0gaW5pdGlhbC51cmwpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2tbMF0ubGluZSA9PT0gaW5pdGlhbC5saW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gYWxyZWFkeSBpbiBzdGFjayB0cmFjZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXN0YWNrWzBdLmxpbmUgJiYgc3RhY2tbMF0uZnVuYyA9PT0gaW5pdGlhbC5mdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrWzBdLmxpbmUgPSBpbml0aWFsLmxpbmU7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrWzBdLmNvbnRleHQgPSBpbml0aWFsLmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sudW5zaGlmdChpbml0aWFsKTtcbiAgICAgICAgc3RhY2tJbmZvLnBhcnRpYWwgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3RhY2tJbmZvLmluY29tcGxldGUgPSB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgc3RhY2sgdHJhY2UgaW5mb3JtYXRpb24gYnkgd2Fsa2luZyB0aGUgYXJndW1lbnRzLmNhbGxlclxuICogY2hhaW4gYXQgdGhlIHRpbWUgdGhlIGV4Y2VwdGlvbiBvY2N1cnJlZC4gVGhpcyB3aWxsIGNhdXNlIGVhcmxpZXJcbiAqIGZyYW1lcyB0byBiZSBtaXNzZWQgYnV0IGlzIHRoZSBvbmx5IHdheSB0byBnZXQgYW55IHN0YWNrIHRyYWNlIGluXG4gKiBTYWZhcmkgYW5kIElFLiBUaGUgdG9wIGZyYW1lIGlzIHJlc3RvcmVkIGJ5XG4gKiB7QGxpbmsgYXVnbWVudFN0YWNrVHJhY2VXaXRoSW5pdGlhbEVsZW1lbnR9LlxuICogQHBhcmFtIHtFcnJvcn0gZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aFxuICogQHJldHVybiB7U3RhY2tUcmFjZX0gU3RhY2sgdHJhY2UgaW5mb3JtYXRpb24uXG4gKiBAbWVtYmVyb2YgY29tcHV0ZVN0YWNrVHJhY2VcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVN0YWNrVHJhY2VCeVdhbGtpbmdDYWxsZXJDaGFpbihleCwgZGVwdGgpIHtcbiAgICB2YXIgZnVuY3Rpb25OYW1lID0gL2Z1bmN0aW9uXFxzKyhbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXVtfJGEtekEtWjAtOVxceEEwLVxcdUZGRkZdKik/XFxzKlxcKC9pO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBmdW5jcyA9IHt9O1xuICAgIHZhciByZWN1cnNpb24gPSBmYWxzZTtcbiAgICB2YXIgcGFydHM7XG4gICAgdmFyIGl0ZW07XG4gICAgZm9yICh2YXIgY3VyciA9IGNvbXB1dGVTdGFja1RyYWNlQnlXYWxraW5nQ2FsbGVyQ2hhaW4uY2FsbGVyOyBjdXJyICYmICFyZWN1cnNpb247IGN1cnIgPSBjdXJyLmNhbGxlcikge1xuICAgICAgICBpZiAoY3VyciA9PT0gY29tcHV0ZVN0YWNrVHJhY2UgfHwgY3VyciA9PT0gcmVwb3J0KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpdGVtID0ge1xuICAgICAgICAgICAgYXJnczogW10sXG4gICAgICAgICAgICBjb2x1bW46IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZ1bmM6IFVOS05PV05fRlVOQ1RJT04sXG4gICAgICAgICAgICBsaW5lOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB1cmw6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgcGFydHMgPSBmdW5jdGlvbk5hbWUuZXhlYyhjdXJyLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoY3Vyci5uYW1lKSB7XG4gICAgICAgICAgICBpdGVtLmZ1bmMgPSBjdXJyLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFydHMpIHtcbiAgICAgICAgICAgIGl0ZW0uZnVuYyA9IHBhcnRzWzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbS5mdW5jID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaXRlbS5mdW5jID0gcGFydHMgPyBwYXJ0cy5pbnB1dC5zdWJzdHJpbmcoMCwgcGFydHMuaW5wdXQuaW5kZXhPZigneycpKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVuY3NbY3Vyci50b1N0cmluZygpXSkge1xuICAgICAgICAgICAgcmVjdXJzaW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZ1bmNzW2N1cnIudG9TdHJpbmcoKV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2goaXRlbSk7XG4gICAgfVxuICAgIGlmIChkZXB0aCkge1xuICAgICAgICBzdGFjay5zcGxpY2UoMCwgZGVwdGgpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBzdGFjazogc3RhY2ssXG4gICAgICAgIG1lc3NhZ2U6IHRyeVRvR2V0U3RyaW5nKGV4LCAnbWVzc2FnZScpLFxuICAgICAgICBuYW1lOiB0cnlUb0dldFN0cmluZyhleCwgJ25hbWUnKSxcbiAgICB9O1xuICAgIGF1Z21lbnRTdGFja1RyYWNlV2l0aEluaXRpYWxFbGVtZW50KHJlc3VsdCwgdHJ5VG9HZXRTdHJpbmcoZXgsICdzb3VyY2VVUkwnKSB8fCB0cnlUb0dldFN0cmluZyhleCwgJ2ZpbGVOYW1lJyksIHRyeVRvR2V0U3RyaW5nKGV4LCAnbGluZScpIHx8IHRyeVRvR2V0U3RyaW5nKGV4LCAnbGluZU51bWJlcicpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdHJ5VG9HZXRTdHJpbmcoY2FuZGlkYXRlLCBwcm9wZXJ0eSkge1xuICAgIGlmICh0eXBlb2YgY2FuZGlkYXRlICE9PSAnb2JqZWN0JyB8fCAhY2FuZGlkYXRlIHx8ICEocHJvcGVydHkgaW4gY2FuZGlkYXRlKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBjYW5kaWRhdGVbcHJvcGVydHldO1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIExvZ3MgYSBzdGFja3RyYWNlIHN0YXJ0aW5nIGZyb20gdGhlIHByZXZpb3VzIGNhbGwgYW5kIHdvcmtpbmcgZG93bi5cbiAqIEBwYXJhbSB7KG51bWJlcnxzdHJpbmcpPX0gZGVwdGggSG93IG1hbnkgZnJhbWVzIGRlZXAgdG8gdHJhY2UuXG4gKiBAcmV0dXJuIHtTdGFja1RyYWNlfSBTdGFjayB0cmFjZSBpbmZvcm1hdGlvbi5cbiAqIEBtZW1iZXJvZiBjb21wdXRlU3RhY2tUcmFjZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVN0YWNrVHJhY2VPZkNhbGxlcihkZXB0aCkge1xuICAgIHZhciBjdXJyZW50RGVwdGggPSAoZGVwdGggPT09IHVuZGVmaW5lZCA/IDAgOiArZGVwdGgpICsgMTsgLy8gXCIrIDFcIiBiZWNhdXNlIFwib2ZDYWxsZXJcIiBzaG91bGQgZHJvcCBvbmUgZnJhbWVcbiAgICB0cnkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgIHJldHVybiBjb21wdXRlU3RhY2tUcmFjZShleCwgY3VycmVudERlcHRoICsgMSk7XG4gICAgfVxufVxuLyoqXG4gKiBBIGJldHRlciBmb3JtIG9mIGhhc093blByb3BlcnR5PGJyLz5cbiAqIEV4YW1wbGU6IGBoYXMoTWFpbkhvc3RPYmplY3QsIHByb3BlcnR5KSA9PT0gdHJ1ZS9mYWxzZWBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIGNoZWNrIHByb3BlcnR5XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBvYmplY3QgaGFzIHRoZSBrZXkgYW5kIGl0IGlzIG5vdCBpbmhlcml0ZWRcbiAqL1xuZnVuY3Rpb24gaGFzKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZDxici8+XG4gKiBFeGFtcGxlOiBgaXNVbmRlZmluZWQodmFsKSA9PT0gdHJ1ZS9mYWxzZWBcbiAqXG4gKiBAcGFyYW0geyp9IHdoYXQgVmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdW5kZWZpbmVkIGFuZCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQod2hhdCkge1xuICAgIHJldHVybiB0eXBlb2Ygd2hhdCA9PT0gJ3VuZGVmaW5lZCc7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wdXRlU3RhY2tUcmFjZS5qcy5tYXAiLCJleHBvcnQgeyBjb21wdXRlU3RhY2tUcmFjZSB9IGZyb20gJy4vY29tcHV0ZVN0YWNrVHJhY2UnO1xuZXhwb3J0IHsgcmVwb3J0LCBzdWJzY3JpYmUsIHVuc3Vic2NyaWJlIH0gZnJvbSAnLi9yZXBvcnQnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHsgbW9uaXRvciB9IGZyb20gJy4uL2ludGVybmFsTW9uaXRvcmluZyc7XG5pbXBvcnQgeyBjb21wdXRlU3RhY2tUcmFjZSwgYXVnbWVudFN0YWNrVHJhY2VXaXRoSW5pdGlhbEVsZW1lbnQgfSBmcm9tICcuL2NvbXB1dGVTdGFja1RyYWNlJztcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0Vycm9yX3R5cGVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgIG1heC1sZW5cbnZhciBFUlJPUl9UWVBFU19SRSA9IC9eKD86W1V1XW5jYXVnaHQgKD86ZXhjZXB0aW9uOiApPyk/KD86KCg/OkV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSXwpRXJyb3IpOiApPyguKikkLztcbi8qKlxuICogQ3Jvc3MtYnJvd3NlciBwcm9jZXNzaW5nIG9mIHVuaGFuZGxlZCBleGNlcHRpb25zXG4gKlxuICogU3ludGF4OlxuICogYGBganNcbiAqICAgc3Vic2NyaWJlKGZ1bmN0aW9uKHN0YWNrSW5mbykgeyAuLi4gfSlcbiAqICAgdW5zdWJzY3JpYmUoZnVuY3Rpb24oc3RhY2tJbmZvKSB7IC4uLiB9KVxuICogICByZXBvcnQoZXhjZXB0aW9uKVxuICogICB0cnkgeyAuLi5jb2RlLi4uIH0gY2F0Y2goZXgpIHsgcmVwb3J0KGV4KTsgfVxuICogYGBgXG4gKlxuICogU3VwcG9ydHM6XG4gKiAgIC0gRmlyZWZveDogZnVsbCBzdGFjayB0cmFjZSB3aXRoIGxpbmUgbnVtYmVycywgcGx1cyBjb2x1bW4gbnVtYmVyXG4gKiAgICAgb24gdG9wIGZyYW1lOyBjb2x1bW4gbnVtYmVyIGlzIG5vdCBndWFyYW50ZWVkXG4gKiAgIC0gT3BlcmE6IGZ1bGwgc3RhY2sgdHJhY2Ugd2l0aCBsaW5lIGFuZCBjb2x1bW4gbnVtYmVyc1xuICogICAtIENocm9tZTogZnVsbCBzdGFjayB0cmFjZSB3aXRoIGxpbmUgYW5kIGNvbHVtbiBudW1iZXJzXG4gKiAgIC0gU2FmYXJpOiBsaW5lIGFuZCBjb2x1bW4gbnVtYmVyIGZvciB0aGUgdG9wIGZyYW1lIG9ubHk7IHNvbWUgZnJhbWVzXG4gKiAgICAgbWF5IGJlIG1pc3NpbmcsIGFuZCBjb2x1bW4gbnVtYmVyIGlzIG5vdCBndWFyYW50ZWVkXG4gKiAgIC0gSUU6IGxpbmUgYW5kIGNvbHVtbiBudW1iZXIgZm9yIHRoZSB0b3AgZnJhbWUgb25seTsgc29tZSBmcmFtZXNcbiAqICAgICBtYXkgYmUgbWlzc2luZywgYW5kIGNvbHVtbiBudW1iZXIgaXMgbm90IGd1YXJhbnRlZWRcbiAqXG4gKiBJbiB0aGVvcnksIFRyYWNlS2l0IHNob3VsZCB3b3JrIG9uIGFsbCBvZiB0aGUgZm9sbG93aW5nIHZlcnNpb25zOlxuICogICAtIElFNS41KyAob25seSA4LjAgdGVzdGVkKVxuICogICAtIEZpcmVmb3ggMC45KyAob25seSAzLjUrIHRlc3RlZClcbiAqICAgLSBPcGVyYSA3KyAob25seSAxMC41MCB0ZXN0ZWQ7IHZlcnNpb25zIDkgYW5kIGVhcmxpZXIgbWF5IHJlcXVpcmVcbiAqICAgICBFeGNlcHRpb25zIEhhdmUgU3RhY2t0cmFjZSB0byBiZSBlbmFibGVkIGluIG9wZXJhOmNvbmZpZylcbiAqICAgLSBTYWZhcmkgMysgKG9ubHkgNCsgdGVzdGVkKVxuICogICAtIENocm9tZSAxKyAob25seSA1KyB0ZXN0ZWQpXG4gKiAgIC0gS29ucXVlcm9yIDMuNSsgKHVudGVzdGVkKVxuICpcbiAqIFJlcXVpcmVzIGNvbXB1dGVTdGFja1RyYWNlLlxuICpcbiAqIFRyaWVzIHRvIGNhdGNoIGFsbCB1bmhhbmRsZWQgZXhjZXB0aW9ucyBhbmQgcmVwb3J0IHRoZW0gdG8gdGhlXG4gKiBzdWJzY3JpYmVkIGhhbmRsZXJzLiBQbGVhc2Ugbm90ZSB0aGF0IHJlcG9ydCB3aWxsIHJldGhyb3cgdGhlXG4gKiBleGNlcHRpb24uIFRoaXMgaXMgUkVRVUlSRUQgaW4gb3JkZXIgdG8gZ2V0IGEgdXNlZnVsIHN0YWNrIHRyYWNlIGluIElFLlxuICogSWYgdGhlIGV4Y2VwdGlvbiBkb2VzIG5vdCByZWFjaCB0aGUgdG9wIG9mIHRoZSBicm93c2VyLCB5b3Ugd2lsbCBvbmx5XG4gKiBnZXQgYSBzdGFjayB0cmFjZSBmcm9tIHRoZSBwb2ludCB3aGVyZSByZXBvcnQgd2FzIGNhbGxlZC5cbiAqXG4gKiBIYW5kbGVycyByZWNlaXZlIGEgU3RhY2tUcmFjZSBvYmplY3QgYXMgZGVzY3JpYmVkIGluIHRoZVxuICogY29tcHV0ZVN0YWNrVHJhY2UgZG9jcy5cbiAqXG4gKiBAbWVtYmVyb2YgVHJhY2VLaXRcbiAqIEBuYW1lc3BhY2VcbiAqL1xuLyoqXG4gKiBSZXBvcnRzIGFuIHVuaGFuZGxlZCBFcnJvci5cbiAqIEBwYXJhbSB7RXJyb3J9IGV4XG4gKiBAbWVtYmVyb2YgcmVwb3J0XG4gKiBAdGhyb3dzIEFuIGV4Y2VwdGlvbiBpZiBhbiBpbmNvbXBsZXRlIHN0YWNrIHRyYWNlIGlzIGRldGVjdGVkIChvbGQgSUUgYnJvd3NlcnMpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwb3J0KGV4KSB7XG4gICAgaWYgKGxhc3RFeGNlcHRpb25TdGFjaykge1xuICAgICAgICBpZiAobGFzdEV4Y2VwdGlvbiA9PT0gZXgpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gYWxyZWFkeSBjYXVnaHQgYnkgYW4gaW5uZXIgY2F0Y2ggYmxvY2ssIGlnbm9yZVxuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NMYXN0RXhjZXB0aW9uKCk7XG4gICAgfVxuICAgIHZhciBzdGFjayA9IGNvbXB1dGVTdGFja1RyYWNlKGV4KTtcbiAgICBsYXN0RXhjZXB0aW9uU3RhY2sgPSBzdGFjaztcbiAgICBsYXN0RXhjZXB0aW9uID0gZXg7XG4gICAgLy8gSWYgdGhlIHN0YWNrIHRyYWNlIGlzIGluY29tcGxldGUsIHdhaXQgZm9yIDIgc2Vjb25kcyBmb3JcbiAgICAvLyBzbG93IHNsb3cgSUUgdG8gc2VlIGlmIG9uZXJyb3Igb2NjdXJzIG9yIG5vdCBiZWZvcmUgcmVwb3J0aW5nXG4gICAgLy8gdGhpcyBleGNlcHRpb247IG90aGVyd2lzZSwgd2Ugd2lsbCBlbmQgdXAgd2l0aCBhbiBpbmNvbXBsZXRlXG4gICAgLy8gc3RhY2sgdHJhY2VcbiAgICBzZXRUaW1lb3V0KG1vbml0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobGFzdEV4Y2VwdGlvbiA9PT0gZXgpIHtcbiAgICAgICAgICAgIHByb2Nlc3NMYXN0RXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9KSwgc3RhY2suaW5jb21wbGV0ZSA/IDIwMDAgOiAwKTtcbiAgICB0aHJvdyBleDsgLy8gcmUtdGhyb3cgdG8gcHJvcGFnYXRlIHRvIHRoZSB0b3AgbGV2ZWwgKGFuZCBjYXVzZSB3aW5kb3cub25lcnJvcilcbn1cbnZhciBoYW5kbGVycyA9IFtdO1xudmFyIGxhc3RFeGNlcHRpb247XG52YXIgbGFzdEV4Y2VwdGlvblN0YWNrO1xuLyoqXG4gKiBBZGQgYSBjcmFzaCBoYW5kbGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICogQG1lbWJlcm9mIHJlcG9ydFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3Vic2NyaWJlKGhhbmRsZXIpIHtcbiAgICBpbnN0YWxsR2xvYmFsSGFuZGxlcigpO1xuICAgIGluc3RhbGxHbG9iYWxVbmhhbmRsZWRSZWplY3Rpb25IYW5kbGVyKCk7XG4gICAgaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbn1cbi8qKlxuICogUmVtb3ZlIGEgY3Jhc2ggaGFuZGxlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqIEBtZW1iZXJvZiByZXBvcnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKGhhbmRsZXIpIHtcbiAgICBmb3IgKHZhciBpID0gaGFuZGxlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgaWYgKGhhbmRsZXJzW2ldID09PSBoYW5kbGVyKSB7XG4gICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhbmRsZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB1bmluc3RhbGxHbG9iYWxIYW5kbGVyKCk7XG4gICAgICAgIHVuaW5zdGFsbEdsb2JhbFVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZXIoKTtcbiAgICB9XG59XG4vKipcbiAqIERpc3BhdGNoIHN0YWNrIGluZm9ybWF0aW9uIHRvIGFsbCBoYW5kbGVycy5cbiAqIEBwYXJhbSB7U3RhY2tUcmFjZX0gc3RhY2tcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNXaW5kb3dFcnJvciBJcyB0aGlzIGEgdG9wLWxldmVsIHdpbmRvdyBlcnJvcj9cbiAqIEBwYXJhbSB7RXJyb3I9fSBlcnJvciBUaGUgZXJyb3IgdGhhdCdzIGJlaW5nIGhhbmRsZWQgKGlmIGF2YWlsYWJsZSwgbnVsbCBvdGhlcndpc2UpXG4gKiBAbWVtYmVyb2YgcmVwb3J0XG4gKiBAdGhyb3dzIEFuIGV4Y2VwdGlvbiBpZiBhbiBlcnJvciBvY2N1cnMgd2hpbGUgY2FsbGluZyBhbiBoYW5kbGVyLlxuICovXG5mdW5jdGlvbiBub3RpZnlIYW5kbGVycyhzdGFjaywgaXNXaW5kb3dFcnJvciwgZXJyb3IpIHtcbiAgICB2YXIgZXhjZXB0aW9uO1xuICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGhhbmRsZXIoc3RhY2ssIGlzV2luZG93RXJyb3IsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoaW5uZXIpIHtcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IGlubmVyO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGV4Y2VwdGlvbikge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxufVxudmFyIG9sZE9uZXJyb3JIYW5kbGVyO1xudmFyIG9uRXJyb3JIYW5kbGVySW5zdGFsbGVkO1xudmFyIG9sZE9udW5oYW5kbGVkcmVqZWN0aW9uSGFuZGxlcjtcbnZhciBvblVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZXJJbnN0YWxsZWQ7XG4vKipcbiAqIEVuc3VyZXMgYWxsIGdsb2JhbCB1bmhhbmRsZWQgZXhjZXB0aW9ucyBhcmUgcmVjb3JkZWQuXG4gKiBTdXBwb3J0ZWQgYnkgR2Vja28gYW5kIElFLlxuICogQHBhcmFtIHtFdmVudHxzdHJpbmd9IG1lc3NhZ2UgRXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7c3RyaW5nPX0gdXJsIFVSTCBvZiBzY3JpcHQgdGhhdCBnZW5lcmF0ZWQgdGhlIGV4Y2VwdGlvbi5cbiAqIEBwYXJhbSB7KG51bWJlcnxzdHJpbmcpPX0gbGluZU5vIFRoZSBsaW5lIG51bWJlciBhdCB3aGljaCB0aGUgZXJyb3Igb2NjdXJyZWQuXG4gKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nKT19IGNvbHVtbk5vIFRoZSBjb2x1bW4gbnVtYmVyIGF0IHdoaWNoIHRoZSBlcnJvciBvY2N1cnJlZC5cbiAqIEBwYXJhbSB7RXJyb3I9fSBlcnJvck9iaiBUaGUgYWN0dWFsIEVycm9yIG9iamVjdC5cbiAqIEBtZW1iZXJvZiByZXBvcnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYWNlS2l0V2luZG93T25FcnJvcihtZXNzYWdlLCB1cmwsIGxpbmVObywgY29sdW1uTm8sIGVycm9yT2JqKSB7XG4gICAgdmFyIHN0YWNrO1xuICAgIGlmIChsYXN0RXhjZXB0aW9uU3RhY2spIHtcbiAgICAgICAgYXVnbWVudFN0YWNrVHJhY2VXaXRoSW5pdGlhbEVsZW1lbnQobGFzdEV4Y2VwdGlvblN0YWNrLCB1cmwsIGxpbmVObyk7XG4gICAgICAgIHByb2Nlc3NMYXN0RXhjZXB0aW9uKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yT2JqKSB7XG4gICAgICAgIHN0YWNrID0gY29tcHV0ZVN0YWNrVHJhY2UoZXJyb3JPYmopO1xuICAgICAgICBub3RpZnlIYW5kbGVycyhzdGFjaywgdHJ1ZSwgZXJyb3JPYmopO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGxvY2F0aW9uXzEgPSB7XG4gICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgIGNvbHVtbjogY29sdW1uTm8sXG4gICAgICAgICAgICBsaW5lOiBsaW5lTm8sXG4gICAgICAgIH07XG4gICAgICAgIHZhciBuYW1lXzE7XG4gICAgICAgIHZhciBtc2cgPSBtZXNzYWdlO1xuICAgICAgICBpZiAoe30udG9TdHJpbmcuY2FsbChtZXNzYWdlKSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICAgICAgICAgIHZhciBncm91cHMgPSBFUlJPUl9UWVBFU19SRS5leGVjKG1zZyk7XG4gICAgICAgICAgICBpZiAoZ3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgbmFtZV8xID0gZ3JvdXBzWzFdO1xuICAgICAgICAgICAgICAgIG1zZyA9IGdyb3Vwc1syXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFjayA9IHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWVfMSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnID8gbXNnIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc3RhY2s6IFtsb2NhdGlvbl8xXSxcbiAgICAgICAgfTtcbiAgICAgICAgbm90aWZ5SGFuZGxlcnMoc3RhY2ssIHRydWUsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAob2xkT25lcnJvckhhbmRsZXIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICAgIHJldHVybiBvbGRPbmVycm9ySGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIEVuc3VyZXMgYWxsIHVuaGFuZGxlZCByZWplY3Rpb25zIGFyZSByZWNvcmRlZC5cbiAqIEBwYXJhbSB7UHJvbWlzZVJlamVjdGlvbkV2ZW50fSBlIGV2ZW50LlxuICogQG1lbWJlcm9mIHJlcG9ydFxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93RXZlbnRIYW5kbGVycy9vbnVuaGFuZGxlZHJlamVjdGlvblxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUHJvbWlzZVJlamVjdGlvbkV2ZW50XG4gKi9cbmZ1bmN0aW9uIHRyYWNlS2l0V2luZG93T25VbmhhbmRsZWRSZWplY3Rpb24oZSkge1xuICAgIHZhciByZWFzb24gPSBlLnJlYXNvbiB8fCAnRW1wdHkgcmVhc29uJztcbiAgICB2YXIgc3RhY2sgPSBjb21wdXRlU3RhY2tUcmFjZShyZWFzb24pO1xuICAgIG5vdGlmeUhhbmRsZXJzKHN0YWNrLCB0cnVlLCByZWFzb24pO1xufVxuLyoqXG4gKiBJbnN0YWxsIGEgZ2xvYmFsIG9uZXJyb3IgaGFuZGxlclxuICogQG1lbWJlcm9mIHJlcG9ydFxuICovXG5mdW5jdGlvbiBpbnN0YWxsR2xvYmFsSGFuZGxlcigpIHtcbiAgICBpZiAob25FcnJvckhhbmRsZXJJbnN0YWxsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvbGRPbmVycm9ySGFuZGxlciA9IHdpbmRvdy5vbmVycm9yO1xuICAgIHdpbmRvdy5vbmVycm9yID0gbW9uaXRvcih0cmFjZUtpdFdpbmRvd09uRXJyb3IpO1xuICAgIG9uRXJyb3JIYW5kbGVySW5zdGFsbGVkID0gdHJ1ZTtcbn1cbi8qKlxuICogVW5pbnN0YWxsIHRoZSBnbG9iYWwgb25lcnJvciBoYW5kbGVyXG4gKiBAbWVtYmVyb2YgcmVwb3J0XG4gKi9cbmZ1bmN0aW9uIHVuaW5zdGFsbEdsb2JhbEhhbmRsZXIoKSB7XG4gICAgaWYgKG9uRXJyb3JIYW5kbGVySW5zdGFsbGVkKSB7XG4gICAgICAgIHdpbmRvdy5vbmVycm9yID0gb2xkT25lcnJvckhhbmRsZXI7XG4gICAgICAgIG9uRXJyb3JIYW5kbGVySW5zdGFsbGVkID0gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBJbnN0YWxsIGEgZ2xvYmFsIG9udW5oYW5kbGVkcmVqZWN0aW9uIGhhbmRsZXJcbiAqIEBtZW1iZXJvZiByZXBvcnRcbiAqL1xuZnVuY3Rpb24gaW5zdGFsbEdsb2JhbFVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZXIoKSB7XG4gICAgaWYgKG9uVW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlckluc3RhbGxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIG9sZE9udW5oYW5kbGVkcmVqZWN0aW9uSGFuZGxlciA9IHdpbmRvdy5vbnVuaGFuZGxlZHJlamVjdGlvbiAhPT0gbnVsbCA/IHdpbmRvdy5vbnVuaGFuZGxlZHJlamVjdGlvbiA6IHVuZGVmaW5lZDtcbiAgICB3aW5kb3cub251bmhhbmRsZWRyZWplY3Rpb24gPSBtb25pdG9yKHRyYWNlS2l0V2luZG93T25VbmhhbmRsZWRSZWplY3Rpb24pO1xuICAgIG9uVW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlckluc3RhbGxlZCA9IHRydWU7XG59XG4vKipcbiAqIFVuaW5zdGFsbCB0aGUgZ2xvYmFsIG9udW5oYW5kbGVkcmVqZWN0aW9uIGhhbmRsZXJcbiAqIEBtZW1iZXJvZiByZXBvcnRcbiAqL1xuZnVuY3Rpb24gdW5pbnN0YWxsR2xvYmFsVW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlcigpIHtcbiAgICBpZiAob25VbmhhbmRsZWRSZWplY3Rpb25IYW5kbGVySW5zdGFsbGVkKSB7XG4gICAgICAgIHdpbmRvdy5vbnVuaGFuZGxlZHJlamVjdGlvbiA9IG9sZE9udW5oYW5kbGVkcmVqZWN0aW9uSGFuZGxlcjtcbiAgICAgICAgb25VbmhhbmRsZWRSZWplY3Rpb25IYW5kbGVySW5zdGFsbGVkID0gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBQcm9jZXNzIHRoZSBtb3N0IHJlY2VudCBleGNlcHRpb25cbiAqIEBtZW1iZXJvZiByZXBvcnRcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc0xhc3RFeGNlcHRpb24oKSB7XG4gICAgdmFyIGN1cnJlbnRMYXN0RXhjZXB0aW9uU3RhY2sgPSBsYXN0RXhjZXB0aW9uU3RhY2s7XG4gICAgdmFyIGN1cnJlbnRMYXN0RXhjZXB0aW9uID0gbGFzdEV4Y2VwdGlvbjtcbiAgICBsYXN0RXhjZXB0aW9uU3RhY2sgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEV4Y2VwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICBub3RpZnlIYW5kbGVycyhjdXJyZW50TGFzdEV4Y2VwdGlvblN0YWNrLCBmYWxzZSwgY3VycmVudExhc3RFeGNlcHRpb24pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVwb3J0LmpzLm1hcCIsInZhciBfYTtcbmltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBCdWlsZE1vZGUgfSBmcm9tICcuLi9ib290L2luaXQnO1xuaW1wb3J0IHsgaW5jbHVkZXMgfSBmcm9tICcuLi90b29scy91dGlscyc7XG52YXIgRU5EUE9JTlRTID0ge1xuICAgIGFsdGVybmF0ZToge1xuICAgICAgICBsb2dzOiAnbG9ncycsXG4gICAgICAgIHJ1bTogJ3J1bScsXG4gICAgICAgIHNlc3Npb25SZXBsYXk6ICdzZXNzaW9uLXJlcGxheScsXG4gICAgICAgIHRyYWNlOiAndHJhY2UnLFxuICAgIH0sXG4gICAgY2xhc3NpYzoge1xuICAgICAgICBsb2dzOiAnYnJvd3NlcicsXG4gICAgICAgIHJ1bTogJ3J1bScsXG4gICAgICAgIC8vIHNlc3Npb24tcmVwbGF5IGhhcyBubyBjbGFzc2ljIGVuZHBvaW50XG4gICAgICAgIHNlc3Npb25SZXBsYXk6IHVuZGVmaW5lZCxcbiAgICAgICAgdHJhY2U6ICdwdWJsaWMtdHJhY2UnLFxuICAgIH0sXG59O1xuZXhwb3J0IHZhciBEYXRhY2VudGVyID0ge1xuICAgIEVVOiAnZXUnLFxuICAgIFVTOiAndXMnLFxufTtcbmV4cG9ydCB2YXIgSU5UQUtFX1NJVEUgPSAoX2EgPSB7fSxcbiAgICBfYVtEYXRhY2VudGVyLkVVXSA9ICdkYXRhZG9naHEuZXUnLFxuICAgIF9hW0RhdGFjZW50ZXIuVVNdID0gJ2RhdGFkb2docS5jb20nLFxuICAgIF9hKTtcbnZhciBDTEFTU0lDX0FMTE9XRURfU0lURVMgPSBbSU5UQUtFX1NJVEVbRGF0YWNlbnRlci5VU10sIElOVEFLRV9TSVRFW0RhdGFjZW50ZXIuRVVdXTtcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlVHJhbnNwb3J0Q29uZmlndXJhdGlvbih1c2VyQ29uZmlndXJhdGlvbiwgYnVpbGRFbnYpIHtcbiAgICB2YXIgdHJhbnNwb3J0U2V0dGluZ3MgPSB7XG4gICAgICAgIGJ1aWxkTW9kZTogYnVpbGRFbnYuYnVpbGRNb2RlLFxuICAgICAgICBjbGllbnRUb2tlbjogdXNlckNvbmZpZ3VyYXRpb24uY2xpZW50VG9rZW4sXG4gICAgICAgIGVudjogdXNlckNvbmZpZ3VyYXRpb24uZW52LFxuICAgICAgICBwcm94eUhvc3Q6IHVzZXJDb25maWd1cmF0aW9uLnByb3h5SG9zdCxcbiAgICAgICAgc2RrVmVyc2lvbjogYnVpbGRFbnYuc2RrVmVyc2lvbixcbiAgICAgICAgc2VydmljZTogdXNlckNvbmZpZ3VyYXRpb24uc2VydmljZSxcbiAgICAgICAgc2l0ZTogdXNlckNvbmZpZ3VyYXRpb24uc2l0ZSB8fCBJTlRBS0VfU0lURVt1c2VyQ29uZmlndXJhdGlvbi5kYXRhY2VudGVyIHx8IGJ1aWxkRW52LmRhdGFjZW50ZXJdLFxuICAgICAgICB2ZXJzaW9uOiB1c2VyQ29uZmlndXJhdGlvbi52ZXJzaW9uLFxuICAgIH07XG4gICAgdmFyIGludGFrZVR5cGUgPSBnZXRJbnRha2VUeXBlKHRyYW5zcG9ydFNldHRpbmdzLnNpdGUsIHVzZXJDb25maWd1cmF0aW9uKTtcbiAgICB2YXIgaW50YWtlVXJscyA9IGdldEludGFrZVVybHMoaW50YWtlVHlwZSwgdHJhbnNwb3J0U2V0dGluZ3MsIHVzZXJDb25maWd1cmF0aW9uLnJlcGxpY2EgIT09IHVuZGVmaW5lZCk7XG4gICAgdmFyIGNvbmZpZ3VyYXRpb24gPSB7XG4gICAgICAgIGlzSW50YWtlVXJsOiBmdW5jdGlvbiAodXJsKSB7IHJldHVybiBpbnRha2VVcmxzLnNvbWUoZnVuY3Rpb24gKGludGFrZVVybCkgeyByZXR1cm4gdXJsLmluZGV4T2YoaW50YWtlVXJsKSA9PT0gMDsgfSk7IH0sXG4gICAgICAgIGxvZ3NFbmRwb2ludDogZ2V0RW5kcG9pbnQoaW50YWtlVHlwZSwgJ2xvZ3MnLCB0cmFuc3BvcnRTZXR0aW5ncyksXG4gICAgICAgIHJ1bUVuZHBvaW50OiBnZXRFbmRwb2ludChpbnRha2VUeXBlLCAncnVtJywgdHJhbnNwb3J0U2V0dGluZ3MpLFxuICAgICAgICBzZXNzaW9uUmVwbGF5RW5kcG9pbnQ6IGdldEVuZHBvaW50KGludGFrZVR5cGUsICdzZXNzaW9uUmVwbGF5JywgdHJhbnNwb3J0U2V0dGluZ3MpLFxuICAgICAgICB0cmFjZUVuZHBvaW50OiBnZXRFbmRwb2ludChpbnRha2VUeXBlLCAndHJhY2UnLCB0cmFuc3BvcnRTZXR0aW5ncyksXG4gICAgfTtcbiAgICBpZiAodXNlckNvbmZpZ3VyYXRpb24uaW50ZXJuYWxNb25pdG9yaW5nQXBpS2V5KSB7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24uaW50ZXJuYWxNb25pdG9yaW5nRW5kcG9pbnQgPSBnZXRFbmRwb2ludChpbnRha2VUeXBlLCAnbG9ncycsIHRyYW5zcG9ydFNldHRpbmdzLCAnYnJvd3Nlci1hZ2VudC1pbnRlcm5hbC1tb25pdG9yaW5nJyk7XG4gICAgfVxuICAgIGlmICh0cmFuc3BvcnRTZXR0aW5ncy5idWlsZE1vZGUgPT09IEJ1aWxkTW9kZS5FMkVfVEVTVCkge1xuICAgICAgICBjb25maWd1cmF0aW9uLmludGVybmFsTW9uaXRvcmluZ0VuZHBvaW50ID0gJzw8PCBFMkUgSU5URVJOQUwgTU9OSVRPUklORyBFTkRQT0lOVCA+Pj4nO1xuICAgICAgICBjb25maWd1cmF0aW9uLmxvZ3NFbmRwb2ludCA9ICc8PDwgRTJFIExPR1MgRU5EUE9JTlQgPj4+JztcbiAgICAgICAgY29uZmlndXJhdGlvbi5ydW1FbmRwb2ludCA9ICc8PDwgRTJFIFJVTSBFTkRQT0lOVCA+Pj4nO1xuICAgICAgICBjb25maWd1cmF0aW9uLnNlc3Npb25SZXBsYXlFbmRwb2ludCA9ICc8PDwgRTJFIFNFU1NJT04gUkVQTEFZIEVORFBPSU5UID4+Pic7XG4gICAgfVxuICAgIGlmICh0cmFuc3BvcnRTZXR0aW5ncy5idWlsZE1vZGUgPT09IEJ1aWxkTW9kZS5TVEFHSU5HKSB7XG4gICAgICAgIGlmICh1c2VyQ29uZmlndXJhdGlvbi5yZXBsaWNhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciByZXBsaWNhVHJhbnNwb3J0U2V0dGluZ3MgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdHJhbnNwb3J0U2V0dGluZ3MpLCB7IGFwcGxpY2F0aW9uSWQ6IHVzZXJDb25maWd1cmF0aW9uLnJlcGxpY2EuYXBwbGljYXRpb25JZCwgY2xpZW50VG9rZW46IHVzZXJDb25maWd1cmF0aW9uLnJlcGxpY2EuY2xpZW50VG9rZW4sIHNpdGU6IElOVEFLRV9TSVRFW0RhdGFjZW50ZXIuVVNdIH0pO1xuICAgICAgICAgICAgY29uZmlndXJhdGlvbi5yZXBsaWNhID0ge1xuICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uSWQ6IHVzZXJDb25maWd1cmF0aW9uLnJlcGxpY2EuYXBwbGljYXRpb25JZCxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbE1vbml0b3JpbmdFbmRwb2ludDogZ2V0RW5kcG9pbnQoaW50YWtlVHlwZSwgJ2xvZ3MnLCByZXBsaWNhVHJhbnNwb3J0U2V0dGluZ3MsICdicm93c2VyLWFnZW50LWludGVybmFsLW1vbml0b3JpbmcnKSxcbiAgICAgICAgICAgICAgICBsb2dzRW5kcG9pbnQ6IGdldEVuZHBvaW50KGludGFrZVR5cGUsICdsb2dzJywgcmVwbGljYVRyYW5zcG9ydFNldHRpbmdzKSxcbiAgICAgICAgICAgICAgICBydW1FbmRwb2ludDogZ2V0RW5kcG9pbnQoaW50YWtlVHlwZSwgJ3J1bScsIHJlcGxpY2FUcmFuc3BvcnRTZXR0aW5ncyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb25maWd1cmF0aW9uO1xufVxuZnVuY3Rpb24gZ2V0SW50YWtlVHlwZShzaXRlLCB1c2VyQ29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiAhdXNlckNvbmZpZ3VyYXRpb24udXNlQWx0ZXJuYXRlSW50YWtlRG9tYWlucyAmJiBpbmNsdWRlcyhDTEFTU0lDX0FMTE9XRURfU0lURVMsIHNpdGUpID8gJ2NsYXNzaWMnIDogJ2FsdGVybmF0ZSc7XG59XG5mdW5jdGlvbiBnZXRJbnRha2VVcmxzKGludGFrZVR5cGUsIHNldHRpbmdzLCB3aXRoUmVwbGljYSkge1xuICAgIGlmIChzZXR0aW5ncy5wcm94eUhvc3QpIHtcbiAgICAgICAgcmV0dXJuIFtcImh0dHBzOi8vXCIgKyBzZXR0aW5ncy5wcm94eUhvc3QgKyBcIi92MS9pbnB1dC9cIl07XG4gICAgfVxuICAgIHZhciBzaXRlcyA9IFtzZXR0aW5ncy5zaXRlXTtcbiAgICBpZiAoc2V0dGluZ3MuYnVpbGRNb2RlID09PSBCdWlsZE1vZGUuU1RBR0lORyAmJiB3aXRoUmVwbGljYSkge1xuICAgICAgICBzaXRlcy5wdXNoKElOVEFLRV9TSVRFW0RhdGFjZW50ZXIuVVNdKTtcbiAgICB9XG4gICAgdmFyIHVybHMgPSBbXTtcbiAgICB2YXIgZW5kcG9pbnRUeXBlcyA9IE9iamVjdC5rZXlzKEVORFBPSU5UU1tpbnRha2VUeXBlXSk7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBzaXRlc18xID0gc2l0ZXM7IF9pIDwgc2l0ZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHNpdGUgPSBzaXRlc18xW19pXTtcbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBlbmRwb2ludFR5cGVzXzEgPSBlbmRwb2ludFR5cGVzOyBfYSA8IGVuZHBvaW50VHlwZXNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgIHZhciBlbmRwb2ludFR5cGUgPSBlbmRwb2ludFR5cGVzXzFbX2FdO1xuICAgICAgICAgICAgdXJscy5wdXNoKFwiaHR0cHM6Ly9cIiArIGdldEhvc3QoaW50YWtlVHlwZSwgZW5kcG9pbnRUeXBlLCBzaXRlKSArIFwiL3YxL2lucHV0L1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXJscztcbn1cbmZ1bmN0aW9uIGdldEhvc3QoaW50YWtlVHlwZSwgZW5kcG9pbnRUeXBlLCBzaXRlKSB7XG4gICAgcmV0dXJuIChpbnRha2VUeXBlID09PSAnY2xhc3NpYycgJiYgZ2V0Q2xhc3NpY0hvc3QoZW5kcG9pbnRUeXBlLCBzaXRlKSkgfHwgZ2V0QWx0ZXJuYXRlSG9zdChlbmRwb2ludFR5cGUsIHNpdGUpO1xufVxuZnVuY3Rpb24gZ2V0Q2xhc3NpY0hvc3QoZW5kcG9pbnRUeXBlLCBzaXRlKSB7XG4gICAgdmFyIGVuZHBvaW50ID0gRU5EUE9JTlRTLmNsYXNzaWNbZW5kcG9pbnRUeXBlXTtcbiAgICByZXR1cm4gZW5kcG9pbnQgJiYgZW5kcG9pbnQgKyBcIi1odHRwLWludGFrZS5sb2dzLlwiICsgc2l0ZTtcbn1cbmZ1bmN0aW9uIGdldEFsdGVybmF0ZUhvc3QoZW5kcG9pbnRUeXBlLCBzaXRlKSB7XG4gICAgdmFyIGVuZHBvaW50ID0gRU5EUE9JTlRTLmFsdGVybmF0ZVtlbmRwb2ludFR5cGVdO1xuICAgIHZhciBkb21haW5QYXJ0cyA9IHNpdGUuc3BsaXQoJy4nKTtcbiAgICB2YXIgZXh0ZW5zaW9uID0gZG9tYWluUGFydHMucG9wKCk7XG4gICAgdmFyIHN1ZmZpeCA9IGRvbWFpblBhcnRzLmpvaW4oJy0nKSArIFwiLlwiICsgZXh0ZW5zaW9uO1xuICAgIHJldHVybiBlbmRwb2ludCArIFwiLmJyb3dzZXItaW50YWtlLVwiICsgc3VmZml4O1xufVxuZnVuY3Rpb24gZ2V0RW5kcG9pbnQoaW50YWtlVHlwZSwgZW5kcG9pbnRUeXBlLCBzZXR0aW5ncywgc291cmNlKSB7XG4gICAgdmFyIHRhZ3MgPSBcInNka192ZXJzaW9uOlwiICsgc2V0dGluZ3Muc2RrVmVyc2lvbiArXG4gICAgICAgIChcIlwiICsgKHNldHRpbmdzLmVudiA/IFwiLGVudjpcIiArIHNldHRpbmdzLmVudiA6ICcnKSkgK1xuICAgICAgICAoXCJcIiArIChzZXR0aW5ncy5zZXJ2aWNlID8gXCIsc2VydmljZTpcIiArIHNldHRpbmdzLnNlcnZpY2UgOiAnJykpICtcbiAgICAgICAgKFwiXCIgKyAoc2V0dGluZ3MudmVyc2lvbiA/IFwiLHZlcnNpb246XCIgKyBzZXR0aW5ncy52ZXJzaW9uIDogJycpKTtcbiAgICB2YXIgZGF0YWRvZ0hvc3QgPSBnZXRIb3N0KGludGFrZVR5cGUsIGVuZHBvaW50VHlwZSwgc2V0dGluZ3Muc2l0ZSk7XG4gICAgdmFyIGhvc3QgPSBzZXR0aW5ncy5wcm94eUhvc3QgPyBzZXR0aW5ncy5wcm94eUhvc3QgOiBkYXRhZG9nSG9zdDtcbiAgICB2YXIgcHJveHlQYXJhbWV0ZXIgPSBzZXR0aW5ncy5wcm94eUhvc3QgPyBcImRkaG9zdD1cIiArIGRhdGFkb2dIb3N0ICsgXCImXCIgOiAnJztcbiAgICB2YXIgcGFyYW1ldGVycyA9IHByb3h5UGFyYW1ldGVyICsgXCJkZHNvdXJjZT1cIiArIChzb3VyY2UgfHwgJ2Jyb3dzZXInKSArIFwiJmRkdGFncz1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh0YWdzKTtcbiAgICByZXR1cm4gXCJodHRwczovL1wiICsgaG9zdCArIFwiL3YxL2lucHV0L1wiICsgc2V0dGluZ3MuY2xpZW50VG9rZW4gKyBcIj9cIiArIHBhcmFtZXRlcnM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc3BvcnRDb25maWd1cmF0aW9uLmpzLm1hcCIsImV4cG9ydCB7IERFRkFVTFRfQ09ORklHVVJBVElPTiwgYnVpbGRDb29raWVPcHRpb25zIH0gZnJvbSAnLi9kb21haW4vY29uZmlndXJhdGlvbic7XG5leHBvcnQgeyBzdGFydEF1dG9tYXRpY0Vycm9yQ29sbGVjdGlvbiB9IGZyb20gJy4vZG9tYWluL2F1dG9tYXRpY0Vycm9yQ29sbGVjdGlvbic7XG5leHBvcnQgeyBjb21wdXRlU3RhY2tUcmFjZSB9IGZyb20gJy4vZG9tYWluL3RyYWNla2l0JztcbmV4cG9ydCB7IEJ1aWxkTW9kZSwgZGVmaW5lR2xvYmFsLCBtYWtlUHVibGljQXBpLCBjb21tb25Jbml0LCBjaGVja0Nvb2tpZXNBdXRob3JpemVkLCBjaGVja0lzTm90TG9jYWxGaWxlLCB9IGZyb20gJy4vYm9vdC9pbml0JztcbmV4cG9ydCB7IG1vbml0b3JlZCwgbW9uaXRvciwgY2FsbE1vbml0b3JlZCwgYWRkTW9uaXRvcmluZ01lc3NhZ2UsIGFkZEVycm9yVG9Nb25pdG9yaW5nQmF0Y2gsIHNldERlYnVnTW9kZSwgfSBmcm9tICcuL2RvbWFpbi9pbnRlcm5hbE1vbml0b3JpbmcnO1xuZXhwb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4vdG9vbHMvb2JzZXJ2YWJsZSc7XG5leHBvcnQgeyBzdGFydFNlc3Npb25NYW5hZ2VtZW50LCBTRVNTSU9OX1RJTUVfT1VUX0RFTEFZLCBcbi8vIEV4cG9zZWQgZm9yIHRlc3RzXG5TRVNTSU9OX0NPT0tJRV9OQU1FLCBzdG9wU2Vzc2lvbk1hbmFnZW1lbnQsIH0gZnJvbSAnLi9kb21haW4vc2Vzc2lvbk1hbmFnZW1lbnQnO1xuZXhwb3J0IHsgSHR0cFJlcXVlc3QsIEJhdGNoIH0gZnJvbSAnLi90cmFuc3BvcnQvdHJhbnNwb3J0JztcbmV4cG9ydCAqIGZyb20gJy4vdG9vbHMvdXJsUG9seWZpbGwnO1xuZXhwb3J0ICogZnJvbSAnLi90b29scy90aW1lVXRpbHMnO1xuZXhwb3J0ICogZnJvbSAnLi90b29scy91dGlscyc7XG5leHBvcnQgeyBFcnJvclNvdXJjZSwgZm9ybWF0VW5rbm93bkVycm9yIH0gZnJvbSAnLi90b29scy9lcnJvcic7XG5leHBvcnQgeyBjb21iaW5lLCBkZWVwQ2xvbmUgfSBmcm9tICcuL3Rvb2xzL2NvbnRleHQnO1xuZXhwb3J0IHsgYXJlQ29va2llc0F1dGhvcml6ZWQsIGdldENvb2tpZSwgc2V0Q29va2llLCBDT09LSUVfQUNDRVNTX0RFTEFZIH0gZnJvbSAnLi9icm93c2VyL2Nvb2tpZSc7XG5leHBvcnQgeyBzdGFydFhoclByb3h5LCByZXNldFhoclByb3h5IH0gZnJvbSAnLi9icm93c2VyL3hoclByb3h5JztcbmV4cG9ydCB7IHN0YXJ0RmV0Y2hQcm94eSwgcmVzZXRGZXRjaFByb3h5LCB9IGZyb20gJy4vYnJvd3Nlci9mZXRjaFByb3h5JztcbmV4cG9ydCB7IEJvdW5kZWRCdWZmZXIgfSBmcm9tICcuL3Rvb2xzL2JvdW5kZWRCdWZmZXInO1xuZXhwb3J0IHsgY2F0Y2hVc2VyRXJyb3JzIH0gZnJvbSAnLi90b29scy9jYXRjaFVzZXJFcnJvcnMnO1xuZXhwb3J0IHsgY3JlYXRlQ29udGV4dE1hbmFnZXIgfSBmcm9tICcuL3Rvb2xzL2NvbnRleHRNYW5hZ2VyJztcbmV4cG9ydCB7IGxpbWl0TW9kaWZpY2F0aW9uIH0gZnJvbSAnLi90b29scy9saW1pdE1vZGlmaWNhdGlvbic7XG5leHBvcnQgKiBmcm9tICcuL3Rvb2xzL3NwZWNIZWxwZXInO1xuZXhwb3J0IHsgRGF0YWNlbnRlciB9IGZyb20gJy4vZG9tYWluL3RyYW5zcG9ydENvbmZpZ3VyYXRpb24nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwidmFyIERFRkFVTFRfTElNSVQgPSAxMDAwMDtcbnZhciBCb3VuZGVkQnVmZmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJvdW5kZWRCdWZmZXIobGltaXQpIHtcbiAgICAgICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHsgbGltaXQgPSBERUZBVUxUX0xJTUlUOyB9XG4gICAgICAgIHRoaXMubGltaXQgPSBsaW1pdDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICB9XG4gICAgQm91bmRlZEJ1ZmZlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuYnVmZmVyLnB1c2goaXRlbSk7XG4gICAgICAgIGlmIChsZW5ndGggPiB0aGlzLmxpbWl0KSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5zcGxpY2UoMCwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJvdW5kZWRCdWZmZXIucHJvdG90eXBlLmRyYWluID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGZuKGl0ZW0pOyB9KTtcbiAgICAgICAgdGhpcy5idWZmZXIubGVuZ3RoID0gMDtcbiAgICB9O1xuICAgIHJldHVybiBCb3VuZGVkQnVmZmVyO1xufSgpKTtcbmV4cG9ydCB7IEJvdW5kZWRCdWZmZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvdW5kZWRCdWZmZXIuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIGNhdGNoVXNlckVycm9ycyhmbiwgZXJyb3JNc2cpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yTXNnLCBlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhdGNoVXNlckVycm9ycy5qcy5tYXAiLCJ2YXIgaXNDb250ZXh0QXJyYXkgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpOyB9O1xudmFyIGlzQ29udGV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbDtcbn07XG5leHBvcnQgZnVuY3Rpb24gY29tYmluZSgpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHNvdXJjZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGRlc3RpbmF0aW9uO1xuICAgIGZvciAodmFyIF9hID0gMCwgc291cmNlc18xID0gc291cmNlczsgX2EgPCBzb3VyY2VzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzXzFbX2FdO1xuICAgICAgICAvLyBJZ25vcmUgYW55IHVuZGVmaW5lZCBvciBudWxsIHNvdXJjZXMuXG4gICAgICAgIGlmIChzb3VyY2UgPT09IHVuZGVmaW5lZCB8fCBzb3VyY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGRlc3RpbmF0aW9uID0gbWVyZ2VJbnRvKGRlc3RpbmF0aW9uLCBzb3VyY2UsIGNyZWF0ZUNpcmN1bGFyUmVmZXJlbmNlQ2hlY2tlcigpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufVxuLypcbiAqIFBlcmZvcm1zIGEgZGVlcCBjbG9uZSBvZiBvYmplY3RzIGFuZCBhcnJheXMuXG4gKiAtIENpcmN1bGFyIHJlZmVyZW5jZXMgYXJlIHJlcGxhY2VkIGJ5ICd1bmRlZmluZWQnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWVwQ2xvbmUoY29udGV4dCkge1xuICAgIHJldHVybiBtZXJnZUludG8odW5kZWZpbmVkLCBjb250ZXh0LCBjcmVhdGVDaXJjdWxhclJlZmVyZW5jZUNoZWNrZXIoKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2lyY3VsYXJSZWZlcmVuY2VDaGVja2VyKCkge1xuICAgIGlmICh0eXBlb2YgV2Vha1NldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIHNldF8xID0gbmV3IFdlYWtTZXQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhhc0FscmVhZHlCZWVuU2VlbjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhcyA9IHNldF8xLmhhcyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0XzEuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIHJldHVybiB7XG4gICAgICAgIGhhc0FscmVhZHlCZWVuU2VlbjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgaGFzID0gYXJyYXkuaW5kZXhPZih2YWx1ZSkgPj0gMDtcbiAgICAgICAgICAgIGlmICghaGFzKSB7XG4gICAgICAgICAgICAgICAgYXJyYXkucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGFzO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIEl0ZXJhdGUgb3ZlciAnc291cmNlJyBhbmQgYWZmZWN0IGl0cyBzdWJ2YWx1ZXMgaW50byAnZGVzdGluYXRpb24nLCByZWN1cnNpdmVseS4gIElmIHRoZSAnc291cmNlJ1xuICogYW5kICdkZXN0aW5hdGlvbicgY2FuJ3QgYmUgbWVyZ2VkLCByZXR1cm4gJ3NvdXJjZScuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUludG8oZGVzdGluYXRpb24sIHNvdXJjZSwgY2lyY3VsYXJSZWZlcmVuY2VDaGVja2VyKSB7XG4gICAgLy8gSWdub3JlIHRoZSAnc291cmNlJyBpZiBpdCBpcyB1bmRlZmluZWRcbiAgICBpZiAoc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgJ3NvdXJjZScgaXMgbm90IGFuIG9iamVjdCBvciBhcnJheSwgaXQgY2FuJ3QgYmUgbWVyZ2VkIHdpdGggJ2Rlc3RpbmF0aW9uJyBpbiBhbnkgd2F5LCBzb1xuICAgIC8vIHJldHVybiBpdCBkaXJlY3RseS5cbiAgICBpZiAoIWlzQ29udGV4dChzb3VyY2UpICYmICFpc0NvbnRleHRBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuICAgIC8vIFJldHVybiAndW5kZWZpbmVkJyBpZiB3ZSBhbHJlYWR5IGl0ZXJhdGVkIG92ZXIgdGhpcyAnc291cmNlJyB0byBhdm9pZCBpbmZpbml0ZSByZWN1cnNpb25cbiAgICBpZiAoY2lyY3VsYXJSZWZlcmVuY2VDaGVja2VyLmhhc0FscmVhZHlCZWVuU2Vlbihzb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vICdzb3VyY2UnIGFuZCAnZGVzdGluYXRpb24nIGFyZSBvYmplY3RzLCBtZXJnZSB0aGVtIHRvZ2V0aGVyXG4gICAgaWYgKGlzQ29udGV4dChzb3VyY2UpICYmIChkZXN0aW5hdGlvbiA9PT0gdW5kZWZpbmVkIHx8IGlzQ29udGV4dChkZXN0aW5hdGlvbikpKSB7XG4gICAgICAgIHZhciBmaW5hbERlc3RpbmF0aW9uID0gZGVzdGluYXRpb24gfHwge307XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgZmluYWxEZXN0aW5hdGlvbltrZXldID0gbWVyZ2VJbnRvKGZpbmFsRGVzdGluYXRpb25ba2V5XSwgc291cmNlW2tleV0sIGNpcmN1bGFyUmVmZXJlbmNlQ2hlY2tlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbmFsRGVzdGluYXRpb247XG4gICAgfVxuICAgIC8vICdzb3VyY2UnIGFuZCAnZGVzdGluYXRpb24nIGFyZSBhcnJheXMsIG1lcmdlIHRoZW0gdG9nZXRoZXJcbiAgICBpZiAoaXNDb250ZXh0QXJyYXkoc291cmNlKSAmJiAoZGVzdGluYXRpb24gPT09IHVuZGVmaW5lZCB8fCBpc0NvbnRleHRBcnJheShkZXN0aW5hdGlvbikpKSB7XG4gICAgICAgIHZhciBmaW5hbERlc3RpbmF0aW9uID0gZGVzdGluYXRpb24gfHwgW107XG4gICAgICAgIGZpbmFsRGVzdGluYXRpb24ubGVuZ3RoID0gTWF0aC5tYXgoZmluYWxEZXN0aW5hdGlvbi5sZW5ndGgsIHNvdXJjZS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc291cmNlLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgICAgZmluYWxEZXN0aW5hdGlvbltpbmRleF0gPSBtZXJnZUludG8oZmluYWxEZXN0aW5hdGlvbltpbmRleF0sIHNvdXJjZVtpbmRleF0sIGNpcmN1bGFyUmVmZXJlbmNlQ2hlY2tlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbmFsRGVzdGluYXRpb247XG4gICAgfVxuICAgIC8vIFRoZSBkZXN0aW5hdGlvbiBpbiBub3QgYW4gYXJyYXkgbm9yIGFuIG9iamVjdCwgc28gd2UgY2FuJ3QgbWVyZ2UgaXRcbiAgICByZXR1cm4gc291cmNlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGV4dC5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29udGV4dE1hbmFnZXIoKSB7XG4gICAgdmFyIGNvbnRleHQgPSB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRleHQ7IH0sXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnRleHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb250ZXh0W2tleV07XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0NvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBuZXdDb250ZXh0O1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250ZXh0TWFuYWdlci5qcy5tYXAiLCJpbXBvcnQgeyBqc29uU3RyaW5naWZ5IH0gZnJvbSAnLi91dGlscyc7XG5leHBvcnQgdmFyIEVycm9yU291cmNlID0ge1xuICAgIEFHRU5UOiAnYWdlbnQnLFxuICAgIENPTlNPTEU6ICdjb25zb2xlJyxcbiAgICBDVVNUT006ICdjdXN0b20nLFxuICAgIExPR0dFUjogJ2xvZ2dlcicsXG4gICAgTkVUV09SSzogJ25ldHdvcmsnLFxuICAgIFNPVVJDRTogJ3NvdXJjZScsXG59O1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFVua25vd25FcnJvcihzdGFja1RyYWNlLCBlcnJvck9iamVjdCwgbm9uRXJyb3JQcmVmaXgpIHtcbiAgICBpZiAoIXN0YWNrVHJhY2UgfHwgKHN0YWNrVHJhY2UubWVzc2FnZSA9PT0gdW5kZWZpbmVkICYmICEoZXJyb3JPYmplY3QgaW5zdGFuY2VvZiBFcnJvcikpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBub25FcnJvclByZWZpeCArIFwiIFwiICsganNvblN0cmluZ2lmeShlcnJvck9iamVjdCksXG4gICAgICAgICAgICBzdGFjazogJ05vIHN0YWNrLCBjb25zaWRlciB1c2luZyBhbiBpbnN0YW5jZSBvZiBFcnJvcicsXG4gICAgICAgICAgICB0eXBlOiBzdGFja1RyYWNlICYmIHN0YWNrVHJhY2UubmFtZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWVzc2FnZTogc3RhY2tUcmFjZS5tZXNzYWdlIHx8ICdFbXB0eSBtZXNzYWdlJyxcbiAgICAgICAgc3RhY2s6IHRvU3RhY2tUcmFjZVN0cmluZyhzdGFja1RyYWNlKSxcbiAgICAgICAgdHlwZTogc3RhY2tUcmFjZS5uYW1lLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdG9TdGFja1RyYWNlU3RyaW5nKHN0YWNrKSB7XG4gICAgdmFyIHJlc3VsdCA9IGZvcm1hdEVycm9yTWVzc2FnZShzdGFjayk7XG4gICAgc3RhY2suc3RhY2suZm9yRWFjaChmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBmcmFtZS5mdW5jID09PSAnPycgPyAnPGFub255bW91cz4nIDogZnJhbWUuZnVuYztcbiAgICAgICAgdmFyIGFyZ3MgPSBmcmFtZS5hcmdzICYmIGZyYW1lLmFyZ3MubGVuZ3RoID4gMCA/IFwiKFwiICsgZnJhbWUuYXJncy5qb2luKCcsICcpICsgXCIpXCIgOiAnJztcbiAgICAgICAgdmFyIGxpbmUgPSBmcmFtZS5saW5lID8gXCI6XCIgKyBmcmFtZS5saW5lIDogJyc7XG4gICAgICAgIHZhciBjb2x1bW4gPSBmcmFtZS5saW5lICYmIGZyYW1lLmNvbHVtbiA/IFwiOlwiICsgZnJhbWUuY29sdW1uIDogJyc7XG4gICAgICAgIHJlc3VsdCArPSBcIlxcbiAgYXQgXCIgKyBmdW5jICsgYXJncyArIFwiIEAgXCIgKyBmcmFtZS51cmwgKyBsaW5lICsgY29sdW1uO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RXJyb3JNZXNzYWdlKHN0YWNrKSB7XG4gICAgcmV0dXJuIChzdGFjay5uYW1lIHx8ICdFcnJvcicpICsgXCI6IFwiICsgc3RhY2subWVzc2FnZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yLmpzLm1hcCIsImltcG9ydCB7IGRlZXBDbG9uZSB9IGZyb20gJy4vY29udGV4dCc7XG4vKipcbiAqIEN1cnJlbnQgbGltaXRhdGlvbnM6XG4gKiAtIGZpZWxkIHBhdGggZG8gbm90IHN1cHBvcnQgYXJyYXksICdhLmIuYycgb25seVxuICogLSBtb2RpZmlhYmxlIGZpZWxkcyB0eXBlIG11c3QgYmUgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW1pdE1vZGlmaWNhdGlvbihvYmplY3QsIG1vZGlmaWFibGVGaWVsZFBhdGhzLCBtb2RpZmllcikge1xuICAgIHZhciBjbG9uZSA9IGRlZXBDbG9uZShvYmplY3QpO1xuICAgIHZhciByZXN1bHQgPSBtb2RpZmllcihjbG9uZSk7XG4gICAgbW9kaWZpYWJsZUZpZWxkUGF0aHMuZm9yRWFjaChmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSBnZXQoY2xvbmUsIHBhdGgpO1xuICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmFsVmFsdWUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNldChvYmplY3QsIHBhdGgsIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBvYmplY3Q7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHBhdGguc3BsaXQoJy4nKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGZpZWxkID0gX2FbX2ldO1xuICAgICAgICBpZiAoIWlzVmFsaWRPYmplY3RDb250YWluaW5nKGN1cnJlbnQsIGZpZWxkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W2ZpZWxkXTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICAgIHZhciBjdXJyZW50ID0gb2JqZWN0O1xuICAgIHZhciBmaWVsZHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICBpZiAoIWlzVmFsaWRPYmplY3RDb250YWluaW5nKGN1cnJlbnQsIGZpZWxkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpICE9PSBmaWVsZHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbZmllbGRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudFtmaWVsZF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzVmFsaWRPYmplY3RDb250YWluaW5nKG9iamVjdCwgZmllbGQpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIGZpZWxkIGluIG9iamVjdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0TW9kaWZpY2F0aW9uLmpzLm1hcCIsInZhciBPYnNlcnZhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9ic2VydmFibGUoKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XG4gICAgfVxuICAgIE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2goZik7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLm9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlcikgeyByZXR1cm4gb2JzZXJ2ZXIoZGF0YSk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmFibGU7XG59KCkpO1xuZXhwb3J0IHsgT2JzZXJ2YWJsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2YWJsZS5qcy5tYXAiLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgbm9vcCwgb2JqZWN0RW50cmllcyB9IGZyb20gJy4vdXRpbHMnO1xuZXhwb3J0IHZhciBTUEVDX0VORFBPSU5UUyA9IHtcbiAgICBpbnRlcm5hbE1vbml0b3JpbmdFbmRwb2ludDogJ2h0dHBzOi8vbW9uaXRvcmluZy1pbnRha2UuY29tL3YxL2lucHV0L2FiY2RlP2Zvbz1iYXInLFxuICAgIGxvZ3NFbmRwb2ludDogJ2h0dHBzOi8vbG9ncy1pbnRha2UuY29tL3YxL2lucHV0L2FiY2RlP2Zvbz1iYXInLFxuICAgIHJ1bUVuZHBvaW50OiAnaHR0cHM6Ly9ydW0taW50YWtlLmNvbS92MS9pbnB1dC9hYmNkZT9mb289YmFyJyxcbiAgICB0cmFjZUVuZHBvaW50OiAnaHR0cHM6Ly90cmFjZS1pbnRha2UuY29tL3YxL2lucHV0L2FiY2RlP2Zvbz1iYXInLFxuICAgIGlzSW50YWtlVXJsOiBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHZhciBpbnRha2VVcmxzID0gW1xuICAgICAgICAgICAgJ2h0dHBzOi8vbW9uaXRvcmluZy1pbnRha2UuY29tL3YxL2lucHV0LycsXG4gICAgICAgICAgICAnaHR0cHM6Ly9sb2dzLWludGFrZS5jb20vdjEvaW5wdXQvJyxcbiAgICAgICAgICAgICdodHRwczovL3J1bS1pbnRha2UuY29tL3YxL2lucHV0LycsXG4gICAgICAgICAgICAnaHR0cHM6Ly90cmFjZS1pbnRha2UuY29tL3YxL2lucHV0LycsXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBpbnRha2VVcmxzLnNvbWUoZnVuY3Rpb24gKGludGFrZVVybCkgeyByZXR1cm4gdXJsLmluZGV4T2YoaW50YWtlVXJsKSA9PT0gMDsgfSk7XG4gICAgfSxcbn07XG5leHBvcnQgZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gICAgcmV0dXJuIC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNGaXJlZm94KCkge1xuICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZmlyZWZveCcpID4gLTE7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNJRSgpIHtcbiAgICB2YXIgaGFzSUVBZ2VudCA9IC9UcmlkZW50LipydlxcOjExXFwuLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01TSUUgJykgPiAwIHx8IGhhc0lFQWdlbnQ7XG59XG5leHBvcnQgZnVuY3Rpb24gY2xlYXJBbGxDb29raWVzKCkge1xuICAgIGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgZG9jdW1lbnQuY29va2llID0gYy5yZXBsYWNlKC89LiovLCBcIj07ZXhwaXJlcz1cIiArIG5ldyBEYXRlKCkudG9VVENTdHJpbmcoKSArIFwiO3BhdGg9LztzYW1lc2l0ZT1zdHJpY3RcIik7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc3R1YkZldGNoKCkge1xuICAgIHZhciBvcmlnaW5hbEZldGNoID0gd2luZG93LmZldGNoO1xuICAgIHZhciBhbGxGZXRjaENvbXBsZXRlQ2FsbGJhY2sgPSBub29wO1xuICAgIHZhciBwZW5kaW5nUmVxdWVzdHMgPSAwO1xuICAgIGZ1bmN0aW9uIG9uUmVxdWVzdEVuZCgpIHtcbiAgICAgICAgcGVuZGluZ1JlcXVlc3RzIC09IDE7XG4gICAgICAgIGlmIChwZW5kaW5nUmVxdWVzdHMgPT09IDApIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gYWxsRmV0Y2hDb21wbGV0ZUNhbGxiYWNrKCk7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdpbmRvdy5mZXRjaCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0cyArPSAxO1xuICAgICAgICB2YXIgcmVzb2x2ZTtcbiAgICAgICAgdmFyIHJlamVjdDtcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzLCByZWopIHtcbiAgICAgICAgICAgIHJlc29sdmUgPSByZXM7XG4gICAgICAgICAgICByZWplY3QgPSByZWo7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9taXNlLnJlc29sdmVXaXRoID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXNvbHZlKF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXNwb25zZSksIHsgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsb25lZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UucmVzcG9uc2VUZXh0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlc3BvbnNlLnJlc3BvbnNlVGV4dEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZS5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICAgICAgICAgICAgICB9IH0pKTtcbiAgICAgICAgICAgIG9uUmVxdWVzdEVuZCgpO1xuICAgICAgICB9O1xuICAgICAgICBwcm9taXNlLnJlamVjdFdpdGggPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICBvblJlcXVlc3RFbmQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2hlbkFsbENvbXBsZXRlOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGFsbEZldGNoQ29tcGxldGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB9LFxuICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgd2luZG93LmZldGNoID0gb3JpZ2luYWxGZXRjaDtcbiAgICAgICAgICAgIGFsbEZldGNoQ29tcGxldGVDYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbnZhciBTdHViWGhyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0dWJYaHIoKSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBYTUxIdHRwUmVxdWVzdC5VTlNFTlQ7XG4gICAgICAgIHRoaXMub25yZWFkeXN0YXRlY2hhbmdlID0gbm9vcDtcbiAgICAgICAgdGhpcy5oYXNFbmRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZha2VFdmVudFRhcmdldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb24sQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4gICAgU3R1Ylhoci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChtZXRob2QsIHVybCkgeyB9O1xuICAgIFN0dWJYaHIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb24sQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4gICAgU3R1Ylhoci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gMDtcbiAgICAgICAgaWYgKHRoaXMuaGFzRW5kZWQpIHtcbiAgICAgICAgICAgIC8vIENhbGxpbmcgeGhyLmFib3J0KCkgb24gYW4gZW5kZWQgcmVxdWVzdCBkb2VzIG5vdCB0cmlnZ2VyIGV2ZW50c1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFzRW5kZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBYTUxIdHRwUmVxdWVzdC5ET05FO1xuICAgICAgICB0aGlzLm9ucmVhZHlzdGF0ZWNoYW5nZSgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ2Fib3J0Jyk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnbG9hZGVuZCcpO1xuICAgIH07XG4gICAgU3R1Ylhoci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoc3RhdHVzLCByZXNwb25zZSkge1xuICAgICAgICBpZiAodGhpcy5oYXNFbmRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY2FsbCBjb21wbGV0ZSgpIG9uIGEgZW5kZWQgcmVxdWVzdFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc0VuZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gWE1MSHR0cFJlcXVlc3QuRE9ORTtcbiAgICAgICAgdGhpcy5vbnJlYWR5c3RhdGVjaGFuZ2UoKTtcbiAgICAgICAgaWYgKHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgNTAwKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ2xvYWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID49IDUwMCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdlcnJvcicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnbG9hZGVuZCcpO1xuICAgIH07XG4gICAgU3R1Ylhoci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmZha2VFdmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFN0dWJYaHIucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB0aGlzLmZha2VFdmVudFRhcmdldC5kaXNwYXRjaEV2ZW50KGNyZWF0ZU5ld0V2ZW50KG5hbWUpKTtcbiAgICB9O1xuICAgIHJldHVybiBTdHViWGhyO1xufSgpKTtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVOZXdFdmVudChldmVudE5hbWUsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAocHJvcGVydGllcyA9PT0gdm9pZCAwKSB7IHByb3BlcnRpZXMgPSB7fTsgfVxuICAgIHZhciBldmVudDtcbiAgICBpZiAodHlwZW9mIEV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGV2ZW50ID0gbmV3IEV2ZW50KGV2ZW50TmFtZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgICBldmVudC5pbml0RXZlbnQoZXZlbnROYW1lLCB0cnVlLCB0cnVlKTtcbiAgICB9XG4gICAgb2JqZWN0RW50cmllcyhwcm9wZXJ0aWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbmFtZSA9IF9hWzBdLCB2YWx1ZSA9IF9hWzFdO1xuICAgICAgICAvLyBTZXR0aW5nIHZhbHVlcyBkaXJlY3RseSBvciB3aXRoIGEgYHZhbHVlYCBkZXNjcmlwdG9yIHNlZW1zIHVuc3VwcG9ydGVkIGluIElFMTFcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV2ZW50LCBuYW1lLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXZlbnQ7XG59XG5leHBvcnQgZnVuY3Rpb24gc3R1YlhocigpIHtcbiAgICB2YXIgb3JpZ2luYWxYaHIgPSBYTUxIdHRwUmVxdWVzdDtcbiAgICBYTUxIdHRwUmVxdWVzdCA9IFN0dWJYaHI7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFhNTEh0dHBSZXF1ZXN0ID0gb3JpZ2luYWxYaHI7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3aXRoWGhyKF9hKSB7XG4gICAgdmFyIHNldHVwID0gX2Euc2V0dXAsIG9uQ29tcGxldGUgPSBfYS5vbkNvbXBsZXRlO1xuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvbkNvbXBsZXRlKHhocik7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHNldHVwKHhocik7XG59XG5leHBvcnQgZnVuY3Rpb24gc2V0UGFnZVZpc2liaWxpdHkodmlzaWJpbGl0eSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkb2N1bWVudCwgJ3Zpc2liaWxpdHlTdGF0ZScsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlzaWJpbGl0eTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVQYWdlVmlzaWJpbGl0eSgpIHtcbiAgICBkZWxldGUgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3BlY0hlbHBlci5qcy5tYXAiLCJpbXBvcnQgeyBpc051bWJlciwgcm91bmQgfSBmcm9tICcuL3V0aWxzJztcbmV4cG9ydCBmdW5jdGlvbiB0b1NlcnZlckR1cmF0aW9uKGR1cmF0aW9uKSB7XG4gICAgaWYgKCFpc051bWJlcihkdXJhdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gcm91bmQoZHVyYXRpb24gKiAxZTYsIDApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVTdGFtcE5vdygpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWxhdGl2ZU5vdygpIHtcbiAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZWxhcHNlZChzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCk7XG59XG4vKipcbiAqIEdldCB0aGUgdGltZSBzaW5jZSB0aGUgbmF2aWdhdGlvbiB3YXMgc3RhcnRlZC5cbiAqXG4gKiBOb3RlOiB0aGlzIGRvZXMgbm90IHVzZSBgcGVyZm9ybWFuY2UudGltZU9yaWdpbmAgYmVjYXVzZSBpdCBkb2Vzbid0IHNlZW0gdG8gcmVmbGVjdCB0aGUgYWN0dWFsXG4gKiB0aW1lIG9uIHdoaWNoIHRoZSBuYXZpZ2F0aW9uIGhhcyBzdGFydGVkOiBpdCBtYXkgYmUgbXVjaCBmYXJ0aGVyIGluIHRoZSBwYXN0LCBhdCBsZWFzdCBpbiBGaXJlZm94IDcxLlxuICogUmVsYXRlZCBpc3N1ZSBpbiBGaXJlZm94OiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI5OTI2XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWxhdGl2ZVRpbWUodGltZXN0YW1wKSB7XG4gICAgcmV0dXJuICh0aW1lc3RhbXAgLSBnZXROYXZpZ2F0aW9uU3RhcnQoKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0VGltZVN0YW1wKHJlbGF0aXZlVGltZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kc1xuICAgIHJldHVybiBNYXRoLmZsb29yKGdldE5hdmlnYXRpb25TdGFydCgpICsgcmVsYXRpdmVUaW1lKTtcbn1cbi8qKlxuICogTmF2aWdhdGlvbiBzdGFydCBzbGlnaHRseSBjaGFuZ2Ugb24gc29tZSByYXJlIGNhc2VzXG4gKi9cbnZhciBuYXZpZ2F0aW9uU3RhcnQ7XG5mdW5jdGlvbiBnZXROYXZpZ2F0aW9uU3RhcnQoKSB7XG4gICAgaWYgKG5hdmlnYXRpb25TdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5hdmlnYXRpb25TdGFydCA9IHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBuYXZpZ2F0aW9uU3RhcnQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lVXRpbHMuanMubWFwIiwiaW1wb3J0IHsgZ2V0TGlua0VsZW1lbnRPcmlnaW4sIGdldExvY2F0aW9uT3JpZ2luIH0gZnJvbSAnLi91dGlscyc7XG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplVXJsKHVybCkge1xuICAgIHJldHVybiBidWlsZFVybCh1cmwsIGdldExvY2F0aW9uT3JpZ2luKCkpLmhyZWY7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFVybCh1cmwpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gISFidWlsZFVybCh1cmwpO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXZlU2FtZU9yaWdpbih1cmwxLCB1cmwyKSB7XG4gICAgcmV0dXJuIGdldE9yaWdpbih1cmwxKSA9PT0gZ2V0T3JpZ2luKHVybDIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE9yaWdpbih1cmwpIHtcbiAgICByZXR1cm4gZ2V0TGlua0VsZW1lbnRPcmlnaW4oYnVpbGRVcmwodXJsKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UGF0aE5hbWUodXJsKSB7XG4gICAgdmFyIHBhdGhuYW1lID0gYnVpbGRVcmwodXJsKS5wYXRobmFtZTtcbiAgICByZXR1cm4gcGF0aG5hbWVbMF0gPT09ICcvJyA/IHBhdGhuYW1lIDogXCIvXCIgKyBwYXRobmFtZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWFyY2godXJsKSB7XG4gICAgcmV0dXJuIGJ1aWxkVXJsKHVybCkuc2VhcmNoO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEhhc2godXJsKSB7XG4gICAgcmV0dXJuIGJ1aWxkVXJsKHVybCkuaGFzaDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFVybCh1cmwsIGJhc2UpIHtcbiAgICBpZiAoY2hlY2tVUkxTdXBwb3J0ZWQoKSkge1xuICAgICAgICByZXR1cm4gYmFzZSAhPT0gdW5kZWZpbmVkID8gbmV3IFVSTCh1cmwsIGJhc2UpIDogbmV3IFVSTCh1cmwpO1xuICAgIH1cbiAgICBpZiAoYmFzZSA9PT0gdW5kZWZpbmVkICYmICEvOi8udGVzdCh1cmwpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgVVJMOiAnXCIgKyB1cmwgKyBcIidcIik7XG4gICAgfVxuICAgIHZhciBkb2MgPSBkb2N1bWVudDtcbiAgICB2YXIgYW5jaG9yRWxlbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgaWYgKGJhc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJycpO1xuICAgICAgICB2YXIgYmFzZUVsZW1lbnQgPSBkb2MuY3JlYXRlRWxlbWVudCgnYmFzZScpO1xuICAgICAgICBiYXNlRWxlbWVudC5ocmVmID0gYmFzZTtcbiAgICAgICAgZG9jLmhlYWQuYXBwZW5kQ2hpbGQoYmFzZUVsZW1lbnQpO1xuICAgICAgICBkb2MuYm9keS5hcHBlbmRDaGlsZChhbmNob3JFbGVtZW50KTtcbiAgICB9XG4gICAgYW5jaG9yRWxlbWVudC5ocmVmID0gdXJsO1xuICAgIHJldHVybiBhbmNob3JFbGVtZW50O1xufVxudmFyIGlzVVJMU3VwcG9ydGVkO1xuZnVuY3Rpb24gY2hlY2tVUkxTdXBwb3J0ZWQoKSB7XG4gICAgaWYgKGlzVVJMU3VwcG9ydGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGlzVVJMU3VwcG9ydGVkO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB2YXIgdXJsID0gbmV3IFVSTCgnaHR0cDovL3Rlc3QvcGF0aCcpO1xuICAgICAgICBpc1VSTFN1cHBvcnRlZCA9IHVybC5ocmVmID09PSAnaHR0cDovL3Rlc3QvcGF0aCc7XG4gICAgICAgIHJldHVybiBpc1VSTFN1cHBvcnRlZDtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIGlzVVJMU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc1VSTFN1cHBvcnRlZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybFBvbHlmaWxsLmpzLm1hcCIsImltcG9ydCB7IG1vbml0b3IgfSBmcm9tICcuLi9kb21haW4vaW50ZXJuYWxNb25pdG9yaW5nJztcbmV4cG9ydCB2YXIgT05FX1NFQ09ORCA9IDEwMDA7XG5leHBvcnQgdmFyIE9ORV9NSU5VVEUgPSA2MCAqIE9ORV9TRUNPTkQ7XG5leHBvcnQgdmFyIE9ORV9IT1VSID0gNjAgKiBPTkVfTUlOVVRFO1xuZXhwb3J0IHZhciBPTkVfS0lMT19CWVRFID0gMTAyNDtcbmV4cG9ydCB2YXIgUmVzb3VyY2VUeXBlO1xuKGZ1bmN0aW9uIChSZXNvdXJjZVR5cGUpIHtcbiAgICBSZXNvdXJjZVR5cGVbXCJET0NVTUVOVFwiXSA9IFwiZG9jdW1lbnRcIjtcbiAgICBSZXNvdXJjZVR5cGVbXCJYSFJcIl0gPSBcInhoclwiO1xuICAgIFJlc291cmNlVHlwZVtcIkJFQUNPTlwiXSA9IFwiYmVhY29uXCI7XG4gICAgUmVzb3VyY2VUeXBlW1wiRkVUQ0hcIl0gPSBcImZldGNoXCI7XG4gICAgUmVzb3VyY2VUeXBlW1wiQ1NTXCJdID0gXCJjc3NcIjtcbiAgICBSZXNvdXJjZVR5cGVbXCJKU1wiXSA9IFwianNcIjtcbiAgICBSZXNvdXJjZVR5cGVbXCJJTUFHRVwiXSA9IFwiaW1hZ2VcIjtcbiAgICBSZXNvdXJjZVR5cGVbXCJGT05UXCJdID0gXCJmb250XCI7XG4gICAgUmVzb3VyY2VUeXBlW1wiTUVESUFcIl0gPSBcIm1lZGlhXCI7XG4gICAgUmVzb3VyY2VUeXBlW1wiT1RIRVJcIl0gPSBcIm90aGVyXCI7XG59KShSZXNvdXJjZVR5cGUgfHwgKFJlc291cmNlVHlwZSA9IHt9KSk7XG5leHBvcnQgdmFyIFJlcXVlc3RUeXBlO1xuKGZ1bmN0aW9uIChSZXF1ZXN0VHlwZSkge1xuICAgIFJlcXVlc3RUeXBlW1wiRkVUQ0hcIl0gPSBcImZldGNoXCI7XG4gICAgUmVxdWVzdFR5cGVbXCJYSFJcIl0gPSBcInhoclwiO1xufSkoUmVxdWVzdFR5cGUgfHwgKFJlcXVlc3RUeXBlID0ge30pKTtcbi8vIHVzZSBsb2Rhc2ggQVBJXG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGUoZm4sIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgbmVlZExlYWRpbmdFeGVjdXRpb24gPSBvcHRpb25zICYmIG9wdGlvbnMubGVhZGluZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5sZWFkaW5nIDogdHJ1ZTtcbiAgICB2YXIgbmVlZFRyYWlsaW5nRXhlY3V0aW9uID0gb3B0aW9ucyAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRyYWlsaW5nIDogdHJ1ZTtcbiAgICB2YXIgaW5XYWl0UGVyaW9kID0gZmFsc2U7XG4gICAgdmFyIHBlbmRpbmdFeGVjdXRpb25XaXRoUGFyYW1ldGVycztcbiAgICB2YXIgcGVuZGluZ1RpbWVvdXRJZDtcbiAgICByZXR1cm4ge1xuICAgICAgICB0aHJvdHRsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbldhaXRQZXJpb2QpIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nRXhlY3V0aW9uV2l0aFBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZWVkTGVhZGluZ0V4ZWN1dGlvbikge1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KHZvaWQgMCwgcGFyYW1ldGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nRXhlY3V0aW9uV2l0aFBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5XYWl0UGVyaW9kID0gdHJ1ZTtcbiAgICAgICAgICAgIHBlbmRpbmdUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAobmVlZFRyYWlsaW5nRXhlY3V0aW9uICYmIHBlbmRpbmdFeGVjdXRpb25XaXRoUGFyYW1ldGVycykge1xuICAgICAgICAgICAgICAgICAgICBmbi5hcHBseSh2b2lkIDAsIHBlbmRpbmdFeGVjdXRpb25XaXRoUGFyYW1ldGVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluV2FpdFBlcmlvZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHBlbmRpbmdFeGVjdXRpb25XaXRoUGFyYW1ldGVycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0sIHdhaXQpO1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChwZW5kaW5nVGltZW91dElkKTtcbiAgICAgICAgICAgIGluV2FpdFBlcmlvZCA9IGZhbHNlO1xuICAgICAgICAgICAgcGVuZGluZ0V4ZWN1dGlvbldpdGhQYXJhbWV0ZXJzID0gdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgIHZhciB0b0Fzc2lnbiA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHRvQXNzaWduW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB0b0Fzc2lnbi5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIFVVSUQgdjRcbiAqIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamVkLzk4Mjg4M1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKHBsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIHBsYWNlaG9sZGVyXG4gICAgICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lICBuby1iaXR3aXNlXG4gICAgICAgICAgICAocGFyc2VJbnQocGxhY2Vob2xkZXIsIDEwKSBeICgoTWF0aC5yYW5kb20oKSAqIDE2KSA+PiAocGFyc2VJbnQocGxhY2Vob2xkZXIsIDEwKSAvIDQpKSkudG9TdHJpbmcoMTYpXG4gICAgICAgIDogKDFlNyArIFwiLVwiICsgMWUzICsgXCItXCIgKyA0ZTMgKyBcIi1cIiArIDhlMyArIFwiLVwiICsgMWUxMSkucmVwbGFjZSgvWzAxOF0vZywgZ2VuZXJhdGVVVUlEKTtcbn1cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIGRyYXcgaXMgc3VjY2Vzc2Z1bFxuICogQHBhcmFtIHRocmVzaG9sZCBiZXR3ZWVuIDAgYW5kIDEwMFxuICovXG5leHBvcnQgZnVuY3Rpb24gcGVyZm9ybURyYXcodGhyZXNob2xkKSB7XG4gICAgcmV0dXJuIHRocmVzaG9sZCAhPT0gMCAmJiBNYXRoLnJhbmRvbSgpICogMTAwIDw9IHRocmVzaG9sZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChudW0sIGRlY2ltYWxzKSB7XG4gICAgcmV0dXJuICtudW0udG9GaXhlZChkZWNpbWFscyk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHsgfVxuLyoqXG4gKiBDdXN0b20gaW1wbGVtZW50YXRpb24gb2YgSlNPTi5zdHJpbmdpZnkgdGhhdCBpZ25vcmVzIHZhbHVlLnRvSlNPTi5cbiAqIFdlIG5lZWQgdG8gZG8gdGhhdCBiZWNhdXNlIHNvbWUgc2l0ZXMgYmFkbHkgb3ZlcnJpZGUgdG9KU09OIG9uIGNlcnRhaW4gb2JqZWN0cy5cbiAqIE5vdGUgdGhpcyBzdGlsbCBzdXBwb3NlcyB0aGF0IEpTT04uc3RyaW5naWZ5IGlzIGNvcnJlY3QuLi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGpzb25TdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuICAgIHZhciBvcmlnaW5hbFRvSlNPTiA9IFtmYWxzZSwgdW5kZWZpbmVkXTtcbiAgICBpZiAoaGFzVG9KU09OKHZhbHVlKSkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGFkZCBhIGZsYWcgYW5kIG5vdCByZWx5IG9uIHRoZSB0cnV0aGluZXNzIG9mIHZhbHVlLnRvSlNPTlxuICAgICAgICAvLyBiZWNhdXNlIGl0IGNhbiBiZSBzZXQgYnV0IHVuZGVmaW5lZCBhbmQgdGhhdCdzIGFjdHVhbGx5IHNpZ25pZmljYW50LlxuICAgICAgICBvcmlnaW5hbFRvSlNPTiA9IFt0cnVlLCB2YWx1ZS50b0pTT05dO1xuICAgICAgICBkZWxldGUgdmFsdWUudG9KU09OO1xuICAgIH1cbiAgICB2YXIgb3JpZ2luYWxQcm90b1RvSlNPTiA9IFtmYWxzZSwgdW5kZWZpbmVkXTtcbiAgICB2YXIgcHJvdG90eXBlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gICAgICAgIGlmIChoYXNUb0pTT04ocHJvdG90eXBlKSkge1xuICAgICAgICAgICAgb3JpZ2luYWxQcm90b1RvSlNPTiA9IFt0cnVlLCBwcm90b3R5cGUudG9KU09OXTtcbiAgICAgICAgICAgIGRlbGV0ZSBwcm90b3R5cGUudG9KU09OO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSk7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXN1bHQgPSAnPGVycm9yOiB1bmFibGUgdG8gc2VyaWFsaXplIG9iamVjdD4nO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG9yaWdpbmFsVG9KU09OWzBdKSB7XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICB2YWx1ZS50b0pTT04gPSBvcmlnaW5hbFRvSlNPTlsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZ2luYWxQcm90b1RvSlNPTlswXSkge1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgcHJvdG90eXBlLnRvSlNPTiA9IG9yaWdpbmFsUHJvdG9Ub0pTT05bMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGhhc1RvSlNPTih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlLmhhc093blByb3BlcnR5KCd0b0pTT04nKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpbmNsdWRlcyhjYW5kaWRhdGUsIHNlYXJjaCkge1xuICAgIHJldHVybiBjYW5kaWRhdGUuaW5kZXhPZihzZWFyY2gpICE9PSAtMTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaW5kKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgICAgIGlmIChwcmVkaWNhdGUoaXRlbSwgaSwgYXJyYXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUGVyY2VudGFnZSh2YWx1ZSkge1xuICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSAxMDA7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBvYmplY3RWYWx1ZXMob2JqZWN0KSB7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKG9iamVjdFtrZXldKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWVzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdEVudHJpZXMob2JqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCkubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIFtrZXksIG9iamVjdFtrZXldXTsgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNFbXB0eU9iamVjdChvYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqZWN0KS5sZW5ndGggPT09IDA7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdCwgZm4pIHtcbiAgICB2YXIgbmV3T2JqZWN0ID0ge307XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKG9iamVjdCk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBfYVtfaV07XG4gICAgICAgIG5ld09iamVjdFtrZXldID0gZm4ob2JqZWN0W2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3T2JqZWN0O1xufVxuLyoqXG4gKiBpbnNwaXJlZCBieSBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvZ2xvYmFsdGhpc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2xvYmFsT2JqZWN0KCkge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QucHJvdG90eXBlLCAnX2RkX3RlbXBfJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgfSk7XG4gICAgLy8gQHRzLWlnbm9yZSBfZGRfdGVtcCBpcyBkZWZpbmVkIHVzaW5nIGRlZmluZVByb3BlcnR5XG4gICAgdmFyIGdsb2JhbE9iamVjdCA9IF9kZF90ZW1wXztcbiAgICAvLyBAdHMtaWdub3JlIF9kZF90ZW1wIGlzIGRlZmluZWQgdXNpbmcgZGVmaW5lUHJvcGVydHlcbiAgICBkZWxldGUgT2JqZWN0LnByb3RvdHlwZS5fZGRfdGVtcF87IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGVcbiAgICBpZiAodHlwZW9mIGdsb2JhbE9iamVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gb24gc2FmYXJpIF9kZF90ZW1wXyBpcyBhdmFpbGFibGUgb24gd2luZG93IGJ1dCBub3QgZ2xvYmFsbHlcbiAgICAgICAgLy8gZmFsbGJhY2sgb24gb3RoZXIgYnJvd3NlciBnbG9iYWxzIGNoZWNrXG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGdsb2JhbE9iamVjdCA9IHNlbGY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGdsb2JhbE9iamVjdCA9IHdpbmRvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbE9iamVjdCA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnbG9iYWxPYmplY3Q7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9jYXRpb25PcmlnaW4oKSB7XG4gICAgcmV0dXJuIGdldExpbmtFbGVtZW50T3JpZ2luKHdpbmRvdy5sb2NhdGlvbik7XG59XG4vKipcbiAqIElFIGZhbGxiYWNrXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTEh5cGVybGlua0VsZW1lbnRVdGlscy9vcmlnaW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExpbmtFbGVtZW50T3JpZ2luKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC5vcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQub3JpZ2luO1xuICAgIH1cbiAgICB2YXIgc2FuaXRpemVkSG9zdCA9IGVsZW1lbnQuaG9zdC5yZXBsYWNlKC8oOjgwfDo0NDMpJC8sICcnKTtcbiAgICByZXR1cm4gZWxlbWVudC5wcm90b2NvbCArIFwiLy9cIiArIHNhbml0aXplZEhvc3Q7XG59XG5leHBvcnQgZnVuY3Rpb24gZmluZENvbW1hU2VwYXJhdGVkVmFsdWUocmF3U3RyaW5nLCBuYW1lKSB7XG4gICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChcIig/Ol58OylcXFxccypcIiArIG5hbWUgKyBcIlxcXFxzKj1cXFxccyooW147XSspXCIpO1xuICAgIHZhciBtYXRjaGVzID0gcmVnZXguZXhlYyhyYXdTdHJpbmcpO1xuICAgIHJldHVybiBtYXRjaGVzID8gbWF0Y2hlc1sxXSA6IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzYWZlVHJ1bmNhdGUoY2FuZGlkYXRlLCBsZW5ndGgpIHtcbiAgICB2YXIgbGFzdENoYXIgPSBjYW5kaWRhdGUuY2hhckNvZGVBdChsZW5ndGggLSAxKTtcbiAgICAvLyBjaGVjayBpZiBpdCBpcyB0aGUgaGlnaCBwYXJ0IG9mIGEgc3Vycm9nYXRlIHBhaXJcbiAgICBpZiAobGFzdENoYXIgPj0gMHhkODAwICYmIGxhc3RDaGFyIDw9IDB4ZGJmZikge1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlLnNsaWNlKDAsIGxlbmd0aCArIDEpO1xuICAgIH1cbiAgICByZXR1cm4gY2FuZGlkYXRlLnNsaWNlKDAsIGxlbmd0aCk7XG59XG4vKipcbiAqIEFkZCBhbiBldmVudCBsaXN0ZW5lciB0byBhbiBldmVudCBlbWl0dGVyIG9iamVjdCAoV2luZG93LCBFbGVtZW50LCBtb2NrIG9iamVjdC4uLikuICBUaGlzIHByb3ZpZGVzXG4gKiBhIGZldyBjb252ZW5pZW5jZXMgY29tcGFyZWQgdG8gdXNpbmcgYGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcmAgZGlyZWN0bHk6XG4gKlxuICogKiBzdXBwb3J0cyBJRTExIGJ5OiB1c2luZyBhbiBvcHRpb24gb2JqZWN0IG9ubHkgaWYgbmVlZGVkIGFuZCBlbXVsYXRpbmcgdGhlIGBvbmNlYCBvcHRpb25cbiAqXG4gKiAqIHdyYXBzIHRoZSBsaXN0ZW5lciB3aXRoIGEgYG1vbml0b3JgIGZ1bmN0aW9uXG4gKlxuICogKiByZXR1cm5zIGEgYHN0b3BgIGZ1bmN0aW9uIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGFkZEV2ZW50TGlzdGVuZXJzKGVtaXR0ZXIsIFtldmVudF0sIGxpc3RlbmVyLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQWRkIGV2ZW50IGxpc3RlbmVycyB0byBhbiBldmVudCBlbWl0dGVyIG9iamVjdCAoV2luZG93LCBFbGVtZW50LCBtb2NrIG9iamVjdC4uLikuICBUaGlzIHByb3ZpZGVzXG4gKiBhIGZldyBjb252ZW5pZW5jZXMgY29tcGFyZWQgdG8gdXNpbmcgYGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcmAgZGlyZWN0bHk6XG4gKlxuICogKiBzdXBwb3J0cyBJRTExIGJ5OiB1c2luZyBhbiBvcHRpb24gb2JqZWN0IG9ubHkgaWYgbmVlZGVkIGFuZCBlbXVsYXRpbmcgdGhlIGBvbmNlYCBvcHRpb25cbiAqXG4gKiAqIHdyYXBzIHRoZSBsaXN0ZW5lciB3aXRoIGEgYG1vbml0b3JgIGZ1bmN0aW9uXG4gKlxuICogKiByZXR1cm5zIGEgYHN0b3BgIGZ1bmN0aW9uIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXJcbiAqXG4gKiAqIHdpdGggYG9uY2U6IHRydWVgLCB0aGUgbGlzdGVuZXIgd2lsbCBiZSBjYWxsZWQgYXQgbW9zdCBvbmNlLCBldmVuIGlmIGRpZmZlcmVudCBldmVudHMgYXJlIGxpc3RlbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVycyhlbWl0dGVyLCBldmVudHMsIGxpc3RlbmVyLCBfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmNlID0gX2Iub25jZSwgY2FwdHVyZSA9IF9iLmNhcHR1cmUsIHBhc3NpdmUgPSBfYi5wYXNzaXZlO1xuICAgIHZhciB3cmFwcGVkTGlzdGVuZXIgPSBtb25pdG9yKG9uY2VcbiAgICAgICAgPyBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgIGxpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICA6IGxpc3RlbmVyKTtcbiAgICB2YXIgb3B0aW9ucyA9IHBhc3NpdmUgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfSA6IGNhcHR1cmU7XG4gICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHdyYXBwZWRMaXN0ZW5lciwgb3B0aW9ucyk7IH0pO1xuICAgIHZhciBzdG9wID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIHdyYXBwZWRMaXN0ZW5lciwgb3B0aW9ucyk7IH0pOyB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0b3A6IHN0b3AsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBydW5PblJlYWR5U3RhdGUoZXhwZWN0ZWRSZWFkeVN0YXRlLCBjYWxsYmFjaykge1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBleHBlY3RlZFJlYWR5U3RhdGUgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGV4cGVjdGVkUmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJyA/IFwibG9hZFwiIC8qIExPQUQgKi8gOiBcIkRPTUNvbnRlbnRMb2FkZWRcIiAvKiBET01fQ09OVEVOVF9MT0FERUQgKi87XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIod2luZG93LCBldmVudE5hbWUsIGNhbGxiYWNrLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiaW1wb3J0IHsgX19zcHJlYWRBcnJheXMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGdldFRpbWVTdGFtcCwgcmVsYXRpdmVOb3cgfSBmcm9tICcuLi90b29scy90aW1lVXRpbHMnO1xuaW1wb3J0IHsgYWRkRXZlbnRMaXN0ZW5lciwganNvblN0cmluZ2lmeSwgbm9vcCwgb2JqZWN0VmFsdWVzIH0gZnJvbSAnLi4vdG9vbHMvdXRpbHMnO1xuaW1wb3J0IHsgbW9uaXRvciwgYWRkRXJyb3JUb01vbml0b3JpbmdCYXRjaCB9IGZyb20gJy4uL2RvbWFpbi9pbnRlcm5hbE1vbml0b3JpbmcnO1xuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLThcbnZhciBIQVNfTVVMVElfQllURVNfQ0hBUkFDVEVSUyA9IC9bXlxcdTAwMDAtXFx1MDA3Rl0vO1xuLyoqXG4gKiBVc2UgUE9TVCByZXF1ZXN0IHdpdGhvdXQgY29udGVudCB0eXBlIHRvOlxuICogLSBhdm9pZCBDT1JTIHByZWZsaWdodCByZXF1ZXN0c1xuICogLSBhbGxvdyB1c2FnZSBvZiBzZW5kQmVhY29uXG4gKlxuICogbXVsdGlwbGUgZWxlbWVudHMgYXJlIHNlbnQgc2VwYXJhdGVkIGJ5IFxcbiBpbiBvcmRlclxuICogdG8gYmUgcGFyc2VkIGNvcnJlY3RseSB3aXRob3V0IGNvbnRlbnQgdHlwZSBoZWFkZXJcbiAqL1xudmFyIEh0dHBSZXF1ZXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0dHBSZXF1ZXN0KGVuZHBvaW50VXJsLCBieXRlc0xpbWl0LCB3aXRoQmF0Y2hUaW1lKSB7XG4gICAgICAgIGlmICh3aXRoQmF0Y2hUaW1lID09PSB2b2lkIDApIHsgd2l0aEJhdGNoVGltZSA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMuZW5kcG9pbnRVcmwgPSBlbmRwb2ludFVybDtcbiAgICAgICAgdGhpcy5ieXRlc0xpbWl0ID0gYnl0ZXNMaW1pdDtcbiAgICAgICAgdGhpcy53aXRoQmF0Y2hUaW1lID0gd2l0aEJhdGNoVGltZTtcbiAgICB9XG4gICAgSHR0cFJlcXVlc3QucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoZGF0YSwgc2l6ZSkge1xuICAgICAgICB2YXIgdXJsID0gdGhpcy53aXRoQmF0Y2hUaW1lID8gYWRkQmF0Y2hUaW1lKHRoaXMuZW5kcG9pbnRVcmwpIDogdGhpcy5lbmRwb2ludFVybDtcbiAgICAgICAgaWYgKG5hdmlnYXRvci5zZW5kQmVhY29uICYmIHNpemUgPCB0aGlzLmJ5dGVzTGltaXQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzUXVldWVkID0gbmF2aWdhdG9yLnNlbmRCZWFjb24odXJsLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNRdWV1ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVwb3J0QmVhY29uRXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgcmVxdWVzdC5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgcmVxdWVzdC5zZW5kKGRhdGEpO1xuICAgIH07XG4gICAgcmV0dXJuIEh0dHBSZXF1ZXN0O1xufSgpKTtcbmV4cG9ydCB7IEh0dHBSZXF1ZXN0IH07XG5mdW5jdGlvbiBhZGRCYXRjaFRpbWUodXJsKSB7XG4gICAgcmV0dXJuIFwiXCIgKyB1cmwgKyAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgXCJiYXRjaF90aW1lPVwiICsgbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBcIiZtX3RpbWU9XCIgKyBnZXRUaW1lU3RhbXAocmVsYXRpdmVOb3coKSk7XG59XG52YXIgaGFzUmVwb3J0ZWRCZWFjb25FcnJvciA9IGZhbHNlO1xuZnVuY3Rpb24gcmVwb3J0QmVhY29uRXJyb3IoZSkge1xuICAgIGlmICghaGFzUmVwb3J0ZWRCZWFjb25FcnJvcikge1xuICAgICAgICBoYXNSZXBvcnRlZEJlYWNvbkVycm9yID0gdHJ1ZTtcbiAgICAgICAgYWRkRXJyb3JUb01vbml0b3JpbmdCYXRjaChlKTtcbiAgICB9XG59XG52YXIgQmF0Y2ggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmF0Y2gocmVxdWVzdCwgbWF4U2l6ZSwgYnl0ZXNMaW1pdCwgbWF4TWVzc2FnZVNpemUsIGZsdXNoVGltZW91dCwgYmVmb3JlVW5sb2FkQ2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGJlZm9yZVVubG9hZENhbGxiYWNrID09PSB2b2lkIDApIHsgYmVmb3JlVW5sb2FkQ2FsbGJhY2sgPSBub29wOyB9XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMubWF4U2l6ZSA9IG1heFNpemU7XG4gICAgICAgIHRoaXMuYnl0ZXNMaW1pdCA9IGJ5dGVzTGltaXQ7XG4gICAgICAgIHRoaXMubWF4TWVzc2FnZVNpemUgPSBtYXhNZXNzYWdlU2l6ZTtcbiAgICAgICAgdGhpcy5mbHVzaFRpbWVvdXQgPSBmbHVzaFRpbWVvdXQ7XG4gICAgICAgIHRoaXMuYmVmb3JlVW5sb2FkQ2FsbGJhY2sgPSBiZWZvcmVVbmxvYWRDYWxsYmFjaztcbiAgICAgICAgdGhpcy5wdXNoT25seUJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLnVwc2VydEJ1ZmZlciA9IHt9O1xuICAgICAgICB0aGlzLmJ1ZmZlckJ5dGVzU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuYnVmZmVyTWVzc2FnZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5mbHVzaE9uVmlzaWJpbGl0eUhpZGRlbigpO1xuICAgICAgICB0aGlzLmZsdXNoUGVyaW9kaWNhbGx5KCk7XG4gICAgfVxuICAgIEJhdGNoLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmFkZE9yVXBkYXRlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgQmF0Y2gucHJvdG90eXBlLnVwc2VydCA9IGZ1bmN0aW9uIChtZXNzYWdlLCBrZXkpIHtcbiAgICAgICAgdGhpcy5hZGRPclVwZGF0ZShtZXNzYWdlLCBrZXkpO1xuICAgIH07XG4gICAgQmF0Y2gucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5idWZmZXJNZXNzYWdlQ291bnQgIT09IDApIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlcyA9IF9fc3ByZWFkQXJyYXlzKHRoaXMucHVzaE9ubHlCdWZmZXIsIG9iamVjdFZhbHVlcyh0aGlzLnVwc2VydEJ1ZmZlcikpO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0LnNlbmQobWVzc2FnZXMuam9pbignXFxuJyksIHRoaXMuYnVmZmVyQnl0ZXNTaXplKTtcbiAgICAgICAgICAgIHRoaXMucHVzaE9ubHlCdWZmZXIgPSBbXTtcbiAgICAgICAgICAgIHRoaXMudXBzZXJ0QnVmZmVyID0ge307XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlckJ5dGVzU2l6ZSA9IDA7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlck1lc3NhZ2VDb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJhdGNoLnByb3RvdHlwZS5zaXplSW5CeXRlcyA9IGZ1bmN0aW9uIChjYW5kaWRhdGUpIHtcbiAgICAgICAgLy8gQWNjdXJhdGUgYnl0ZSBzaXplIGNvbXB1dGF0aW9ucyBjYW4gZGVncmFkZSBwZXJmb3JtYW5jZXMgd2hlbiB0aGVyZSBpcyBhIGxvdCBvZiBldmVudHMgdG8gcHJvY2Vzc1xuICAgICAgICBpZiAoIUhBU19NVUxUSV9CWVRFU19DSEFSQUNURVJTLnRlc3QoY2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpbmRvdy5UZXh0RW5jb2RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGNhbmRpZGF0ZSkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQmxvYihbY2FuZGlkYXRlXSkuc2l6ZTtcbiAgICB9O1xuICAgIEJhdGNoLnByb3RvdHlwZS5hZGRPclVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBrZXkpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9jZXNzKG1lc3NhZ2UpLCBwcm9jZXNzZWRNZXNzYWdlID0gX2EucHJvY2Vzc2VkTWVzc2FnZSwgbWVzc2FnZUJ5dGVzU2l6ZSA9IF9hLm1lc3NhZ2VCeXRlc1NpemU7XG4gICAgICAgIGlmIChtZXNzYWdlQnl0ZXNTaXplID49IHRoaXMubWF4TWVzc2FnZVNpemUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkRpc2NhcmRlZCBhIG1lc3NhZ2Ugd2hvc2Ugc2l6ZSB3YXMgYmlnZ2VyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCBzaXplIFwiICsgdGhpcy5tYXhNZXNzYWdlU2l6ZSArIFwiS0IuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc01lc3NhZ2VGb3Ioa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy53aWxsUmVhY2hlZEJ5dGVzTGltaXRXaXRoKG1lc3NhZ2VCeXRlc1NpemUpKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdXNoKHByb2Nlc3NlZE1lc3NhZ2UsIG1lc3NhZ2VCeXRlc1NpemUsIGtleSk7XG4gICAgICAgIGlmICh0aGlzLmlzRnVsbCgpKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJhdGNoLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIHByb2Nlc3NlZE1lc3NhZ2UgPSBqc29uU3RyaW5naWZ5KG1lc3NhZ2UpO1xuICAgICAgICB2YXIgbWVzc2FnZUJ5dGVzU2l6ZSA9IHRoaXMuc2l6ZUluQnl0ZXMocHJvY2Vzc2VkTWVzc2FnZSk7XG4gICAgICAgIHJldHVybiB7IHByb2Nlc3NlZE1lc3NhZ2U6IHByb2Nlc3NlZE1lc3NhZ2UsIG1lc3NhZ2VCeXRlc1NpemU6IG1lc3NhZ2VCeXRlc1NpemUgfTtcbiAgICB9O1xuICAgIEJhdGNoLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHByb2Nlc3NlZE1lc3NhZ2UsIG1lc3NhZ2VCeXRlc1NpemUsIGtleSkge1xuICAgICAgICBpZiAodGhpcy5idWZmZXJNZXNzYWdlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAvLyBcXG4gc2VwYXJhdG9yIGF0IHNlcmlhbGl6YXRpb25cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyQnl0ZXNTaXplICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnVwc2VydEJ1ZmZlcltrZXldID0gcHJvY2Vzc2VkTWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHVzaE9ubHlCdWZmZXIucHVzaChwcm9jZXNzZWRNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlckJ5dGVzU2l6ZSArPSBtZXNzYWdlQnl0ZXNTaXplO1xuICAgICAgICB0aGlzLmJ1ZmZlck1lc3NhZ2VDb3VudCArPSAxO1xuICAgIH07XG4gICAgQmF0Y2gucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHJlbW92ZWRNZXNzYWdlID0gdGhpcy51cHNlcnRCdWZmZXJba2V5XTtcbiAgICAgICAgZGVsZXRlIHRoaXMudXBzZXJ0QnVmZmVyW2tleV07XG4gICAgICAgIHZhciBtZXNzYWdlQnl0ZXNTaXplID0gdGhpcy5zaXplSW5CeXRlcyhyZW1vdmVkTWVzc2FnZSk7XG4gICAgICAgIHRoaXMuYnVmZmVyQnl0ZXNTaXplIC09IG1lc3NhZ2VCeXRlc1NpemU7XG4gICAgICAgIHRoaXMuYnVmZmVyTWVzc2FnZUNvdW50IC09IDE7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlck1lc3NhZ2VDb3VudCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyQnl0ZXNTaXplIC09IDE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJhdGNoLnByb3RvdHlwZS5oYXNNZXNzYWdlRm9yID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ICE9PSB1bmRlZmluZWQgJiYgdGhpcy51cHNlcnRCdWZmZXJba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgQmF0Y2gucHJvdG90eXBlLndpbGxSZWFjaGVkQnl0ZXNMaW1pdFdpdGggPSBmdW5jdGlvbiAobWVzc2FnZUJ5dGVzU2l6ZSkge1xuICAgICAgICAvLyBieXRlIG9mIHRoZSBzZXBhcmF0b3IgYXQgdGhlIGVuZCBvZiB0aGUgbWVzc2FnZVxuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJCeXRlc1NpemUgKyBtZXNzYWdlQnl0ZXNTaXplICsgMSA+PSB0aGlzLmJ5dGVzTGltaXQ7XG4gICAgfTtcbiAgICBCYXRjaC5wcm90b3R5cGUuaXNGdWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJNZXNzYWdlQ291bnQgPT09IHRoaXMubWF4U2l6ZSB8fCB0aGlzLmJ1ZmZlckJ5dGVzU2l6ZSA+PSB0aGlzLmJ5dGVzTGltaXQ7XG4gICAgfTtcbiAgICBCYXRjaC5wcm90b3R5cGUuZmx1c2hQZXJpb2RpY2FsbHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHNldFRpbWVvdXQobW9uaXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgX3RoaXMuZmx1c2hQZXJpb2RpY2FsbHkoKTtcbiAgICAgICAgfSksIHRoaXMuZmx1c2hUaW1lb3V0KTtcbiAgICB9O1xuICAgIEJhdGNoLnByb3RvdHlwZS5mbHVzaE9uVmlzaWJpbGl0eUhpZGRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdpdGggc2VuZEJlYWNvbiwgcmVxdWVzdHMgYXJlIGd1YXJhbnRlZWQgdG8gYmUgc3VjY2Vzc2Z1bGx5IHNlbnQgZHVyaW5nIGRvY3VtZW50IHVubG9hZFxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQHRzLWlnbm9yZSB0aGlzIGZ1bmN0aW9uIGlzIG5vdCBhbHdheXMgZGVmaW5lZFxuICAgICAgICBpZiAobmF2aWdhdG9yLnNlbmRCZWFjb24pIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogYmVmb3JldW5sb2FkIGlzIGNhbGxlZCBiZWZvcmUgdmlzaWJpbGl0eWNoYW5nZVxuICAgICAgICAgICAgICogcmVnaXN0ZXIgZmlyc3QgdG8gYmUgc3VyZSB0byBiZSBjYWxsZWQgYmVmb3JlIGZsdXNoIG9uIGJlZm9yZXVubG9hZFxuICAgICAgICAgICAgICogY2F2ZWF0OiB1bmxvYWQgY2FuIHN0aWxsIGJlIGNhbmNlbGVkIGJ5IGFub3RoZXIgbGlzdGVuZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwiYmVmb3JldW5sb2FkXCIgLyogQkVGT1JFX1VOTE9BRCAqLywgdGhpcy5iZWZvcmVVbmxvYWRDYWxsYmFjayk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE9ubHkgZXZlbnQgdGhhdCBndWFyYW50ZWUgdG8gZmlyZSBvbiBtb2JpbGUgZGV2aWNlcyB3aGVuIHRoZSBwYWdlIHRyYW5zaXRpb25zIHRvIGJhY2tncm91bmQgc3RhdGVcbiAgICAgICAgICAgICAqIChlLmcuIHdoZW4gdXNlciBzd2l0Y2hlcyB0byBhIGRpZmZlcmVudCBhcHBsaWNhdGlvbiwgZ29lcyB0byBob21lc2NyZWVuLCBldGMpLCBvciBpcyBiZWluZyB1bmxvYWRlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgXCJ2aXNpYmlsaXR5Y2hhbmdlXCIgLyogVklTSUJJTElUWV9DSEFOR0UgKi8sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnaGlkZGVuJykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTYWZhcmkgZG9lcyBub3Qgc3VwcG9ydCB5ZXQgdG8gc2VuZCBhIHJlcXVlc3QgZHVyaW5nOlxuICAgICAgICAgICAgICogLSBhIHZpc2liaWxpdHkgY2hhbmdlIGR1cmluZyBkb2MgdW5sb2FkIChjZjogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE5NDg5NylcbiAgICAgICAgICAgICAqIC0gYSBwYWdlIGhpZGUgdHJhbnNpdGlvbiAoY2Y6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xODgzMjkpXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIod2luZG93LCBcImJlZm9yZXVubG9hZFwiIC8qIEJFRk9SRV9VTkxPQUQgKi8sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmZsdXNoKCk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQmF0Y2g7XG59KCkpO1xuZXhwb3J0IHsgQmF0Y2ggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zcG9ydC5qcy5tYXAiLCJleHBvcnQgdmFyIGJ1aWxkRW52ID0ge1xuICAgIGJ1aWxkTW9kZTogJ3JlbGVhc2UnLFxuICAgIGRhdGFjZW50ZXI6ICd1cycsXG4gICAgc2RrVmVyc2lvbjogJzIuNy40Jyxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZEVudi5qcy5tYXAiLCJpbXBvcnQgeyBjb21iaW5lLCBjb21tb25Jbml0IH0gZnJvbSAnQGRhdGFkb2cvYnJvd3Nlci1jb3JlJztcbmltcG9ydCB7IHN0YXJ0RE9NTXV0YXRpb25Db2xsZWN0aW9uIH0gZnJvbSAnLi4vYnJvd3Nlci9kb21NdXRhdGlvbkNvbGxlY3Rpb24nO1xuaW1wb3J0IHsgc3RhcnRQZXJmb3JtYW5jZUNvbGxlY3Rpb24gfSBmcm9tICcuLi9icm93c2VyL3BlcmZvcm1hbmNlQ29sbGVjdGlvbic7XG5pbXBvcnQgeyBzdGFydFJ1bUFzc2VtYmx5IH0gZnJvbSAnLi4vZG9tYWluL2Fzc2VtYmx5JztcbmltcG9ydCB7IHN0YXJ0SW50ZXJuYWxDb250ZXh0IH0gZnJvbSAnLi4vZG9tYWluL2ludGVybmFsQ29udGV4dCc7XG5pbXBvcnQgeyBMaWZlQ3ljbGUgfSBmcm9tICcuLi9kb21haW4vbGlmZUN5Y2xlJztcbmltcG9ydCB7IHN0YXJ0UGFyZW50Q29udGV4dHMgfSBmcm9tICcuLi9kb21haW4vcGFyZW50Q29udGV4dHMnO1xuaW1wb3J0IHsgc3RhcnRSZXF1ZXN0Q29sbGVjdGlvbiB9IGZyb20gJy4uL2RvbWFpbi9yZXF1ZXN0Q29sbGVjdGlvbic7XG5pbXBvcnQgeyBzdGFydEFjdGlvbkNvbGxlY3Rpb24gfSBmcm9tICcuLi9kb21haW4vcnVtRXZlbnRzQ29sbGVjdGlvbi9hY3Rpb24vYWN0aW9uQ29sbGVjdGlvbic7XG5pbXBvcnQgeyBzdGFydEVycm9yQ29sbGVjdGlvbiB9IGZyb20gJy4uL2RvbWFpbi9ydW1FdmVudHNDb2xsZWN0aW9uL2Vycm9yL2Vycm9yQ29sbGVjdGlvbic7XG5pbXBvcnQgeyBzdGFydExvbmdUYXNrQ29sbGVjdGlvbiB9IGZyb20gJy4uL2RvbWFpbi9ydW1FdmVudHNDb2xsZWN0aW9uL2xvbmdUYXNrL2xvbmdUYXNrQ29sbGVjdGlvbic7XG5pbXBvcnQgeyBzdGFydFJlc291cmNlQ29sbGVjdGlvbiB9IGZyb20gJy4uL2RvbWFpbi9ydW1FdmVudHNDb2xsZWN0aW9uL3Jlc291cmNlL3Jlc291cmNlQ29sbGVjdGlvbic7XG5pbXBvcnQgeyBzdGFydFZpZXdDb2xsZWN0aW9uIH0gZnJvbSAnLi4vZG9tYWluL3J1bUV2ZW50c0NvbGxlY3Rpb24vdmlldy92aWV3Q29sbGVjdGlvbic7XG5pbXBvcnQgeyBzdGFydFJ1bVNlc3Npb24gfSBmcm9tICcuLi9kb21haW4vcnVtU2Vzc2lvbic7XG5pbXBvcnQgeyBzdGFydFJ1bUJhdGNoIH0gZnJvbSAnLi4vdHJhbnNwb3J0L2JhdGNoJztcbmltcG9ydCB7IGJ1aWxkRW52IH0gZnJvbSAnLi9idWlsZEVudic7XG5leHBvcnQgZnVuY3Rpb24gc3RhcnRSdW0odXNlckNvbmZpZ3VyYXRpb24sIGdldENvbW1vbkNvbnRleHQpIHtcbiAgICB2YXIgbGlmZUN5Y2xlID0gbmV3IExpZmVDeWNsZSgpO1xuICAgIHZhciBfYSA9IGNvbW1vbkluaXQodXNlckNvbmZpZ3VyYXRpb24sIGJ1aWxkRW52KSwgY29uZmlndXJhdGlvbiA9IF9hLmNvbmZpZ3VyYXRpb24sIGludGVybmFsTW9uaXRvcmluZyA9IF9hLmludGVybmFsTW9uaXRvcmluZztcbiAgICB2YXIgc2Vzc2lvbiA9IHN0YXJ0UnVtU2Vzc2lvbihjb25maWd1cmF0aW9uLCBsaWZlQ3ljbGUpO1xuICAgIGludGVybmFsTW9uaXRvcmluZy5zZXRFeHRlcm5hbENvbnRleHRQcm92aWRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lKHtcbiAgICAgICAgICAgIGFwcGxpY2F0aW9uX2lkOiB1c2VyQ29uZmlndXJhdGlvbi5hcHBsaWNhdGlvbklkLFxuICAgICAgICB9LCBwYXJlbnRDb250ZXh0cy5maW5kVmlldygpLCBnZXRDb21tb25Db250ZXh0KCkuY29udGV4dCk7XG4gICAgfSk7XG4gICAgdmFyIF9iID0gc3RhcnRSdW1FdmVudENvbGxlY3Rpb24odXNlckNvbmZpZ3VyYXRpb24uYXBwbGljYXRpb25JZCwgbG9jYXRpb24sIGxpZmVDeWNsZSwgY29uZmlndXJhdGlvbiwgc2Vzc2lvbiwgZ2V0Q29tbW9uQ29udGV4dCksIHBhcmVudENvbnRleHRzID0gX2IucGFyZW50Q29udGV4dHMsIGFkZEVycm9yID0gX2IuYWRkRXJyb3IsIGFkZEFjdGlvbiA9IF9iLmFkZEFjdGlvbiwgYWRkVGltaW5nID0gX2IuYWRkVGltaW5nO1xuICAgIHN0YXJ0UmVxdWVzdENvbGxlY3Rpb24obGlmZUN5Y2xlLCBjb25maWd1cmF0aW9uKTtcbiAgICBzdGFydFBlcmZvcm1hbmNlQ29sbGVjdGlvbihsaWZlQ3ljbGUsIGNvbmZpZ3VyYXRpb24pO1xuICAgIHN0YXJ0RE9NTXV0YXRpb25Db2xsZWN0aW9uKGxpZmVDeWNsZSk7XG4gICAgdmFyIGludGVybmFsQ29udGV4dCA9IHN0YXJ0SW50ZXJuYWxDb250ZXh0KHVzZXJDb25maWd1cmF0aW9uLmFwcGxpY2F0aW9uSWQsIHNlc3Npb24sIHBhcmVudENvbnRleHRzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRBY3Rpb246IGFkZEFjdGlvbixcbiAgICAgICAgYWRkRXJyb3I6IGFkZEVycm9yLFxuICAgICAgICBhZGRUaW1pbmc6IGFkZFRpbWluZyxcbiAgICAgICAgY29uZmlndXJhdGlvbjogY29uZmlndXJhdGlvbixcbiAgICAgICAgbGlmZUN5Y2xlOiBsaWZlQ3ljbGUsXG4gICAgICAgIHBhcmVudENvbnRleHRzOiBwYXJlbnRDb250ZXh0cyxcbiAgICAgICAgc2Vzc2lvbjogc2Vzc2lvbixcbiAgICAgICAgZ2V0SW50ZXJuYWxDb250ZXh0OiBpbnRlcm5hbENvbnRleHQuZ2V0LFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gc3RhcnRSdW1FdmVudENvbGxlY3Rpb24oYXBwbGljYXRpb25JZCwgbG9jYXRpb24sIGxpZmVDeWNsZSwgY29uZmlndXJhdGlvbiwgc2Vzc2lvbiwgZ2V0Q29tbW9uQ29udGV4dCkge1xuICAgIHZhciBwYXJlbnRDb250ZXh0cyA9IHN0YXJ0UGFyZW50Q29udGV4dHMobGlmZUN5Y2xlLCBzZXNzaW9uKTtcbiAgICB2YXIgYmF0Y2ggPSBzdGFydFJ1bUJhdGNoKGNvbmZpZ3VyYXRpb24sIGxpZmVDeWNsZSk7XG4gICAgc3RhcnRSdW1Bc3NlbWJseShhcHBsaWNhdGlvbklkLCBjb25maWd1cmF0aW9uLCBsaWZlQ3ljbGUsIHNlc3Npb24sIHBhcmVudENvbnRleHRzLCBnZXRDb21tb25Db250ZXh0KTtcbiAgICBzdGFydExvbmdUYXNrQ29sbGVjdGlvbihsaWZlQ3ljbGUpO1xuICAgIHN0YXJ0UmVzb3VyY2VDb2xsZWN0aW9uKGxpZmVDeWNsZSwgc2Vzc2lvbik7XG4gICAgdmFyIF9hID0gc3RhcnRWaWV3Q29sbGVjdGlvbihsaWZlQ3ljbGUsIGxvY2F0aW9uKSwgYWRkVGltaW5nID0gX2EuYWRkVGltaW5nLCBzdG9wVmlld0NvbGxlY3Rpb24gPSBfYS5zdG9wO1xuICAgIHZhciBhZGRFcnJvciA9IHN0YXJ0RXJyb3JDb2xsZWN0aW9uKGxpZmVDeWNsZSwgY29uZmlndXJhdGlvbikuYWRkRXJyb3I7XG4gICAgdmFyIGFkZEFjdGlvbiA9IHN0YXJ0QWN0aW9uQ29sbGVjdGlvbihsaWZlQ3ljbGUsIGNvbmZpZ3VyYXRpb24pLmFkZEFjdGlvbjtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRBY3Rpb246IGFkZEFjdGlvbixcbiAgICAgICAgYWRkRXJyb3I6IGFkZEVycm9yLFxuICAgICAgICBwYXJlbnRDb250ZXh0czogcGFyZW50Q29udGV4dHMsXG4gICAgICAgIGFkZFRpbWluZzogYWRkVGltaW5nLFxuICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdG9wVmlld0NvbGxlY3Rpb24oKTtcbiAgICAgICAgICAgIC8vIHByZXZlbnQgYmF0Y2ggZnJvbSBwcmV2aW91cyB0ZXN0cyB0byBrZWVwIHJ1bm5pbmcgYW5kIHNlbmQgdW53YW50ZWQgcmVxdWVzdHNcbiAgICAgICAgICAgIC8vIGNvdWxkIGJlIHJlcGxhY2VkIGJ5IHN0b3BwaW5nIGFsbCB0aGUgY29tcG9uZW50IHdoZW4gdGhleSB3aWxsIGFsbCBoYXZlIGEgc3RvcCBtZXRob2RcbiAgICAgICAgICAgIGJhdGNoLnN0b3AoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnVtLmpzLm1hcCIsImltcG9ydCB7IEJvdW5kZWRCdWZmZXIsIGJ1aWxkQ29va2llT3B0aW9ucywgY2hlY2tDb29raWVzQXV0aG9yaXplZCwgY2hlY2tJc05vdExvY2FsRmlsZSwgY3JlYXRlQ29udGV4dE1hbmFnZXIsIGRlZXBDbG9uZSwgRXJyb3JTb3VyY2UsIGlzUGVyY2VudGFnZSwgbWFrZVB1YmxpY0FwaSwgbW9uaXRvciwgcmVsYXRpdmVOb3csIH0gZnJvbSAnQGRhdGFkb2cvYnJvd3Nlci1jb3JlJztcbmltcG9ydCB7IEFjdGlvblR5cGUgfSBmcm9tICcuLi9yYXdSdW1FdmVudC50eXBlcyc7XG5leHBvcnQgZnVuY3Rpb24gbWFrZVJ1bVB1YmxpY0FwaShzdGFydFJ1bUltcGwpIHtcbiAgICB2YXIgaXNBbHJlYWR5SW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB2YXIgZ2xvYmFsQ29udGV4dE1hbmFnZXIgPSBjcmVhdGVDb250ZXh0TWFuYWdlcigpO1xuICAgIHZhciB1c2VyID0ge307XG4gICAgdmFyIGdldEludGVybmFsQ29udGV4dFN0cmF0ZWd5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9O1xuICAgIHZhciBiZWZvcmVJbml0QWRkVGltaW5nID0gbmV3IEJvdW5kZWRCdWZmZXIoKTtcbiAgICB2YXIgYWRkVGltaW5nU3RyYXRlZ3kgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBiZWZvcmVJbml0QWRkVGltaW5nLmFkZChbbmFtZSwgcmVsYXRpdmVOb3coKV0pO1xuICAgIH07XG4gICAgdmFyIGJlZm9yZUluaXRBZGRBY3Rpb24gPSBuZXcgQm91bmRlZEJ1ZmZlcigpO1xuICAgIHZhciBhZGRBY3Rpb25TdHJhdGVneSA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgYmVmb3JlSW5pdEFkZEFjdGlvbi5hZGQoW2FjdGlvbiwgY2xvbmVkQ29tbW9uQ29udGV4dCgpXSk7XG4gICAgfTtcbiAgICB2YXIgYmVmb3JlSW5pdEFkZEVycm9yID0gbmV3IEJvdW5kZWRCdWZmZXIoKTtcbiAgICB2YXIgYWRkRXJyb3JTdHJhdGVneSA9IGZ1bmN0aW9uIChwcm92aWRlZEVycm9yKSB7XG4gICAgICAgIGJlZm9yZUluaXRBZGRFcnJvci5hZGQoW3Byb3ZpZGVkRXJyb3IsIGNsb25lZENvbW1vbkNvbnRleHQoKV0pO1xuICAgIH07XG4gICAgZnVuY3Rpb24gY2xvbmVkQ29tbW9uQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIGRlZXBDbG9uZSh7XG4gICAgICAgICAgICBjb250ZXh0OiBnbG9iYWxDb250ZXh0TWFuYWdlci5nZXQoKSxcbiAgICAgICAgICAgIHVzZXI6IHVzZXIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgcnVtUHVibGljQXBpID0gbWFrZVB1YmxpY0FwaSh7XG4gICAgICAgIGluaXQ6IG1vbml0b3IoZnVuY3Rpb24gKHVzZXJDb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoIWNoZWNrQ29va2llc0F1dGhvcml6ZWQoYnVpbGRDb29raWVPcHRpb25zKHVzZXJDb25maWd1cmF0aW9uKSkgfHxcbiAgICAgICAgICAgICAgICAhY2hlY2tJc05vdExvY2FsRmlsZSgpIHx8XG4gICAgICAgICAgICAgICAgIWNhbkluaXRSdW0odXNlckNvbmZpZ3VyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVzZXJDb25maWd1cmF0aW9uLnB1YmxpY0FwaUtleSkge1xuICAgICAgICAgICAgICAgIHVzZXJDb25maWd1cmF0aW9uLmNsaWVudFRva2VuID0gdXNlckNvbmZpZ3VyYXRpb24ucHVibGljQXBpS2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgKF9hID0gc3RhcnRSdW1JbXBsKHVzZXJDb25maWd1cmF0aW9uLCBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgICAgIHVzZXI6IHVzZXIsXG4gICAgICAgICAgICAgICAgY29udGV4dDogZ2xvYmFsQ29udGV4dE1hbmFnZXIuZ2V0KCksXG4gICAgICAgICAgICB9KTsgfSksIGFkZEFjdGlvblN0cmF0ZWd5ID0gX2EuYWRkQWN0aW9uLCBhZGRFcnJvclN0cmF0ZWd5ID0gX2EuYWRkRXJyb3IsIGFkZFRpbWluZ1N0cmF0ZWd5ID0gX2EuYWRkVGltaW5nLCBnZXRJbnRlcm5hbENvbnRleHRTdHJhdGVneSA9IF9hLmdldEludGVybmFsQ29udGV4dCk7XG4gICAgICAgICAgICBiZWZvcmVJbml0QWRkQWN0aW9uLmRyYWluKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBhY3Rpb24gPSBfYVswXSwgY29tbW9uQ29udGV4dCA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIHJldHVybiBhZGRBY3Rpb25TdHJhdGVneShhY3Rpb24sIGNvbW1vbkNvbnRleHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBiZWZvcmVJbml0QWRkRXJyb3IuZHJhaW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gX2FbMF0sIGNvbW1vbkNvbnRleHQgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkRXJyb3JTdHJhdGVneShlcnJvciwgY29tbW9uQ29udGV4dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJlZm9yZUluaXRBZGRUaW1pbmcuZHJhaW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfYVswXSwgdGltZSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIHJldHVybiBhZGRUaW1pbmdTdHJhdGVneShuYW1lLCB0aW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaXNBbHJlYWR5SW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9KSxcbiAgICAgICAgYWRkUnVtR2xvYmFsQ29udGV4dDogbW9uaXRvcihnbG9iYWxDb250ZXh0TWFuYWdlci5hZGQpLFxuICAgICAgICByZW1vdmVSdW1HbG9iYWxDb250ZXh0OiBtb25pdG9yKGdsb2JhbENvbnRleHRNYW5hZ2VyLnJlbW92ZSksXG4gICAgICAgIGdldFJ1bUdsb2JhbENvbnRleHQ6IG1vbml0b3IoZ2xvYmFsQ29udGV4dE1hbmFnZXIuZ2V0KSxcbiAgICAgICAgc2V0UnVtR2xvYmFsQ29udGV4dDogbW9uaXRvcihnbG9iYWxDb250ZXh0TWFuYWdlci5zZXQpLFxuICAgICAgICBnZXRJbnRlcm5hbENvbnRleHQ6IG1vbml0b3IoZnVuY3Rpb24gKHN0YXJ0VGltZSkgeyByZXR1cm4gZ2V0SW50ZXJuYWxDb250ZXh0U3RyYXRlZ3koc3RhcnRUaW1lKTsgfSksXG4gICAgICAgIGFkZEFjdGlvbjogbW9uaXRvcihmdW5jdGlvbiAobmFtZSwgY29udGV4dCkge1xuICAgICAgICAgICAgYWRkQWN0aW9uU3RyYXRlZ3koe1xuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgY29udGV4dDogZGVlcENsb25lKGNvbnRleHQpLFxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogcmVsYXRpdmVOb3coKSxcbiAgICAgICAgICAgICAgICB0eXBlOiBBY3Rpb25UeXBlLkNVU1RPTSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIHVzZSBhZGRBY3Rpb24gaW5zdGVhZFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkVXNlckFjdGlvbjogZnVuY3Rpb24gKG5hbWUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJ1bVB1YmxpY0FwaS5hZGRBY3Rpb24obmFtZSwgY29udGV4dCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZEVycm9yOiBtb25pdG9yKGZ1bmN0aW9uIChlcnJvciwgY29udGV4dCwgc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlID09PSB2b2lkIDApIHsgc291cmNlID0gRXJyb3JTb3VyY2UuQ1VTVE9NOyB9XG4gICAgICAgICAgICB2YXIgY2hlY2tlZFNvdXJjZTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UgPT09IEVycm9yU291cmNlLkNVU1RPTSB8fCBzb3VyY2UgPT09IEVycm9yU291cmNlLk5FVFdPUksgfHwgc291cmNlID09PSBFcnJvclNvdXJjZS5TT1VSQ0UpIHtcbiAgICAgICAgICAgICAgICBjaGVja2VkU291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkREX1JVTS5hZGRFcnJvcjogSW52YWxpZCBzb3VyY2UgJ1wiICsgc291cmNlICsgXCInXCIpO1xuICAgICAgICAgICAgICAgIGNoZWNrZWRTb3VyY2UgPSBFcnJvclNvdXJjZS5DVVNUT007XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRFcnJvclN0cmF0ZWd5KHtcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgY29udGV4dDogZGVlcENsb25lKGNvbnRleHQpLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogY2hlY2tlZFNvdXJjZSxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWU6IHJlbGF0aXZlTm93KCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSksXG4gICAgICAgIGFkZFRpbWluZzogbW9uaXRvcihmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgYWRkVGltaW5nU3RyYXRlZ3kobmFtZSk7XG4gICAgICAgIH0pLFxuICAgICAgICBzZXRVc2VyOiBtb25pdG9yKGZ1bmN0aW9uIChuZXdVc2VyKSB7XG4gICAgICAgICAgICB2YXIgc2FuaXRpemVkVXNlciA9IHNhbml0aXplVXNlcihuZXdVc2VyKTtcbiAgICAgICAgICAgIGlmIChzYW5pdGl6ZWRVc2VyKSB7XG4gICAgICAgICAgICAgICAgdXNlciA9IHNhbml0aXplZFVzZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbnN1cHBvcnRlZCB1c2VyOicsIG5ld1VzZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICB9KTtcbiAgICByZXR1cm4gcnVtUHVibGljQXBpO1xuICAgIGZ1bmN0aW9uIHNhbml0aXplVXNlcihuZXdVc2VyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3VXNlciAhPT0gJ29iamVjdCcgfHwgIW5ld1VzZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gZGVlcENsb25lKG5ld1VzZXIpO1xuICAgICAgICBpZiAoJ2lkJyBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5pZCA9IFN0cmluZyhyZXN1bHQuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnbmFtZScgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQubmFtZSA9IFN0cmluZyhyZXN1bHQubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdlbWFpbCcgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQuZW1haWwgPSBTdHJpbmcocmVzdWx0LmVtYWlsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5Jbml0UnVtKHVzZXJDb25maWd1cmF0aW9uKSB7XG4gICAgICAgIGlmIChpc0FscmVhZHlJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgaWYgKCF1c2VyQ29uZmlndXJhdGlvbi5zaWxlbnRNdWx0aXBsZUluaXQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdERF9SVU0gaXMgYWxyZWFkeSBpbml0aWFsaXplZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXVzZXJDb25maWd1cmF0aW9uIHx8ICghdXNlckNvbmZpZ3VyYXRpb24uY2xpZW50VG9rZW4gJiYgIXVzZXJDb25maWd1cmF0aW9uLnB1YmxpY0FwaUtleSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NsaWVudCBUb2tlbiBpcyBub3QgY29uZmlndXJlZCwgd2Ugd2lsbCBub3Qgc2VuZCBhbnkgZGF0YS4nKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXVzZXJDb25maWd1cmF0aW9uLmFwcGxpY2F0aW9uSWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FwcGxpY2F0aW9uIElEIGlzIG5vdCBjb25maWd1cmVkLCBubyBSVU0gZGF0YSB3aWxsIGJlIGNvbGxlY3RlZC4nKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlckNvbmZpZ3VyYXRpb24uc2FtcGxlUmF0ZSAhPT0gdW5kZWZpbmVkICYmICFpc1BlcmNlbnRhZ2UodXNlckNvbmZpZ3VyYXRpb24uc2FtcGxlUmF0ZSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NhbXBsZSBSYXRlIHNob3VsZCBiZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEwMCcpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VyQ29uZmlndXJhdGlvbi5yZXNvdXJjZVNhbXBsZVJhdGUgIT09IHVuZGVmaW5lZCAmJiAhaXNQZXJjZW50YWdlKHVzZXJDb25maWd1cmF0aW9uLnJlc291cmNlU2FtcGxlUmF0ZSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Jlc291cmNlIFNhbXBsZSBSYXRlIHNob3VsZCBiZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEwMCcpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHVzZXJDb25maWd1cmF0aW9uLmFsbG93ZWRUcmFjaW5nT3JpZ2lucykgJiZcbiAgICAgICAgICAgIHVzZXJDb25maWd1cmF0aW9uLmFsbG93ZWRUcmFjaW5nT3JpZ2lucy5sZW5ndGggIT09IDAgJiZcbiAgICAgICAgICAgIHVzZXJDb25maWd1cmF0aW9uLnNlcnZpY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignU2VydmljZSBuZWVkIHRvIGJlIGNvbmZpZ3VyZWQgd2hlbiB0cmFjaW5nIGlzIGVuYWJsZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ydW1QdWJsaWNBcGkuanMubWFwIiwiaW1wb3J0IHsgbW9uaXRvciB9IGZyb20gJ0BkYXRhZG9nL2Jyb3dzZXItY29yZSc7XG5pbXBvcnQgeyBMaWZlQ3ljbGVFdmVudFR5cGUgfSBmcm9tICcuLi9kb21haW4vbGlmZUN5Y2xlJztcbmZ1bmN0aW9uIGdldE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3RvcigpIHtcbiAgICB2YXIgY29uc3RydWN0b3I7XG4gICAgdmFyIGJyb3dzZXJXaW5kb3cgPSB3aW5kb3c7XG4gICAgLy8gQW5ndWxhciB1c2VzIFpvbmUuanMgdG8gcHJvdmlkZSBhIGNvbnRleHQgcGVyc2lzdGluZyBhY2Nyb3NzIGFzeW5jIHRhc2tzLiAgWm9uZS5qcyByZXBsYWNlcyB0aGVcbiAgICAvLyBnbG9iYWwgTXV0YXRpb25PYnNlcnZlciBjb25zdHJ1Y3RvciB3aXRoIGEgcGF0Y2hlZCB2ZXJzaW9uIHRvIHN1cHBvcnQgdGhlIGNvbnRleHQgcHJvcGFnYXRpb24uXG4gICAgLy8gVGhlcmUgaXMgYW4gb25nb2luZyBpc3N1ZVsxXVsyXSB3aXRoIHRoaXMgc2V0dXAgd2hlbiB1c2luZyBhIE11dGF0aW9uT2JzZXJ2ZXIgd2l0aGluIGEgQW5ndWxhclxuICAgIC8vIGNvbXBvbmVudDogb24gc29tZSBvY2Nhc2lvbnMsIHRoZSBjYWxsYmFjayBpcyBiZWluZyBjYWxsZWQgaW4gYW4gaW5maW5pdGUgbG9vcCwgY2F1c2luZyB0aGVcbiAgICAvLyBwYWdlIHRvIGZyZWV6ZSAoZXZlbiBpZiB0aGUgY2FsbGJhY2sgaXMgY29tcGxldGVseSBlbXB0eSkuXG4gICAgLy9cbiAgICAvLyBUbyB3b3JrIGFyb3VuZCB0aGlzIGlzc3VlLCB3ZSBhcmUgdXNpbmcgdGhlIFpvbmUgX19zeW1ib2xfXyBBUEkgdG8gZ2V0IHRoZSBvcmlnaW5hbCwgdW5wYXRjaGVkXG4gICAgLy8gTXV0YXRpb25PYnNlcnZlciBjb25zdHJ1Y3Rvci5cbiAgICAvL1xuICAgIC8vIFsxXSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8yNjk0OFxuICAgIC8vIFsyXSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8zMTcxMlxuICAgIGlmIChicm93c2VyV2luZG93LlpvbmUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlXG4gICAgICAgIHZhciBzeW1ib2wgPSBicm93c2VyV2luZG93LlpvbmUuX19zeW1ib2xfXygnTXV0YXRpb25PYnNlcnZlcicpO1xuICAgICAgICBjb25zdHJ1Y3RvciA9IGJyb3dzZXJXaW5kb3dbc3ltYm9sXTtcbiAgICB9XG4gICAgaWYgKCFjb25zdHJ1Y3Rvcikge1xuICAgICAgICBjb25zdHJ1Y3RvciA9IGJyb3dzZXJXaW5kb3cuTXV0YXRpb25PYnNlcnZlcjtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0RE9NTXV0YXRpb25Db2xsZWN0aW9uKGxpZmVDeWNsZSkge1xuICAgIHZhciBvYnNlcnZlcjtcbiAgICB2YXIgTXV0YXRpb25PYnNlcnZlciA9IGdldE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3RvcigpO1xuICAgIGlmIChNdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAgIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobW9uaXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsaWZlQ3ljbGUubm90aWZ5KExpZmVDeWNsZUV2ZW50VHlwZS5ET01fTVVUQVRFRCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG9tTXV0YXRpb25Db2xsZWN0aW9uLmpzLm1hcCIsImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBhZGRFdmVudExpc3RlbmVycywgZ2V0UmVsYXRpdmVUaW1lLCBpc051bWJlciwgbW9uaXRvciwgcmVsYXRpdmVOb3csIHJ1bk9uUmVhZHlTdGF0ZSwgfSBmcm9tICdAZGF0YWRvZy9icm93c2VyLWNvcmUnO1xuaW1wb3J0IHsgTGlmZUN5Y2xlRXZlbnRUeXBlIH0gZnJvbSAnLi4vZG9tYWluL2xpZmVDeWNsZSc7XG5pbXBvcnQgeyBGQUtFX0lOSVRJQUxfRE9DVU1FTlQsIGlzQWxsb3dlZFJlcXVlc3RVcmwgfSBmcm9tICcuLi9kb21haW4vcnVtRXZlbnRzQ29sbGVjdGlvbi9yZXNvdXJjZS9yZXNvdXJjZVV0aWxzJztcbmltcG9ydCB7IGdldERvY3VtZW50VHJhY2VJZCB9IGZyb20gJy4uL2RvbWFpbi90cmFjaW5nL2dldERvY3VtZW50VHJhY2VJZCc7XG5mdW5jdGlvbiBzdXBwb3J0UGVyZm9ybWFuY2VPYmplY3QoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5wZXJmb3JtYW5jZSAhPT0gdW5kZWZpbmVkICYmICdnZXRFbnRyaWVzJyBpbiBwZXJmb3JtYW5jZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdXBwb3J0UGVyZm9ybWFuY2VUaW1pbmdFdmVudChlbnRyeVR5cGUpIHtcbiAgICByZXR1cm4gKHdpbmRvdy5QZXJmb3JtYW5jZU9ic2VydmVyICYmXG4gICAgICAgIFBlcmZvcm1hbmNlT2JzZXJ2ZXIuc3VwcG9ydGVkRW50cnlUeXBlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIFBlcmZvcm1hbmNlT2JzZXJ2ZXIuc3VwcG9ydGVkRW50cnlUeXBlcy5pbmNsdWRlcyhlbnRyeVR5cGUpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdGFydFBlcmZvcm1hbmNlQ29sbGVjdGlvbihsaWZlQ3ljbGUsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXRyaWV2ZUluaXRpYWxEb2N1bWVudFJlc291cmNlVGltaW5nKGZ1bmN0aW9uICh0aW1pbmcpIHtcbiAgICAgICAgaGFuZGxlUnVtUGVyZm9ybWFuY2VFbnRyeShsaWZlQ3ljbGUsIGNvbmZpZ3VyYXRpb24sIHRpbWluZyk7XG4gICAgfSk7XG4gICAgaWYgKHN1cHBvcnRQZXJmb3JtYW5jZU9iamVjdCgpKSB7XG4gICAgICAgIGhhbmRsZVBlcmZvcm1hbmNlRW50cmllcyhsaWZlQ3ljbGUsIGNvbmZpZ3VyYXRpb24sIHBlcmZvcm1hbmNlLmdldEVudHJpZXMoKSk7XG4gICAgfVxuICAgIGlmICh3aW5kb3cuUGVyZm9ybWFuY2VPYnNlcnZlcikge1xuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgUGVyZm9ybWFuY2VPYnNlcnZlcihtb25pdG9yKGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlUGVyZm9ybWFuY2VFbnRyaWVzKGxpZmVDeWNsZSwgY29uZmlndXJhdGlvbiwgZW50cmllcy5nZXRFbnRyaWVzKCkpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBlbnRyeVR5cGVzID0gW1xuICAgICAgICAgICAgJ3Jlc291cmNlJyxcbiAgICAgICAgICAgICduYXZpZ2F0aW9uJyxcbiAgICAgICAgICAgICdsb25ndGFzaycsXG4gICAgICAgICAgICAncGFpbnQnLFxuICAgICAgICAgICAgJ2xhcmdlc3QtY29udGVudGZ1bC1wYWludCcsXG4gICAgICAgICAgICAnZmlyc3QtaW5wdXQnLFxuICAgICAgICAgICAgJ2xheW91dC1zaGlmdCcsXG4gICAgICAgIF07XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoeyBlbnRyeVR5cGVzOiBlbnRyeVR5cGVzIH0pO1xuICAgICAgICBpZiAoc3VwcG9ydFBlcmZvcm1hbmNlT2JqZWN0KCkgJiYgJ2FkZEV2ZW50TGlzdGVuZXInIGluIHBlcmZvcm1hbmNlKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTU5Mzc3XG4gICAgICAgICAgICBwZXJmb3JtYW5jZS5hZGRFdmVudExpc3RlbmVyKCdyZXNvdXJjZXRpbWluZ2J1ZmZlcmZ1bGwnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UuY2xlYXJSZXNvdXJjZVRpbWluZ3MoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghc3VwcG9ydFBlcmZvcm1hbmNlVGltaW5nRXZlbnQoJ25hdmlnYXRpb24nKSkge1xuICAgICAgICByZXRyaWV2ZU5hdmlnYXRpb25UaW1pbmcoZnVuY3Rpb24gKHRpbWluZykge1xuICAgICAgICAgICAgaGFuZGxlUnVtUGVyZm9ybWFuY2VFbnRyeShsaWZlQ3ljbGUsIGNvbmZpZ3VyYXRpb24sIHRpbWluZyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIXN1cHBvcnRQZXJmb3JtYW5jZVRpbWluZ0V2ZW50KCdmaXJzdC1pbnB1dCcpKSB7XG4gICAgICAgIHJldHJpZXZlRmlyc3RJbnB1dFRpbWluZyhmdW5jdGlvbiAodGltaW5nKSB7XG4gICAgICAgICAgICBoYW5kbGVSdW1QZXJmb3JtYW5jZUVudHJ5KGxpZmVDeWNsZSwgY29uZmlndXJhdGlvbiwgdGltaW5nKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHJldHJpZXZlSW5pdGlhbERvY3VtZW50UmVzb3VyY2VUaW1pbmcoY2FsbGJhY2spIHtcbiAgICBydW5PblJlYWR5U3RhdGUoJ2ludGVyYWN0aXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGltaW5nO1xuICAgICAgICB2YXIgZm9yY2VkQXR0cmlidXRlcyA9IHtcbiAgICAgICAgICAgIGVudHJ5VHlwZTogJ3Jlc291cmNlJyxcbiAgICAgICAgICAgIGluaXRpYXRvclR5cGU6IEZBS0VfSU5JVElBTF9ET0NVTUVOVCxcbiAgICAgICAgICAgIHRyYWNlSWQ6IGdldERvY3VtZW50VHJhY2VJZChkb2N1bWVudCksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzdXBwb3J0UGVyZm9ybWFuY2VUaW1pbmdFdmVudCgnbmF2aWdhdGlvbicpICYmIHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeVR5cGUoJ25hdmlnYXRpb24nKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgbmF2aWdhdGlvbkVudHJ5ID0gcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5VHlwZSgnbmF2aWdhdGlvbicpWzBdO1xuICAgICAgICAgICAgdGltaW5nID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG5hdmlnYXRpb25FbnRyeS50b0pTT04oKSksIGZvcmNlZEF0dHJpYnV0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlbGF0aXZlUGVyZm9ybWFuY2VUaW1pbmcgPSBjb21wdXRlUmVsYXRpdmVQZXJmb3JtYW5jZVRpbWluZygpO1xuICAgICAgICAgICAgdGltaW5nID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIHJlbGF0aXZlUGVyZm9ybWFuY2VUaW1pbmcpLCB7IGRlY29kZWRCb2R5U2l6ZTogMCwgZHVyYXRpb246IHJlbGF0aXZlUGVyZm9ybWFuY2VUaW1pbmcucmVzcG9uc2VFbmQsIG5hbWU6IHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBzdGFydFRpbWU6IDAgfSksIGZvcmNlZEF0dHJpYnV0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKHRpbWluZyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiByZXRyaWV2ZU5hdmlnYXRpb25UaW1pbmcoY2FsbGJhY2spIHtcbiAgICBmdW5jdGlvbiBzZW5kRmFrZVRpbWluZygpIHtcbiAgICAgICAgY2FsbGJhY2soX19hc3NpZ24oX19hc3NpZ24oe30sIGNvbXB1dGVSZWxhdGl2ZVBlcmZvcm1hbmNlVGltaW5nKCkpLCB7IGVudHJ5VHlwZTogJ25hdmlnYXRpb24nIH0pKTtcbiAgICB9XG4gICAgcnVuT25SZWFkeVN0YXRlKCdjb21wbGV0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gU2VuZCBpdCBhIGJpdCBhZnRlciB0aGUgYWN0dWFsIGxvYWQgZXZlbnQsIHNvIHRoZSBcImxvYWRFdmVudEVuZFwiIHRpbWluZyBpcyBhY2N1cmF0ZVxuICAgICAgICBzZXRUaW1lb3V0KG1vbml0b3Ioc2VuZEZha2VUaW1pbmcpKTtcbiAgICB9KTtcbn1cbi8qKlxuICogZmlyc3QtaW5wdXQgdGltaW5nIGVudHJ5IHBvbHlmaWxsIGJhc2VkIG9uXG4gKiBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lL3dlYi12aXRhbHMvYmxvYi9tYXN0ZXIvc3JjL2xpYi9wb2x5ZmlsbHMvZmlyc3RJbnB1dFBvbHlmaWxsLnRzXG4gKi9cbmZ1bmN0aW9uIHJldHJpZXZlRmlyc3RJbnB1dFRpbWluZyhjYWxsYmFjaykge1xuICAgIHZhciBzdGFydFRpbWVTdGFtcCA9IERhdGUubm93KCk7XG4gICAgdmFyIHRpbWluZ1NlbnQgPSBmYWxzZTtcbiAgICB2YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMgPSBhZGRFdmVudExpc3RlbmVycyh3aW5kb3csIFtcImNsaWNrXCIgLyogQ0xJQ0sgKi8sIFwibW91c2Vkb3duXCIgLyogTU9VU0VfRE9XTiAqLywgXCJrZXlkb3duXCIgLyogS0VZX0RPV04gKi8sIFwidG91Y2hzdGFydFwiIC8qIFRPVUNIX1NUQVJUICovLCBcInBvaW50ZXJkb3duXCIgLyogUE9JTlRFUl9ET1dOICovXSwgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAvLyBPbmx5IGNvdW50IGNhbmNlbGFibGUgZXZlbnRzLCB3aGljaCBzaG91bGQgdHJpZ2dlciBiZWhhdmlvciBpbXBvcnRhbnQgdG8gdGhlIHVzZXIuXG4gICAgICAgIGlmICghZXZ0LmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHRpbWluZyB3aWxsIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgXCJmaXJzdCBJbnB1dCBkZWxheVwiLCB3aGljaCBpcyB0aGUgZGVsdGEgYmV0d2VlblxuICAgICAgICAvLyB3aGVuIHRoZSBzeXN0ZW0gcmVjZWl2ZWQgdGhlIGV2ZW50IChlLmcuIGV2dC50aW1lU3RhbXApIGFuZCB3aGVuIGl0IGNvdWxkIHJ1biB0aGUgY2FsbGJhY2tcbiAgICAgICAgLy8gKGUuZy4gcGVyZm9ybWFuY2Uubm93KCkpLlxuICAgICAgICB2YXIgdGltaW5nID0ge1xuICAgICAgICAgICAgZW50cnlUeXBlOiAnZmlyc3QtaW5wdXQnLFxuICAgICAgICAgICAgcHJvY2Vzc2luZ1N0YXJ0OiByZWxhdGl2ZU5vdygpLFxuICAgICAgICAgICAgc3RhcnRUaW1lOiBldnQudGltZVN0YW1wLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZXZ0LnR5cGUgPT09IFwicG9pbnRlcmRvd25cIiAvKiBQT0lOVEVSX0RPV04gKi8pIHtcbiAgICAgICAgICAgIHNlbmRUaW1pbmdJZlBvaW50ZXJJc05vdENhbmNlbGxlZCh0aW1pbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VuZFRpbWluZyh0aW1pbmcpO1xuICAgICAgICB9XG4gICAgfSwgeyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiB0cnVlIH0pLnN0b3A7XG4gICAgLyoqXG4gICAgICogUG9pbnRlciBldmVudHMgYXJlIGEgc3BlY2lhbCBjYXNlLCBiZWNhdXNlIHRoZXkgY2FuIHRyaWdnZXIgbWFpbiBvciBjb21wb3NpdG9yIHRocmVhZCBiZWhhdmlvci5cbiAgICAgKiBXZSBkaWZmZXJlbnRpYXRlIHRoZXNlIGNhc2VzIGJhc2VkIG9uIHdoZXRoZXIgb3Igbm90IHdlIHNlZSBhIHBvaW50ZXJjYW5jZWwgZXZlbnQsIHdoaWNoIGFyZVxuICAgICAqIGZpcmVkIHdoZW4gd2Ugc2Nyb2xsLiBJZiB3ZSdyZSBzY3JvbGxpbmcgd2UgZG9uJ3QgbmVlZCB0byByZXBvcnQgaW5wdXQgZGVsYXkgc2luY2UgRklEIGV4Y2x1ZGVzXG4gICAgICogc2Nyb2xsaW5nIGFuZCBwaW5jaC96b29taW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNlbmRUaW1pbmdJZlBvaW50ZXJJc05vdENhbmNlbGxlZCh0aW1pbmcpIHtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcnMod2luZG93LCBbXCJwb2ludGVydXBcIiAvKiBQT0lOVEVSX1VQICovLCBcInBvaW50ZXJjYW5jZWxcIiAvKiBQT0lOVEVSX0NBTkNFTCAqL10sIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFwicG9pbnRlcnVwXCIgLyogUE9JTlRFUl9VUCAqLykge1xuICAgICAgICAgICAgICAgIHNlbmRUaW1pbmcodGltaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZW5kVGltaW5nKHRpbWluZykge1xuICAgICAgICBpZiAoIXRpbWluZ1NlbnQpIHtcbiAgICAgICAgICAgIHRpbWluZ1NlbnQgPSB0cnVlO1xuICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIC8vIEluIHNvbWUgY2FzZXMgdGhlIHJlY29yZGVkIGRlbGF5IGlzIGNsZWFybHkgd3JvbmcsIGUuZy4gaXQncyBuZWdhdGl2ZSBvciBpdCdzIGxhcmdlciB0aGFuXG4gICAgICAgICAgICAvLyB0aGUgdGltZSBiZXR3ZWVuIG5vdyBhbmQgd2hlbiB0aGUgcGFnZSB3YXMgbG9hZGVkLlxuICAgICAgICAgICAgLy8gLSBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lTGFicy9maXJzdC1pbnB1dC1kZWxheS9pc3N1ZXMvNFxuICAgICAgICAgICAgLy8gLSBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lTGFicy9maXJzdC1pbnB1dC1kZWxheS9pc3N1ZXMvNlxuICAgICAgICAgICAgLy8gLSBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lTGFicy9maXJzdC1pbnB1dC1kZWxheS9pc3N1ZXMvN1xuICAgICAgICAgICAgdmFyIGRlbGF5ID0gdGltaW5nLnByb2Nlc3NpbmdTdGFydCAtIHRpbWluZy5zdGFydFRpbWU7XG4gICAgICAgICAgICBpZiAoZGVsYXkgPj0gMCAmJiBkZWxheSA8IERhdGUubm93KCkgLSBzdGFydFRpbWVTdGFtcCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRpbWluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb21wdXRlUmVsYXRpdmVQZXJmb3JtYW5jZVRpbWluZygpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIHRpbWluZyA9IHBlcmZvcm1hbmNlLnRpbWluZztcbiAgICBmb3IgKHZhciBrZXkgaW4gdGltaW5nKSB7XG4gICAgICAgIGlmIChpc051bWJlcih0aW1pbmdba2V5XSkpIHtcbiAgICAgICAgICAgIHZhciBudW1iZXJLZXkgPSBrZXk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LXR5cGUtYXNzZXJ0aW9uXG4gICAgICAgICAgICB2YXIgdGltaW5nRWxlbWVudCA9IHRpbWluZ1tudW1iZXJLZXldO1xuICAgICAgICAgICAgcmVzdWx0W251bWJlcktleV0gPSB0aW1pbmdFbGVtZW50ID09PSAwID8gMCA6IGdldFJlbGF0aXZlVGltZSh0aW1pbmdFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaGFuZGxlUGVyZm9ybWFuY2VFbnRyaWVzKGxpZmVDeWNsZSwgY29uZmlndXJhdGlvbiwgZW50cmllcykge1xuICAgIGVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgaWYgKGVudHJ5LmVudHJ5VHlwZSA9PT0gJ3Jlc291cmNlJyB8fFxuICAgICAgICAgICAgZW50cnkuZW50cnlUeXBlID09PSAnbmF2aWdhdGlvbicgfHxcbiAgICAgICAgICAgIGVudHJ5LmVudHJ5VHlwZSA9PT0gJ3BhaW50JyB8fFxuICAgICAgICAgICAgZW50cnkuZW50cnlUeXBlID09PSAnbG9uZ3Rhc2snIHx8XG4gICAgICAgICAgICBlbnRyeS5lbnRyeVR5cGUgPT09ICdsYXJnZXN0LWNvbnRlbnRmdWwtcGFpbnQnIHx8XG4gICAgICAgICAgICBlbnRyeS5lbnRyeVR5cGUgPT09ICdmaXJzdC1pbnB1dCcgfHxcbiAgICAgICAgICAgIGVudHJ5LmVudHJ5VHlwZSA9PT0gJ2xheW91dC1zaGlmdCcpIHtcbiAgICAgICAgICAgIGhhbmRsZVJ1bVBlcmZvcm1hbmNlRW50cnkobGlmZUN5Y2xlLCBjb25maWd1cmF0aW9uLCBlbnRyeSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVJ1bVBlcmZvcm1hbmNlRW50cnkobGlmZUN5Y2xlLCBjb25maWd1cmF0aW9uLCBlbnRyeSkge1xuICAgIGlmIChpc0luY29tcGxldGVOYXZpZ2F0aW9uKGVudHJ5KSB8fCBpc0ZvcmJpZGRlblJlc291cmNlKGNvbmZpZ3VyYXRpb24sIGVudHJ5KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxpZmVDeWNsZS5ub3RpZnkoTGlmZUN5Y2xlRXZlbnRUeXBlLlBFUkZPUk1BTkNFX0VOVFJZX0NPTExFQ1RFRCwgZW50cnkpO1xufVxuZnVuY3Rpb24gaXNJbmNvbXBsZXRlTmF2aWdhdGlvbihlbnRyeSkge1xuICAgIHJldHVybiBlbnRyeS5lbnRyeVR5cGUgPT09ICduYXZpZ2F0aW9uJyAmJiBlbnRyeS5sb2FkRXZlbnRFbmQgPD0gMDtcbn1cbmZ1bmN0aW9uIGlzRm9yYmlkZGVuUmVzb3VyY2UoY29uZmlndXJhdGlvbiwgZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkuZW50cnlUeXBlID09PSAncmVzb3VyY2UnICYmICFpc0FsbG93ZWRSZXF1ZXN0VXJsKGNvbmZpZ3VyYXRpb24sIGVudHJ5Lm5hbWUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGVyZm9ybWFuY2VDb2xsZWN0aW9uLmpzLm1hcCIsImltcG9ydCB7IGNvbWJpbmUsIGlzRW1wdHlPYmplY3QsIGxpbWl0TW9kaWZpY2F0aW9uLCB0aW1lU3RhbXBOb3cgfSBmcm9tICdAZGF0YWRvZy9icm93c2VyLWNvcmUnO1xuaW1wb3J0IHsgUnVtRXZlbnRUeXBlLCB9IGZyb20gJy4uL3Jhd1J1bUV2ZW50LnR5cGVzJztcbmltcG9ydCB7IExpZmVDeWNsZUV2ZW50VHlwZSB9IGZyb20gJy4vbGlmZUN5Y2xlJztcbnZhciBTZXNzaW9uVHlwZTtcbihmdW5jdGlvbiAoU2Vzc2lvblR5cGUpIHtcbiAgICBTZXNzaW9uVHlwZVtcIlNZTlRIRVRJQ1NcIl0gPSBcInN5bnRoZXRpY3NcIjtcbiAgICBTZXNzaW9uVHlwZVtcIlVTRVJcIl0gPSBcInVzZXJcIjtcbn0pKFNlc3Npb25UeXBlIHx8IChTZXNzaW9uVHlwZSA9IHt9KSk7XG52YXIgRklFTERTX1dJVEhfU0VOU0lUSVZFX0RBVEEgPSBbXG4gICAgJ3ZpZXcudXJsJyxcbiAgICAndmlldy5yZWZlcnJlcicsXG4gICAgJ2FjdGlvbi50YXJnZXQubmFtZScsXG4gICAgJ2Vycm9yLm1lc3NhZ2UnLFxuICAgICdlcnJvci5zdGFjaycsXG4gICAgJ2Vycm9yLnJlc291cmNlLnVybCcsXG4gICAgJ3Jlc291cmNlLnVybCcsXG5dO1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0UnVtQXNzZW1ibHkoYXBwbGljYXRpb25JZCwgY29uZmlndXJhdGlvbiwgbGlmZUN5Y2xlLCBzZXNzaW9uLCBwYXJlbnRDb250ZXh0cywgZ2V0Q29tbW9uQ29udGV4dCkge1xuICAgIGxpZmVDeWNsZS5zdWJzY3JpYmUoTGlmZUN5Y2xlRXZlbnRUeXBlLlJBV19SVU1fRVZFTlRfQ09MTEVDVEVELCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IF9hLnN0YXJ0VGltZSwgcmF3UnVtRXZlbnQgPSBfYS5yYXdSdW1FdmVudCwgc2F2ZWRDb21tb25Db250ZXh0ID0gX2Euc2F2ZWRDb21tb25Db250ZXh0LCBjdXN0b21lckNvbnRleHQgPSBfYS5jdXN0b21lckNvbnRleHQ7XG4gICAgICAgIHZhciB2aWV3Q29udGV4dCA9IHBhcmVudENvbnRleHRzLmZpbmRWaWV3KHN0YXJ0VGltZSk7XG4gICAgICAgIGlmIChzZXNzaW9uLmlzVHJhY2tlZCgpICYmIHZpZXdDb250ZXh0ICYmIHZpZXdDb250ZXh0LnNlc3Npb24uaWQpIHtcbiAgICAgICAgICAgIHZhciBhY3Rpb25Db250ZXh0ID0gcGFyZW50Q29udGV4dHMuZmluZEFjdGlvbihzdGFydFRpbWUpO1xuICAgICAgICAgICAgdmFyIGNvbW1vbkNvbnRleHQgPSBzYXZlZENvbW1vbkNvbnRleHQgfHwgZ2V0Q29tbW9uQ29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIHJ1bUNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgX2RkOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdF92ZXJzaW9uOiAyLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYXBwbGljYXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGFwcGxpY2F0aW9uSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkYXRlOiB0aW1lU3RhbXBOb3coKSxcbiAgICAgICAgICAgICAgICBzZXJ2aWNlOiBjb25maWd1cmF0aW9uLnNlcnZpY2UsXG4gICAgICAgICAgICAgICAgc2Vzc2lvbjoge1xuICAgICAgICAgICAgICAgICAgICAvLyBtdXN0IGJlIGNvbXB1dGVkIG9uIGVhY2ggZXZlbnQgYmVjYXVzZSBzeW50aGV0aWNzIGluc3RydW1lbnRhdGlvbiBjYW4gYmUgZG9uZSBhZnRlciBzZGsgZXhlY3V0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIGNmIGh0dHBzOi8vZ2l0aHViLmNvbS9wdXBwZXRlZXIvcHVwcGV0ZWVyL2lzc3Vlcy8zNjY3XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGdldFNlc3Npb25UeXBlKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgc2VydmVyUnVtRXZlbnQgPSAobmVlZFRvQXNzZW1ibGVXaXRoQWN0aW9uKHJhd1J1bUV2ZW50KVxuICAgICAgICAgICAgICAgID8gY29tYmluZShydW1Db250ZXh0LCB2aWV3Q29udGV4dCwgYWN0aW9uQ29udGV4dCwgcmF3UnVtRXZlbnQpXG4gICAgICAgICAgICAgICAgOiBjb21iaW5lKHJ1bUNvbnRleHQsIHZpZXdDb250ZXh0LCByYXdSdW1FdmVudCkpO1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjb21iaW5lKGNvbW1vbkNvbnRleHQuY29udGV4dCwgY3VzdG9tZXJDb250ZXh0KTtcbiAgICAgICAgICAgIGlmICghaXNFbXB0eU9iamVjdChjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIHNlcnZlclJ1bUV2ZW50LmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoJ2hhc19yZXBsYXknIGluIHNlcnZlclJ1bUV2ZW50LnNlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIHNlcnZlclJ1bUV2ZW50LnNlc3Npb24uaGFzX3JlcGxheSA9IGNvbW1vbkNvbnRleHQuaGFzUmVwbGF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0VtcHR5T2JqZWN0KGNvbW1vbkNvbnRleHQudXNlcikpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LXR5cGUtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIHNlcnZlclJ1bUV2ZW50LnVzciA9IGNvbW1vbkNvbnRleHQudXNlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRTZW5kKHNlcnZlclJ1bUV2ZW50LCBjb25maWd1cmF0aW9uLmJlZm9yZVNlbmQpKSB7XG4gICAgICAgICAgICAgICAgbGlmZUN5Y2xlLm5vdGlmeShMaWZlQ3ljbGVFdmVudFR5cGUuUlVNX0VWRU5UX0NPTExFQ1RFRCwgc2VydmVyUnVtRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzaG91bGRTZW5kKGV2ZW50LCBiZWZvcmVTZW5kKSB7XG4gICAgaWYgKGJlZm9yZVNlbmQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGxpbWl0TW9kaWZpY2F0aW9uKGV2ZW50LCBGSUVMRFNfV0lUSF9TRU5TSVRJVkVfREFUQSwgYmVmb3JlU2VuZCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlICYmIGV2ZW50LnR5cGUgIT09IFJ1bUV2ZW50VHlwZS5WSUVXKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNhbid0IGRpc21pc3MgdmlldyBldmVudHMgdXNpbmcgYmVmb3JlU2VuZCFcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBuZWVkVG9Bc3NlbWJsZVdpdGhBY3Rpb24oZXZlbnQpIHtcbiAgICByZXR1cm4gW1J1bUV2ZW50VHlwZS5FUlJPUiwgUnVtRXZlbnRUeXBlLlJFU09VUkNFLCBSdW1FdmVudFR5cGUuTE9OR19UQVNLXS5pbmRleE9mKGV2ZW50LnR5cGUpICE9PSAtMTtcbn1cbmZ1bmN0aW9uIGdldFNlc3Npb25UeXBlKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgIHJldHVybiB3aW5kb3cuX0RBVEFET0dfU1lOVEhFVElDU19CUk9XU0VSID09PSB1bmRlZmluZWQgPyBTZXNzaW9uVHlwZS5VU0VSIDogU2Vzc2lvblR5cGUuU1lOVEhFVElDUztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VtYmx5LmpzLm1hcCIsIi8qKlxuICogSW50ZXJuYWwgY29udGV4dCBrZWVwIHJldHVybmluZyB2MSBmb3JtYXRcbiAqIHRvIG5vdCBicmVhayBjb21wYXRpYmlsaXR5IHdpdGggbG9ncyBkYXRhIGZvcm1hdFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRJbnRlcm5hbENvbnRleHQoYXBwbGljYXRpb25JZCwgc2Vzc2lvbiwgcGFyZW50Q29udGV4dHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChzdGFydFRpbWUpIHtcbiAgICAgICAgICAgIHZhciB2aWV3Q29udGV4dCA9IHBhcmVudENvbnRleHRzLmZpbmRWaWV3KHN0YXJ0VGltZSk7XG4gICAgICAgICAgICBpZiAoc2Vzc2lvbi5pc1RyYWNrZWQoKSAmJiB2aWV3Q29udGV4dCAmJiB2aWV3Q29udGV4dC5zZXNzaW9uLmlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFjdGlvbkNvbnRleHQgPSBwYXJlbnRDb250ZXh0cy5maW5kQWN0aW9uKHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbGljYXRpb25faWQ6IGFwcGxpY2F0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25faWQ6IHZpZXdDb250ZXh0LnNlc3Npb24uaWQsXG4gICAgICAgICAgICAgICAgICAgIHVzZXJfYWN0aW9uOiBhY3Rpb25Db250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogYWN0aW9uQ29udGV4dC5hY3Rpb24uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgdmlldzogdmlld0NvbnRleHQudmlldyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcm5hbENvbnRleHQuanMubWFwIiwiZXhwb3J0IHZhciBMaWZlQ3ljbGVFdmVudFR5cGU7XG4oZnVuY3Rpb24gKExpZmVDeWNsZUV2ZW50VHlwZSkge1xuICAgIExpZmVDeWNsZUV2ZW50VHlwZVtMaWZlQ3ljbGVFdmVudFR5cGVbXCJQRVJGT1JNQU5DRV9FTlRSWV9DT0xMRUNURURcIl0gPSAwXSA9IFwiUEVSRk9STUFOQ0VfRU5UUllfQ09MTEVDVEVEXCI7XG4gICAgTGlmZUN5Y2xlRXZlbnRUeXBlW0xpZmVDeWNsZUV2ZW50VHlwZVtcIkFVVE9fQUNUSU9OX0NSRUFURURcIl0gPSAxXSA9IFwiQVVUT19BQ1RJT05fQ1JFQVRFRFwiO1xuICAgIExpZmVDeWNsZUV2ZW50VHlwZVtMaWZlQ3ljbGVFdmVudFR5cGVbXCJBVVRPX0FDVElPTl9DT01QTEVURURcIl0gPSAyXSA9IFwiQVVUT19BQ1RJT05fQ09NUExFVEVEXCI7XG4gICAgTGlmZUN5Y2xlRXZlbnRUeXBlW0xpZmVDeWNsZUV2ZW50VHlwZVtcIkFVVE9fQUNUSU9OX0RJU0NBUkRFRFwiXSA9IDNdID0gXCJBVVRPX0FDVElPTl9ESVNDQVJERURcIjtcbiAgICBMaWZlQ3ljbGVFdmVudFR5cGVbTGlmZUN5Y2xlRXZlbnRUeXBlW1wiVklFV19DUkVBVEVEXCJdID0gNF0gPSBcIlZJRVdfQ1JFQVRFRFwiO1xuICAgIExpZmVDeWNsZUV2ZW50VHlwZVtMaWZlQ3ljbGVFdmVudFR5cGVbXCJWSUVXX1VQREFURURcIl0gPSA1XSA9IFwiVklFV19VUERBVEVEXCI7XG4gICAgTGlmZUN5Y2xlRXZlbnRUeXBlW0xpZmVDeWNsZUV2ZW50VHlwZVtcIlZJRVdfRU5ERURcIl0gPSA2XSA9IFwiVklFV19FTkRFRFwiO1xuICAgIExpZmVDeWNsZUV2ZW50VHlwZVtMaWZlQ3ljbGVFdmVudFR5cGVbXCJSRVFVRVNUX1NUQVJURURcIl0gPSA3XSA9IFwiUkVRVUVTVF9TVEFSVEVEXCI7XG4gICAgTGlmZUN5Y2xlRXZlbnRUeXBlW0xpZmVDeWNsZUV2ZW50VHlwZVtcIlJFUVVFU1RfQ09NUExFVEVEXCJdID0gOF0gPSBcIlJFUVVFU1RfQ09NUExFVEVEXCI7XG4gICAgTGlmZUN5Y2xlRXZlbnRUeXBlW0xpZmVDeWNsZUV2ZW50VHlwZVtcIlNFU1NJT05fUkVORVdFRFwiXSA9IDldID0gXCJTRVNTSU9OX1JFTkVXRURcIjtcbiAgICBMaWZlQ3ljbGVFdmVudFR5cGVbTGlmZUN5Y2xlRXZlbnRUeXBlW1wiRE9NX01VVEFURURcIl0gPSAxMF0gPSBcIkRPTV9NVVRBVEVEXCI7XG4gICAgTGlmZUN5Y2xlRXZlbnRUeXBlW0xpZmVDeWNsZUV2ZW50VHlwZVtcIkJFRk9SRV9VTkxPQURcIl0gPSAxMV0gPSBcIkJFRk9SRV9VTkxPQURcIjtcbiAgICBMaWZlQ3ljbGVFdmVudFR5cGVbTGlmZUN5Y2xlRXZlbnRUeXBlW1wiUkFXX1JVTV9FVkVOVF9DT0xMRUNURURcIl0gPSAxMl0gPSBcIlJBV19SVU1fRVZFTlRfQ09MTEVDVEVEXCI7XG4gICAgTGlmZUN5Y2xlRXZlbnRUeXBlW0xpZmVDeWNsZUV2ZW50VHlwZVtcIlJVTV9FVkVOVF9DT0xMRUNURURcIl0gPSAxM10gPSBcIlJVTV9FVkVOVF9DT0xMRUNURURcIjtcbiAgICBMaWZlQ3ljbGVFdmVudFR5cGVbTGlmZUN5Y2xlRXZlbnRUeXBlW1wiUkVDT1JEX1NUQVJURURcIl0gPSAxNF0gPSBcIlJFQ09SRF9TVEFSVEVEXCI7XG4gICAgTGlmZUN5Y2xlRXZlbnRUeXBlW0xpZmVDeWNsZUV2ZW50VHlwZVtcIlJFQ09SRF9TVE9QUEVEXCJdID0gMTVdID0gXCJSRUNPUkRfU1RPUFBFRFwiO1xufSkoTGlmZUN5Y2xlRXZlbnRUeXBlIHx8IChMaWZlQ3ljbGVFdmVudFR5cGUgPSB7fSkpO1xudmFyIExpZmVDeWNsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaWZlQ3ljbGUoKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0ge307XG4gICAgfVxuICAgIExpZmVDeWNsZS5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgZGF0YSkge1xuICAgICAgICB2YXIgZXZlbnRDYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrc1tldmVudFR5cGVdO1xuICAgICAgICBpZiAoZXZlbnRDYWxsYmFja3MpIHtcbiAgICAgICAgICAgIGV2ZW50Q2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHJldHVybiBjYWxsYmFjayhkYXRhKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExpZmVDeWNsZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrc1tldmVudFR5cGVdKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrc1tldmVudFR5cGVdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsYmFja3NbZXZlbnRUeXBlXS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2FsbGJhY2tzW2V2ZW50VHlwZV0gPSBfdGhpcy5jYWxsYmFja3NbZXZlbnRUeXBlXS5maWx0ZXIoZnVuY3Rpb24gKG90aGVyKSB7IHJldHVybiBjYWxsYmFjayAhPT0gb3RoZXI7IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBMaWZlQ3ljbGU7XG59KCkpO1xuZXhwb3J0IHsgTGlmZUN5Y2xlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saWZlQ3ljbGUuanMubWFwIiwiaW1wb3J0IHsgbW9uaXRvciwgT05FX01JTlVURSwgU0VTU0lPTl9USU1FX09VVF9ERUxBWSB9IGZyb20gJ0BkYXRhZG9nL2Jyb3dzZXItY29yZSc7XG5pbXBvcnQgeyBMaWZlQ3ljbGVFdmVudFR5cGUgfSBmcm9tICcuL2xpZmVDeWNsZSc7XG5leHBvcnQgdmFyIFZJRVdfQ09OVEVYVF9USU1FX09VVF9ERUxBWSA9IFNFU1NJT05fVElNRV9PVVRfREVMQVk7XG5leHBvcnQgdmFyIEFDVElPTl9DT05URVhUX1RJTUVfT1VUX0RFTEFZID0gNSAqIE9ORV9NSU5VVEU7IC8vIGFyYml0cmFyeVxuZXhwb3J0IHZhciBDTEVBUl9PTERfQ09OVEVYVFNfSU5URVJWQUwgPSBPTkVfTUlOVVRFO1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0UGFyZW50Q29udGV4dHMobGlmZUN5Y2xlLCBzZXNzaW9uKSB7XG4gICAgdmFyIGN1cnJlbnRWaWV3O1xuICAgIHZhciBjdXJyZW50QWN0aW9uO1xuICAgIHZhciBjdXJyZW50U2Vzc2lvbklkO1xuICAgIHZhciBwcmV2aW91c1ZpZXdzID0gW107XG4gICAgdmFyIHByZXZpb3VzQWN0aW9ucyA9IFtdO1xuICAgIGxpZmVDeWNsZS5zdWJzY3JpYmUoTGlmZUN5Y2xlRXZlbnRUeXBlLlZJRVdfQ1JFQVRFRCwgZnVuY3Rpb24gKGN1cnJlbnRDb250ZXh0KSB7XG4gICAgICAgIGlmIChjdXJyZW50Vmlldykge1xuICAgICAgICAgICAgcHJldmlvdXNWaWV3cy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBidWlsZEN1cnJlbnRWaWV3Q29udGV4dCgpLFxuICAgICAgICAgICAgICAgIGVuZFRpbWU6IGN1cnJlbnRDb250ZXh0LnN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWU6IGN1cnJlbnRWaWV3LnN0YXJ0VGltZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRWaWV3ID0gY3VycmVudENvbnRleHQ7XG4gICAgICAgIGN1cnJlbnRTZXNzaW9uSWQgPSBzZXNzaW9uLmdldElkKCk7XG4gICAgfSk7XG4gICAgbGlmZUN5Y2xlLnN1YnNjcmliZShMaWZlQ3ljbGVFdmVudFR5cGUuVklFV19VUERBVEVELCBmdW5jdGlvbiAoY3VycmVudENvbnRleHQpIHtcbiAgICAgICAgLy8gQSB2aWV3IGNhbiBiZSB1cGRhdGVkIGFmdGVyIGl0cyBlbmQuICBXZSBoYXZlIHRvIGVuc3VyZSB0aGF0IHRoZSB2aWV3IGJlaW5nIHVwZGF0ZWQgaXMgdGhlXG4gICAgICAgIC8vIG1vc3QgcmVjZW50bHkgY3JlYXRlZC5cbiAgICAgICAgaWYgKGN1cnJlbnRWaWV3LmlkID09PSBjdXJyZW50Q29udGV4dC5pZCkge1xuICAgICAgICAgICAgY3VycmVudFZpZXcgPSBjdXJyZW50Q29udGV4dDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxpZmVDeWNsZS5zdWJzY3JpYmUoTGlmZUN5Y2xlRXZlbnRUeXBlLkFVVE9fQUNUSU9OX0NSRUFURUQsIGZ1bmN0aW9uIChjdXJyZW50Q29udGV4dCkge1xuICAgICAgICBjdXJyZW50QWN0aW9uID0gY3VycmVudENvbnRleHQ7XG4gICAgfSk7XG4gICAgbGlmZUN5Y2xlLnN1YnNjcmliZShMaWZlQ3ljbGVFdmVudFR5cGUuQVVUT19BQ1RJT05fQ09NUExFVEVELCBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIGlmIChjdXJyZW50QWN0aW9uKSB7XG4gICAgICAgICAgICBwcmV2aW91c0FjdGlvbnMudW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgY29udGV4dDogYnVpbGRDdXJyZW50QWN0aW9uQ29udGV4dCgpLFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kc1xuICAgICAgICAgICAgICAgIGVuZFRpbWU6IChjdXJyZW50QWN0aW9uLnN0YXJ0VGltZSArIGFjdGlvbi5kdXJhdGlvbiksXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBjdXJyZW50QWN0aW9uLnN0YXJ0VGltZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRBY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgbGlmZUN5Y2xlLnN1YnNjcmliZShMaWZlQ3ljbGVFdmVudFR5cGUuQVVUT19BQ1RJT05fRElTQ0FSREVELCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRBY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgbGlmZUN5Y2xlLnN1YnNjcmliZShMaWZlQ3ljbGVFdmVudFR5cGUuU0VTU0lPTl9SRU5FV0VELCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHByZXZpb3VzVmlld3MgPSBbXTtcbiAgICAgICAgcHJldmlvdXNBY3Rpb25zID0gW107XG4gICAgICAgIGN1cnJlbnRWaWV3ID0gdW5kZWZpbmVkO1xuICAgICAgICBjdXJyZW50QWN0aW9uID0gdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIHZhciBjbGVhck9sZENvbnRleHRzSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChtb25pdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJPbGRDb250ZXh0cyhwcmV2aW91c1ZpZXdzLCBWSUVXX0NPTlRFWFRfVElNRV9PVVRfREVMQVkpO1xuICAgICAgICBjbGVhck9sZENvbnRleHRzKHByZXZpb3VzQWN0aW9ucywgQUNUSU9OX0NPTlRFWFRfVElNRV9PVVRfREVMQVkpO1xuICAgIH0pLCBDTEVBUl9PTERfQ09OVEVYVFNfSU5URVJWQUwpO1xuICAgIGZ1bmN0aW9uIGNsZWFyT2xkQ29udGV4dHMocHJldmlvdXNDb250ZXh0cywgdGltZU91dERlbGF5KSB7XG4gICAgICAgIHZhciBvbGRUaW1lVGhyZXNob2xkID0gcGVyZm9ybWFuY2Uubm93KCkgLSB0aW1lT3V0RGVsYXk7XG4gICAgICAgIHdoaWxlIChwcmV2aW91c0NvbnRleHRzLmxlbmd0aCA+IDAgJiYgcHJldmlvdXNDb250ZXh0c1twcmV2aW91c0NvbnRleHRzLmxlbmd0aCAtIDFdLnN0YXJ0VGltZSA8IG9sZFRpbWVUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHByZXZpb3VzQ29udGV4dHMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYnVpbGRDdXJyZW50Vmlld0NvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXNzaW9uOiB7XG4gICAgICAgICAgICAgICAgaWQ6IGN1cnJlbnRTZXNzaW9uSWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlldzoge1xuICAgICAgICAgICAgICAgIGlkOiBjdXJyZW50Vmlldy5pZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBjdXJyZW50Vmlldy5uYW1lLFxuICAgICAgICAgICAgICAgIHJlZmVycmVyOiBjdXJyZW50Vmlldy5yZWZlcnJlcixcbiAgICAgICAgICAgICAgICB1cmw6IGN1cnJlbnRWaWV3LmxvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBidWlsZEN1cnJlbnRBY3Rpb25Db250ZXh0KCkge1xuICAgICAgICByZXR1cm4geyBhY3Rpb246IHsgaWQ6IGN1cnJlbnRBY3Rpb24uaWQgfSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQ29udGV4dChidWlsZENvbnRleHQsIHByZXZpb3VzQ29udGV4dHMsIGN1cnJlbnRDb250ZXh0LCBzdGFydFRpbWUpIHtcbiAgICAgICAgaWYgKHN0YXJ0VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudENvbnRleHQgPyBidWlsZENvbnRleHQoKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudENvbnRleHQgJiYgc3RhcnRUaW1lID49IGN1cnJlbnRDb250ZXh0LnN0YXJ0VGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgcHJldmlvdXNDb250ZXh0c18xID0gcHJldmlvdXNDb250ZXh0czsgX2kgPCBwcmV2aW91c0NvbnRleHRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNDb250ZXh0ID0gcHJldmlvdXNDb250ZXh0c18xW19pXTtcbiAgICAgICAgICAgIGlmIChzdGFydFRpbWUgPiBwcmV2aW91c0NvbnRleHQuZW5kVGltZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJ0VGltZSA+PSBwcmV2aW91c0NvbnRleHQuc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzQ29udGV4dC5jb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGZpbmRBY3Rpb246IGZ1bmN0aW9uIChzdGFydFRpbWUpIHsgcmV0dXJuIGZpbmRDb250ZXh0KGJ1aWxkQ3VycmVudEFjdGlvbkNvbnRleHQsIHByZXZpb3VzQWN0aW9ucywgY3VycmVudEFjdGlvbiwgc3RhcnRUaW1lKTsgfSxcbiAgICAgICAgZmluZFZpZXc6IGZ1bmN0aW9uIChzdGFydFRpbWUpIHsgcmV0dXJuIGZpbmRDb250ZXh0KGJ1aWxkQ3VycmVudFZpZXdDb250ZXh0LCBwcmV2aW91c1ZpZXdzLCBjdXJyZW50Vmlldywgc3RhcnRUaW1lKTsgfSxcbiAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChjbGVhck9sZENvbnRleHRzSW50ZXJ2YWwpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJlbnRDb250ZXh0cy5qcy5tYXAiLCJpbXBvcnQgeyBSZXF1ZXN0VHlwZSwgc3RhcnRGZXRjaFByb3h5LCBzdGFydFhoclByb3h5LCB9IGZyb20gJ0BkYXRhZG9nL2Jyb3dzZXItY29yZSc7XG5pbXBvcnQgeyBMaWZlQ3ljbGVFdmVudFR5cGUgfSBmcm9tICcuL2xpZmVDeWNsZSc7XG5pbXBvcnQgeyBpc0FsbG93ZWRSZXF1ZXN0VXJsIH0gZnJvbSAnLi9ydW1FdmVudHNDb2xsZWN0aW9uL3Jlc291cmNlL3Jlc291cmNlVXRpbHMnO1xuaW1wb3J0IHsgc3RhcnRUcmFjZXIgfSBmcm9tICcuL3RyYWNpbmcvdHJhY2VyJztcbnZhciBuZXh0UmVxdWVzdEluZGV4ID0gMTtcbmV4cG9ydCBmdW5jdGlvbiBzdGFydFJlcXVlc3RDb2xsZWN0aW9uKGxpZmVDeWNsZSwgY29uZmlndXJhdGlvbikge1xuICAgIHZhciB0cmFjZXIgPSBzdGFydFRyYWNlcihjb25maWd1cmF0aW9uKTtcbiAgICB0cmFja1hocihsaWZlQ3ljbGUsIGNvbmZpZ3VyYXRpb24sIHRyYWNlcik7XG4gICAgdHJhY2tGZXRjaChsaWZlQ3ljbGUsIGNvbmZpZ3VyYXRpb24sIHRyYWNlcik7XG59XG5leHBvcnQgZnVuY3Rpb24gdHJhY2tYaHIobGlmZUN5Y2xlLCBjb25maWd1cmF0aW9uLCB0cmFjZXIpIHtcbiAgICB2YXIgeGhyUHJveHkgPSBzdGFydFhoclByb3h5KCk7XG4gICAgeGhyUHJveHkuYmVmb3JlU2VuZChmdW5jdGlvbiAoY29udGV4dCwgeGhyKSB7XG4gICAgICAgIGlmIChpc0FsbG93ZWRSZXF1ZXN0VXJsKGNvbmZpZ3VyYXRpb24sIGNvbnRleHQudXJsKSkge1xuICAgICAgICAgICAgdHJhY2VyLnRyYWNlWGhyKGNvbnRleHQsIHhocik7XG4gICAgICAgICAgICBjb250ZXh0LnJlcXVlc3RJbmRleCA9IGdldE5leHRSZXF1ZXN0SW5kZXgoKTtcbiAgICAgICAgICAgIGxpZmVDeWNsZS5ub3RpZnkoTGlmZUN5Y2xlRXZlbnRUeXBlLlJFUVVFU1RfU1RBUlRFRCwge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RJbmRleDogY29udGV4dC5yZXF1ZXN0SW5kZXgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHhoclByb3h5Lm9uUmVxdWVzdENvbXBsZXRlKGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGlmIChpc0FsbG93ZWRSZXF1ZXN0VXJsKGNvbmZpZ3VyYXRpb24sIGNvbnRleHQudXJsKSkge1xuICAgICAgICAgICAgdHJhY2VyLmNsZWFyVHJhY2luZ0lmQ2FuY2VsbGVkKGNvbnRleHQpO1xuICAgICAgICAgICAgbGlmZUN5Y2xlLm5vdGlmeShMaWZlQ3ljbGVFdmVudFR5cGUuUkVRVUVTVF9DT01QTEVURUQsIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogY29udGV4dC5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICBtZXRob2Q6IGNvbnRleHQubWV0aG9kLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RJbmRleDogY29udGV4dC5yZXF1ZXN0SW5kZXgsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IGNvbnRleHQucmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgc3BhbklkOiBjb250ZXh0LnNwYW5JZCxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWU6IGNvbnRleHQuc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIHN0YXR1czogY29udGV4dC5zdGF0dXMsXG4gICAgICAgICAgICAgICAgdHJhY2VJZDogY29udGV4dC50cmFjZUlkLFxuICAgICAgICAgICAgICAgIHR5cGU6IFJlcXVlc3RUeXBlLlhIUixcbiAgICAgICAgICAgICAgICB1cmw6IGNvbnRleHQudXJsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4geGhyUHJveHk7XG59XG5leHBvcnQgZnVuY3Rpb24gdHJhY2tGZXRjaChsaWZlQ3ljbGUsIGNvbmZpZ3VyYXRpb24sIHRyYWNlcikge1xuICAgIHZhciBmZXRjaFByb3h5ID0gc3RhcnRGZXRjaFByb3h5KCk7XG4gICAgZmV0Y2hQcm94eS5iZWZvcmVTZW5kKGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGlmIChpc0FsbG93ZWRSZXF1ZXN0VXJsKGNvbmZpZ3VyYXRpb24sIGNvbnRleHQudXJsKSkge1xuICAgICAgICAgICAgdHJhY2VyLnRyYWNlRmV0Y2goY29udGV4dCk7XG4gICAgICAgICAgICBjb250ZXh0LnJlcXVlc3RJbmRleCA9IGdldE5leHRSZXF1ZXN0SW5kZXgoKTtcbiAgICAgICAgICAgIGxpZmVDeWNsZS5ub3RpZnkoTGlmZUN5Y2xlRXZlbnRUeXBlLlJFUVVFU1RfU1RBUlRFRCwge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RJbmRleDogY29udGV4dC5yZXF1ZXN0SW5kZXgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGZldGNoUHJveHkub25SZXF1ZXN0Q29tcGxldGUoZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGlzQWxsb3dlZFJlcXVlc3RVcmwoY29uZmlndXJhdGlvbiwgY29udGV4dC51cmwpKSB7XG4gICAgICAgICAgICB0cmFjZXIuY2xlYXJUcmFjaW5nSWZDYW5jZWxsZWQoY29udGV4dCk7XG4gICAgICAgICAgICBsaWZlQ3ljbGUubm90aWZ5KExpZmVDeWNsZUV2ZW50VHlwZS5SRVFVRVNUX0NPTVBMRVRFRCwge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBjb250ZXh0LmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogY29udGV4dC5tZXRob2QsXG4gICAgICAgICAgICAgICAgcmVxdWVzdEluZGV4OiBjb250ZXh0LnJlcXVlc3RJbmRleCxcbiAgICAgICAgICAgICAgICByZXNwb25zZTogY29udGV4dC5yZXNwb25zZSxcbiAgICAgICAgICAgICAgICByZXNwb25zZVR5cGU6IGNvbnRleHQucmVzcG9uc2VUeXBlLFxuICAgICAgICAgICAgICAgIHNwYW5JZDogY29udGV4dC5zcGFuSWQsXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBjb250ZXh0LnN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGNvbnRleHQuc3RhdHVzLFxuICAgICAgICAgICAgICAgIHRyYWNlSWQ6IGNvbnRleHQudHJhY2VJZCxcbiAgICAgICAgICAgICAgICB0eXBlOiBSZXF1ZXN0VHlwZS5GRVRDSCxcbiAgICAgICAgICAgICAgICB1cmw6IGNvbnRleHQudXJsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZmV0Y2hQcm94eTtcbn1cbmZ1bmN0aW9uIGdldE5leHRSZXF1ZXN0SW5kZXgoKSB7XG4gICAgdmFyIHJlc3VsdCA9IG5leHRSZXF1ZXN0SW5kZXg7XG4gICAgbmV4dFJlcXVlc3RJbmRleCArPSAxO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1ZXN0Q29sbGVjdGlvbi5qcy5tYXAiLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgY29tYmluZSwgZ2V0VGltZVN0YW1wLCB0b1NlcnZlckR1cmF0aW9uIH0gZnJvbSAnQGRhdGFkb2cvYnJvd3Nlci1jb3JlJztcbmltcG9ydCB7IEFjdGlvblR5cGUsIFJ1bUV2ZW50VHlwZSB9IGZyb20gJy4uLy4uLy4uL3Jhd1J1bUV2ZW50LnR5cGVzJztcbmltcG9ydCB7IExpZmVDeWNsZUV2ZW50VHlwZSB9IGZyb20gJy4uLy4uL2xpZmVDeWNsZSc7XG5pbXBvcnQgeyB0cmFja0FjdGlvbnMgfSBmcm9tICcuL3RyYWNrQWN0aW9ucyc7XG5leHBvcnQgZnVuY3Rpb24gc3RhcnRBY3Rpb25Db2xsZWN0aW9uKGxpZmVDeWNsZSwgY29uZmlndXJhdGlvbikge1xuICAgIGxpZmVDeWNsZS5zdWJzY3JpYmUoTGlmZUN5Y2xlRXZlbnRUeXBlLkFVVE9fQUNUSU9OX0NPTVBMRVRFRCwgZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gbGlmZUN5Y2xlLm5vdGlmeShMaWZlQ3ljbGVFdmVudFR5cGUuUkFXX1JVTV9FVkVOVF9DT0xMRUNURUQsIHByb2Nlc3NBY3Rpb24oYWN0aW9uKSk7XG4gICAgfSk7XG4gICAgaWYgKGNvbmZpZ3VyYXRpb24udHJhY2tJbnRlcmFjdGlvbnMpIHtcbiAgICAgICAgdHJhY2tBY3Rpb25zKGxpZmVDeWNsZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGFkZEFjdGlvbjogZnVuY3Rpb24gKGFjdGlvbiwgc2F2ZWRDb21tb25Db250ZXh0KSB7XG4gICAgICAgICAgICBsaWZlQ3ljbGUubm90aWZ5KExpZmVDeWNsZUV2ZW50VHlwZS5SQVdfUlVNX0VWRU5UX0NPTExFQ1RFRCwgX19hc3NpZ24oeyBzYXZlZENvbW1vbkNvbnRleHQ6IHNhdmVkQ29tbW9uQ29udGV4dCB9LCBwcm9jZXNzQWN0aW9uKGFjdGlvbikpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcHJvY2Vzc0FjdGlvbihhY3Rpb24pIHtcbiAgICB2YXIgYXV0b0FjdGlvblByb3BlcnRpZXMgPSBpc0F1dG9BY3Rpb24oYWN0aW9uKVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiBhY3Rpb24uY291bnRzLmVycm9yQ291bnQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpZDogYWN0aW9uLmlkLFxuICAgICAgICAgICAgICAgIGxvYWRpbmdfdGltZTogdG9TZXJ2ZXJEdXJhdGlvbihhY3Rpb24uZHVyYXRpb24pLFxuICAgICAgICAgICAgICAgIGxvbmdfdGFzazoge1xuICAgICAgICAgICAgICAgICAgICBjb3VudDogYWN0aW9uLmNvdW50cy5sb25nVGFza0NvdW50LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVzb3VyY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IGFjdGlvbi5jb3VudHMucmVzb3VyY2VDb3VudCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB2YXIgY3VzdG9tZXJDb250ZXh0ID0gIWlzQXV0b0FjdGlvbihhY3Rpb24pID8gYWN0aW9uLmNvbnRleHQgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGFjdGlvbkV2ZW50ID0gY29tYmluZSh7XG4gICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICAgICAgbmFtZTogYWN0aW9uLm5hbWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHlwZTogYWN0aW9uLnR5cGUsXG4gICAgICAgIH0sXG4gICAgICAgIGRhdGU6IGdldFRpbWVTdGFtcChhY3Rpb24uc3RhcnRUaW1lKSxcbiAgICAgICAgdHlwZTogUnVtRXZlbnRUeXBlLkFDVElPTixcbiAgICB9LCBhdXRvQWN0aW9uUHJvcGVydGllcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3VzdG9tZXJDb250ZXh0OiBjdXN0b21lckNvbnRleHQsXG4gICAgICAgIHJhd1J1bUV2ZW50OiBhY3Rpb25FdmVudCxcbiAgICAgICAgc3RhcnRUaW1lOiBhY3Rpb24uc3RhcnRUaW1lLFxuICAgIH07XG59XG5mdW5jdGlvbiBpc0F1dG9BY3Rpb24oYWN0aW9uKSB7XG4gICAgcmV0dXJuIGFjdGlvbi50eXBlICE9PSBBY3Rpb25UeXBlLkNVU1RPTTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGlvbkNvbGxlY3Rpb24uanMubWFwIiwiaW1wb3J0IHsgc2FmZVRydW5jYXRlIH0gZnJvbSAnQGRhdGFkb2cvYnJvd3Nlci1jb3JlJztcbmV4cG9ydCBmdW5jdGlvbiBnZXRBY3Rpb25OYW1lRnJvbUVsZW1lbnQoZWxlbWVudCkge1xuICAgIC8vIFByb2NlZWQgdG8gZ2V0IHRoZSBhY3Rpb24gbmFtZSBpbiB0d28gc3RlcHM6XG4gICAgLy8gKiBmaXJzdCwgZ2V0IHRoZSBuYW1lIHByb2dyYW1tYXRpY2FsbHksIGV4cGxpY2l0bHkgZGVmaW5lZCBieSB0aGUgdXNlci5cbiAgICAvLyAqIHRoZW4sIHVzZSBzdHJhdGVnaWVzIHRoYXQgYXJlIGtub3duIHRvIHJldHVybiBnb29kIHJlc3VsdHMuIFRob3NlIHN0cmF0ZWdpZXMgd2lsbCBiZSB1c2VkIG9uXG4gICAgLy8gICB0aGUgZWxlbWVudCBhbmQgYSBmZXcgcGFyZW50cywgYnV0IGl0J3MgbGlrZWx5IHRoYXQgdGhleSB3b24ndCBzdWNjZWVkIGF0IGFsbC5cbiAgICAvLyAqIGlmIG5vIG5hbWUgaXMgZm91bmQgdGhpcyB3YXksIHVzZSBzdHJhdGVnaWVzIHJldHVybmluZyBsZXNzIGFjY3VyYXRlIG5hbWVzIGFzIGEgZmFsbGJhY2suXG4gICAgLy8gICBUaG9zZSBhcmUgbXVjaCBsaWtlbHkgdG8gc3VjY2VlZC5cbiAgICByZXR1cm4gKGdldEFjdGlvbk5hbWVGcm9tRWxlbWVudFByb2dyYW1tYXRpY2FsbHkoZWxlbWVudCkgfHxcbiAgICAgICAgZ2V0QWN0aW9uTmFtZUZyb21FbGVtZW50Rm9yU3RyYXRlZ2llcyhlbGVtZW50LCBwcmlvcml0eVN0cmF0ZWdpZXMpIHx8XG4gICAgICAgIGdldEFjdGlvbk5hbWVGcm9tRWxlbWVudEZvclN0cmF0ZWdpZXMoZWxlbWVudCwgZmFsbGJhY2tTdHJhdGVnaWVzKSB8fFxuICAgICAgICAnJyk7XG59XG4vKipcbiAqIEdldCB0aGUgYWN0aW9uIG5hbWUgZnJvbSB0aGUgYXR0cmlidXRlICdkYXRhLWRkLWFjdGlvbi1uYW1lJyBvbiB0aGUgZWxlbWVudCBvciBhbnkgb2YgaXRzIHBhcmVudC5cbiAqL1xudmFyIFBST0dSQU1NQVRJQ19BVFRSSUJVVEUgPSAnZGF0YS1kZC1hY3Rpb24tbmFtZSc7XG5mdW5jdGlvbiBnZXRBY3Rpb25OYW1lRnJvbUVsZW1lbnRQcm9ncmFtbWF0aWNhbGx5KHRhcmdldEVsZW1lbnQpIHtcbiAgICB2YXIgZWxlbWVudFdpdGhBdHRyaWJ1dGU7XG4gICAgLy8gV2UgZG9uJ3QgdXNlIGdldEFjdGlvbk5hbWVGcm9tRWxlbWVudEZvclN0cmF0ZWdpZXMgaGVyZSwgYmVjYXVzZSB3ZSB3YW50IHRvIGNvbnNpZGVyIGFsbCBwYXJlbnRzLFxuICAgIC8vIHdpdGhvdXQgbGltaXQuIEl0IGlzIHVwIHRvIHRoZSB1c2VyIHRvIGRlY2xhcmUgYSByZWxldmFudCBuYW1pbmcgc3RyYXRlZ3kuXG4gICAgLy8gSWYgYXZhaWxhYmxlLCB1c2UgZWxlbWVudC5jbG9zZXN0KCkgdG8gbWF0Y2ggZ2V0IHRoZSBhdHRyaWJ1dGUgZnJvbSB0aGUgZWxlbWVudCBvciBhbnkgb2YgaXRzXG4gICAgLy8gcGFyZW50LiAgRWxzZSBmYWxsYmFjayB0byBhIG1vcmUgdHJhZGl0aW9uYWwgaW1wbGVtZW50YXRpb24uXG4gICAgaWYgKHN1cHBvcnRzRWxlbWVudENsb3Nlc3QoKSkge1xuICAgICAgICBlbGVtZW50V2l0aEF0dHJpYnV0ZSA9IHRhcmdldEVsZW1lbnQuY2xvc2VzdChcIltcIiArIFBST0dSQU1NQVRJQ19BVFRSSUJVVEUgKyBcIl1cIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRhcmdldEVsZW1lbnQ7XG4gICAgICAgIHdoaWxlIChlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoUFJPR1JBTU1BVElDX0FUVFJJQlVURSkpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50V2l0aEF0dHJpYnV0ZSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghZWxlbWVudFdpdGhBdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IGVsZW1lbnRXaXRoQXR0cmlidXRlLmdldEF0dHJpYnV0ZShQUk9HUkFNTUFUSUNfQVRUUklCVVRFKTtcbiAgICByZXR1cm4gdHJ1bmNhdGUobm9ybWFsaXplV2hpdGVzcGFjZShuYW1lLnRyaW0oKSkpO1xufVxudmFyIHByaW9yaXR5U3RyYXRlZ2llcyA9IFtcbiAgICAvLyBhc3NvY2lhdGVkIExBQkVMIHRleHRcbiAgICBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAvLyBJRSBkb2VzIG5vdCBzdXBwb3J0IGVsZW1lbnQubGFiZWxzLCBzbyB3ZSBmYWxsYmFjayB0byBhIENTUyBzZWxlY3RvciBiYXNlZCBvbiB0aGUgZWxlbWVudCBpZFxuICAgICAgICAvLyBpbnN0ZWFkXG4gICAgICAgIGlmIChzdXBwb3J0c0xhYmVsUHJvcGVydHkoKSkge1xuICAgICAgICAgICAgaWYgKCdsYWJlbHMnIGluIGVsZW1lbnQgJiYgZWxlbWVudC5sYWJlbHMgJiYgZWxlbWVudC5sYWJlbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRUZXh0dWFsQ29udGVudChlbGVtZW50LmxhYmVsc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudC5pZCkge1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gZWxlbWVudC5vd25lckRvY3VtZW50ICYmIGVsZW1lbnQub3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibGFiZWxbZm9yPVxcXCJcIiArIGVsZW1lbnQuaWQucmVwbGFjZSgnXCInLCAnXFxcXFwiJykgKyBcIlxcXCJdXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsICYmIGdldFRleHR1YWxDb250ZW50KGxhYmVsKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8gSU5QVVQgYnV0dG9uIChhbmQgYXNzb2NpYXRlZCkgdmFsdWVcbiAgICBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0lOUFVUJykge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZWxlbWVudDtcbiAgICAgICAgICAgIHZhciB0eXBlID0gaW5wdXQuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2J1dHRvbicgfHwgdHlwZSA9PT0gJ3N1Ym1pdCcgfHwgdHlwZSA9PT0gJ3Jlc2V0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8gQlVUVE9OLCBMQUJFTCBvciBidXR0b24tbGlrZSBlbGVtZW50IHRleHRcbiAgICBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0JVVFRPTicgfHwgZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0xBQkVMJyB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZSgncm9sZScpID09PSAnYnV0dG9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGdldFRleHR1YWxDb250ZW50KGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKTsgfSxcbiAgICAvLyBhc3NvY2lhdGVkIGVsZW1lbnQgdGV4dCBkZXNpZ25hdGVkIGJ5IHRoZSBhcmlhLWxhYmVsbGVkYnkgYXR0cmlidXRlXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGxhYmVsbGVkQnlBdHRyaWJ1dGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbGxlZGJ5Jyk7XG4gICAgICAgIGlmIChsYWJlbGxlZEJ5QXR0cmlidXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWxsZWRCeUF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIGdldEVsZW1lbnRCeUlkKGVsZW1lbnQsIGlkKTsgfSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChsYWJlbCkgeyByZXR1cm4gQm9vbGVhbihsYWJlbCk7IH0pXG4gICAgICAgICAgICAgICAgLm1hcChnZXRUZXh0dWFsQ29udGVudClcbiAgICAgICAgICAgICAgICAuam9pbignICcpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FsdCcpOyB9LFxuICAgIGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbmFtZScpOyB9LFxuICAgIGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZSgndGl0bGUnKTsgfSxcbiAgICBmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJyk7IH0sXG4gICAgLy8gU0VMRUNUIGZpcnN0IE9QVElPTiB0ZXh0XG4gICAgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCdvcHRpb25zJyBpbiBlbGVtZW50ICYmIGVsZW1lbnQub3B0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VGV4dHVhbENvbnRlbnQoZWxlbWVudC5vcHRpb25zWzBdKTtcbiAgICAgICAgfVxuICAgIH0sXG5dO1xudmFyIGZhbGxiYWNrU3RyYXRlZ2llcyA9IFtmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gZ2V0VGV4dHVhbENvbnRlbnQoZWxlbWVudCk7IH1dO1xuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIHRoZSB0YXJnZXQgZWxlbWVudCBhbmQgaXRzIHBhcmVudCwgdXNpbmcgdGhlIHN0cmF0ZWdpZXMgbGlzdCB0byBnZXQgYW4gYWN0aW9uIG5hbWUuXG4gKiBFYWNoIHN0cmF0ZWdpZXMgYXJlIGFwcGxpZWQgb24gZWFjaCBlbGVtZW50LCBzdG9wcGluZyBhcyBzb29uIGFzIGEgbm9uLWVtcHR5IHZhbHVlIGlzIHJldHVybmVkLlxuICovXG52YXIgTUFYX1BBUkVOVFNfVE9fQ09OU0lERVIgPSAxMDtcbmZ1bmN0aW9uIGdldEFjdGlvbk5hbWVGcm9tRWxlbWVudEZvclN0cmF0ZWdpZXModGFyZ2V0RWxlbWVudCwgc3RyYXRlZ2llcykge1xuICAgIHZhciBlbGVtZW50ID0gdGFyZ2V0RWxlbWVudDtcbiAgICB2YXIgcmVjdXJzaW9uQ291bnRlciA9IDA7XG4gICAgd2hpbGUgKHJlY3Vyc2lvbkNvdW50ZXIgPD0gTUFYX1BBUkVOVFNfVE9fQ09OU0lERVIgJiZcbiAgICAgICAgZWxlbWVudCAmJlxuICAgICAgICBlbGVtZW50Lm5vZGVOYW1lICE9PSAnQk9EWScgJiZcbiAgICAgICAgZWxlbWVudC5ub2RlTmFtZSAhPT0gJ0hUTUwnICYmXG4gICAgICAgIGVsZW1lbnQubm9kZU5hbWUgIT09ICdIRUFEJykge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHN0cmF0ZWdpZXNfMSA9IHN0cmF0ZWdpZXM7IF9pIDwgc3RyYXRlZ2llc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHN0cmF0ZWd5ID0gc3RyYXRlZ2llc18xW19pXTtcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSBzdHJhdGVneShlbGVtZW50KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZV8xID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciB0cmltbWVkTmFtZSA9IG5hbWVfMS50cmltKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyaW1tZWROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVuY2F0ZShub3JtYWxpemVXaGl0ZXNwYWNlKHRyaW1tZWROYW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENvbnNpZGVyIGEgRk9STSBhcyBhIGNvbnRleHR1YWwgbGltaXQgdG8gZ2V0IHRoZSBhY3Rpb24gbmFtZS4gIFRoaXMgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXlcbiAgICAgICAgLy8gYmUgcmVjb25zaWRlcmVkIGluIHRoZSBmdXR1cmUuXG4gICAgICAgIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnRk9STScpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIHJlY3Vyc2lvbkNvdW50ZXIgKz0gMTtcbiAgICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVXaGl0ZXNwYWNlKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG59XG5mdW5jdGlvbiB0cnVuY2F0ZShzKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoID4gMTAwID8gc2FmZVRydW5jYXRlKHMsIDEwMCkgKyBcIiBbLi4uXVwiIDogcztcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRCeUlkKHJlZkVsZW1lbnQsIGlkKSB7XG4gICAgLy8gVXNlIHRoZSBlbGVtZW50IG93bmVyRG9jdW1lbnQgaGVyZSwgYmVjYXVzZSB0ZXN0cyBhcmUgZXhlY3V0ZWQgaW4gYW4gaWZyYW1lLCBzb1xuICAgIC8vIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkIHdvbid0IHdvcmsuXG4gICAgcmV0dXJuIHJlZkVsZW1lbnQub3duZXJEb2N1bWVudCA/IHJlZkVsZW1lbnQub3duZXJEb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgOiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VGV4dHVhbENvbnRlbnQoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50LmlzQ29udGVudEVkaXRhYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCdpbm5lclRleHQnIGluIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHRleHQgPSBlbGVtZW50LmlubmVyVGV4dDtcbiAgICAgICAgaWYgKCFzdXBwb3J0c0lubmVyVGV4dFNjcmlwdEFuZFN0eWxlUmVtb3ZhbCgpKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIGlubmVyIHRleHQgb2YgU0NSSVBUIGFuZCBTVFlMRVMgZnJvbSB0aGUgcmVzdWx0LiBUaGlzIGlzIGEgYml0IGRpcnR5LCBidXQgc2hvdWxkXG4gICAgICAgICAgICAvLyBiZSByZWxhdGl2ZWx5IGZhc3QgYW5kIHdvcmsgaW4gbW9zdCBjYXNlcy5cbiAgICAgICAgICAgIHZhciBlbGVtZW50c1RleHRUb1JlbW92ZSA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc2NyaXB0LCBzdHlsZScpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItZm9yLW9mXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzVGV4dFRvUmVtb3ZlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyVGV4dCA9IGVsZW1lbnRzVGV4dFRvUmVtb3ZlW2ldLmlubmVyVGV4dDtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXJUZXh0LnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoaW5uZXJUZXh0LCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudC50ZXh0Q29udGVudDtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGVsZW1lbnQuaW5uZXJUZXh0IGV4Y2x1ZGVzIHRoZSB0ZXh0IGZyb20gaW5saW5lIFNDUklQVCBhbmQgU1RZTEUgZWxlbWVudC4gIFRoaXNcbiAqIHNob3VsZCBiZSB0aGUgY2FzZSBldmVyeXdoZXJlIGV4Y2VwdCBvbiBzb21lIHZlcnNpb24gb2YgSW50ZXJuZXQgRXhwbG9yZXIuXG4gKiBTZWUgaHR0cDovL3BlcmZlY3Rpb25raWxscy5jb20vdGhlLXBvb3ItbWlzdW5kZXJzdG9vZC1pbm5lclRleHQvI2RpZmYtd2l0aC10ZXh0Q29udGVudFxuICovXG52YXIgc3VwcG9ydHNJbm5lclRleHRTY3JpcHRBbmRTdHlsZVJlbW92YWxSZXN1bHQ7XG5mdW5jdGlvbiBzdXBwb3J0c0lubmVyVGV4dFNjcmlwdEFuZFN0eWxlUmVtb3ZhbCgpIHtcbiAgICBpZiAoc3VwcG9ydHNJbm5lclRleHRTY3JpcHRBbmRTdHlsZVJlbW92YWxSZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9ICcqJztcbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAgIHN1cHBvcnRzSW5uZXJUZXh0U2NyaXB0QW5kU3R5bGVSZW1vdmFsUmVzdWx0ID0gZGl2LmlubmVyVGV4dCA9PT0gJyc7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cHBvcnRzSW5uZXJUZXh0U2NyaXB0QW5kU3R5bGVSZW1vdmFsUmVzdWx0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIGVsZW1lbnQubGFiZWxzIHByb3BlcnR5LiAgVGhpcyBzaG91bGQgYmUgdGhlIGNhc2VcbiAqIGV2ZXJ5d2hlcmUgZXhjZXB0IG9uIEludGVybmV0IEV4cGxvcmVyLlxuICogTm90ZTogVGhlIHJlc3VsdCBpcyBjb21wdXRlZCBsYXppbHksIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCBhbnkgRE9NIGFjY2VzcyB3aGVuIHRoZSBTREsgaXNcbiAqIGV2YWx1YXRlZC5cbiAqL1xudmFyIHN1cHBvcnRzTGFiZWxQcm9wZXJ0eVJlc3VsdDtcbmZ1bmN0aW9uIHN1cHBvcnRzTGFiZWxQcm9wZXJ0eSgpIHtcbiAgICBpZiAoc3VwcG9ydHNMYWJlbFByb3BlcnR5UmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3VwcG9ydHNMYWJlbFByb3BlcnR5UmVzdWx0ID0gJ2xhYmVscycgaW4gSFRNTElucHV0RWxlbWVudC5wcm90b3R5cGU7XG4gICAgfVxuICAgIHJldHVybiBzdXBwb3J0c0xhYmVsUHJvcGVydHlSZXN1bHQ7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgZWxlbWVudC5jbG9zZXN0IG1ldGhvZC4gIFRoaXMgc2hvdWxkIGJlIHRoZSBjYXNlXG4gKiBldmVyeXdoZXJlIGV4Y2VwdCBvbiBJbnRlcm5ldCBFeHBsb3Jlci5cbiAqIE5vdGU6IFRoZSByZXN1bHQgaXMgY29tcHV0ZWQgbGF6aWx5LCBiZWNhdXNlIHdlIGRvbid0IHdhbnQgYW55IERPTSBhY2Nlc3Mgd2hlbiB0aGUgU0RLIGlzXG4gKiBldmFsdWF0ZWQuXG4gKi9cbnZhciBzdXBwb3J0c0VsZW1lbnRDbG9zZXN0UmVzdWx0O1xuZnVuY3Rpb24gc3VwcG9ydHNFbGVtZW50Q2xvc2VzdCgpIHtcbiAgICBpZiAoc3VwcG9ydHNFbGVtZW50Q2xvc2VzdFJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN1cHBvcnRzRWxlbWVudENsb3Nlc3RSZXN1bHQgPSAnY2xvc2VzdCcgaW4gSFRNTEVsZW1lbnQucHJvdG90eXBlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwcG9ydHNFbGVtZW50Q2xvc2VzdFJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEFjdGlvbk5hbWVGcm9tRWxlbWVudC5qcy5tYXAiLCJpbXBvcnQgeyBhZGRFdmVudExpc3RlbmVyLCBlbGFwc2VkLCBnZW5lcmF0ZVVVSUQsIHJlbGF0aXZlTm93LCB9IGZyb20gJ0BkYXRhZG9nL2Jyb3dzZXItY29yZSc7XG5pbXBvcnQgeyBMaWZlQ3ljbGVFdmVudFR5cGUgfSBmcm9tICcuLi8uLi9saWZlQ3ljbGUnO1xuaW1wb3J0IHsgdHJhY2tFdmVudENvdW50cyB9IGZyb20gJy4uLy4uL3RyYWNrRXZlbnRDb3VudHMnO1xuaW1wb3J0IHsgd2FpdElkbGVQYWdlQWN0aXZpdHkgfSBmcm9tICcuLi8uLi90cmFja1BhZ2VBY3Rpdml0aWVzJztcbmltcG9ydCB7IEFjdGlvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9yYXdSdW1FdmVudC50eXBlcyc7XG5pbXBvcnQgeyBnZXRBY3Rpb25OYW1lRnJvbUVsZW1lbnQgfSBmcm9tICcuL2dldEFjdGlvbk5hbWVGcm9tRWxlbWVudCc7XG5leHBvcnQgZnVuY3Rpb24gdHJhY2tBY3Rpb25zKGxpZmVDeWNsZSkge1xuICAgIHZhciBhY3Rpb24gPSBzdGFydEFjdGlvbk1hbmFnZW1lbnQobGlmZUN5Y2xlKTtcbiAgICAvLyBOZXcgdmlld3MgdHJpZ2dlciB0aGUgZGlzY2FyZCBvZiB0aGUgY3VycmVudCBwZW5kaW5nIEFjdGlvblxuICAgIGxpZmVDeWNsZS5zdWJzY3JpYmUoTGlmZUN5Y2xlRXZlbnRUeXBlLlZJRVdfQ1JFQVRFRCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBhY3Rpb24uZGlzY2FyZEN1cnJlbnQoKTtcbiAgICB9KTtcbiAgICB2YXIgc3RvcExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwiY2xpY2tcIiAvKiBDTElDSyAqLywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICghKGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWUgPSBnZXRBY3Rpb25OYW1lRnJvbUVsZW1lbnQoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYWN0aW9uLmNyZWF0ZShBY3Rpb25UeXBlLkNMSUNLLCBuYW1lKTtcbiAgICB9LCB7IGNhcHR1cmU6IHRydWUgfSkuc3RvcDtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhY3Rpb24uZGlzY2FyZEN1cnJlbnQoKTtcbiAgICAgICAgICAgIHN0b3BMaXN0ZW5lcigpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBzdGFydEFjdGlvbk1hbmFnZW1lbnQobGlmZUN5Y2xlKSB7XG4gICAgdmFyIGN1cnJlbnRBY3Rpb247XG4gICAgdmFyIGN1cnJlbnRJZGxlUGFnZUFjdGl2aXR5U3Vic2NyaXB0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKHR5cGUsIG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50QWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGFueSBuZXcgYWN0aW9uIGlmIGFub3RoZXIgb25lIGlzIGFscmVhZHkgb2NjdXJyaW5nLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwZW5kaW5nQXV0b0FjdGlvbiA9IG5ldyBQZW5kaW5nQXV0b0FjdGlvbihsaWZlQ3ljbGUsIHR5cGUsIG5hbWUpO1xuICAgICAgICAgICAgY3VycmVudEFjdGlvbiA9IHBlbmRpbmdBdXRvQWN0aW9uO1xuICAgICAgICAgICAgY3VycmVudElkbGVQYWdlQWN0aXZpdHlTdWJzY3JpcHRpb24gPSB3YWl0SWRsZVBhZ2VBY3Rpdml0eShsaWZlQ3ljbGUsIGZ1bmN0aW9uIChoYWRBY3Rpdml0eSwgZW5kVGltZSkge1xuICAgICAgICAgICAgICAgIGlmIChoYWRBY3Rpdml0eSkge1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQXV0b0FjdGlvbi5jb21wbGV0ZShlbmRUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdBdXRvQWN0aW9uLmRpc2NhcmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudEFjdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBkaXNjYXJkQ3VycmVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50SWRsZVBhZ2VBY3Rpdml0eVN1YnNjcmlwdGlvbi5zdG9wKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudEFjdGlvbi5kaXNjYXJkKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudEFjdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufVxudmFyIFBlbmRpbmdBdXRvQWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBlbmRpbmdBdXRvQWN0aW9uKGxpZmVDeWNsZSwgdHlwZSwgbmFtZSkge1xuICAgICAgICB0aGlzLmxpZmVDeWNsZSA9IGxpZmVDeWNsZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5pZCA9IGdlbmVyYXRlVVVJRCgpO1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHJlbGF0aXZlTm93KCk7XG4gICAgICAgIHRoaXMuZXZlbnRDb3VudHNTdWJzY3JpcHRpb24gPSB0cmFja0V2ZW50Q291bnRzKGxpZmVDeWNsZSk7XG4gICAgICAgIHRoaXMubGlmZUN5Y2xlLm5vdGlmeShMaWZlQ3ljbGVFdmVudFR5cGUuQVVUT19BQ1RJT05fQ1JFQVRFRCwgeyBpZDogdGhpcy5pZCwgc3RhcnRUaW1lOiB0aGlzLnN0YXJ0VGltZSB9KTtcbiAgICB9XG4gICAgUGVuZGluZ0F1dG9BY3Rpb24ucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKGVuZFRpbWUpIHtcbiAgICAgICAgdmFyIGV2ZW50Q291bnRzID0gdGhpcy5ldmVudENvdW50c1N1YnNjcmlwdGlvbi5ldmVudENvdW50cztcbiAgICAgICAgdGhpcy5saWZlQ3ljbGUubm90aWZ5KExpZmVDeWNsZUV2ZW50VHlwZS5BVVRPX0FDVElPTl9DT01QTEVURUQsIHtcbiAgICAgICAgICAgIGNvdW50czoge1xuICAgICAgICAgICAgICAgIGVycm9yQ291bnQ6IGV2ZW50Q291bnRzLmVycm9yQ291bnQsXG4gICAgICAgICAgICAgICAgbG9uZ1Rhc2tDb3VudDogZXZlbnRDb3VudHMubG9uZ1Rhc2tDb3VudCxcbiAgICAgICAgICAgICAgICByZXNvdXJjZUNvdW50OiBldmVudENvdW50cy5yZXNvdXJjZUNvdW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBlbGFwc2VkKHRoaXMuc3RhcnRUaW1lLCBlbmRUaW1lKSxcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgc3RhcnRUaW1lOiB0aGlzLnN0YXJ0VGltZSxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRDb3VudHNTdWJzY3JpcHRpb24uc3RvcCgpO1xuICAgIH07XG4gICAgUGVuZGluZ0F1dG9BY3Rpb24ucHJvdG90eXBlLmRpc2NhcmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGlmZUN5Y2xlLm5vdGlmeShMaWZlQ3ljbGVFdmVudFR5cGUuQVVUT19BQ1RJT05fRElTQ0FSREVEKTtcbiAgICAgICAgdGhpcy5ldmVudENvdW50c1N1YnNjcmlwdGlvbi5zdG9wKCk7XG4gICAgfTtcbiAgICByZXR1cm4gUGVuZGluZ0F1dG9BY3Rpb247XG59KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhY2tBY3Rpb25zLmpzLm1hcCIsImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBjb21wdXRlU3RhY2tUcmFjZSwgZm9ybWF0VW5rbm93bkVycm9yLCBnZXRUaW1lU3RhbXAsIHN0YXJ0QXV0b21hdGljRXJyb3JDb2xsZWN0aW9uLCB9IGZyb20gJ0BkYXRhZG9nL2Jyb3dzZXItY29yZSc7XG5pbXBvcnQgeyBSdW1FdmVudFR5cGUgfSBmcm9tICcuLi8uLi8uLi9yYXdSdW1FdmVudC50eXBlcyc7XG5pbXBvcnQgeyBMaWZlQ3ljbGVFdmVudFR5cGUgfSBmcm9tICcuLi8uLi9saWZlQ3ljbGUnO1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0RXJyb3JDb2xsZWN0aW9uKGxpZmVDeWNsZSwgY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiBkb1N0YXJ0RXJyb3JDb2xsZWN0aW9uKGxpZmVDeWNsZSwgc3RhcnRBdXRvbWF0aWNFcnJvckNvbGxlY3Rpb24oY29uZmlndXJhdGlvbikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRvU3RhcnRFcnJvckNvbGxlY3Rpb24obGlmZUN5Y2xlLCBvYnNlcnZhYmxlKSB7XG4gICAgb2JzZXJ2YWJsZS5zdWJzY3JpYmUoZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBsaWZlQ3ljbGUubm90aWZ5KExpZmVDeWNsZUV2ZW50VHlwZS5SQVdfUlVNX0VWRU5UX0NPTExFQ1RFRCwgcHJvY2Vzc0Vycm9yKGVycm9yKSk7IH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZEVycm9yOiBmdW5jdGlvbiAoX2EsIHNhdmVkQ29tbW9uQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gX2EuZXJyb3IsIHN0YXJ0VGltZSA9IF9hLnN0YXJ0VGltZSwgY3VzdG9tZXJDb250ZXh0ID0gX2EuY29udGV4dCwgc291cmNlID0gX2Euc291cmNlO1xuICAgICAgICAgICAgdmFyIHJhd0Vycm9yID0gY29tcHV0ZVJhd0Vycm9yKGVycm9yLCBzdGFydFRpbWUsIHNvdXJjZSk7XG4gICAgICAgICAgICBsaWZlQ3ljbGUubm90aWZ5KExpZmVDeWNsZUV2ZW50VHlwZS5SQVdfUlVNX0VWRU5UX0NPTExFQ1RFRCwgX19hc3NpZ24oeyBjdXN0b21lckNvbnRleHQ6IGN1c3RvbWVyQ29udGV4dCxcbiAgICAgICAgICAgICAgICBzYXZlZENvbW1vbkNvbnRleHQ6IHNhdmVkQ29tbW9uQ29udGV4dCB9LCBwcm9jZXNzRXJyb3IocmF3RXJyb3IpKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVSYXdFcnJvcihlcnJvciwgc3RhcnRUaW1lLCBzb3VyY2UpIHtcbiAgICB2YXIgc3RhY2tUcmFjZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBjb21wdXRlU3RhY2tUcmFjZShlcnJvcikgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIF9fYXNzaWduKHsgc3RhcnRUaW1lOiBzdGFydFRpbWUsIHNvdXJjZTogc291cmNlIH0sIGZvcm1hdFVua25vd25FcnJvcihzdGFja1RyYWNlLCBlcnJvciwgJ1Byb3ZpZGVkJykpO1xufVxuZnVuY3Rpb24gcHJvY2Vzc0Vycm9yKGVycm9yKSB7XG4gICAgdmFyIHJhd1J1bUV2ZW50ID0ge1xuICAgICAgICBkYXRlOiBnZXRUaW1lU3RhbXAoZXJyb3Iuc3RhcnRUaW1lKSxcbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICByZXNvdXJjZTogZXJyb3IucmVzb3VyY2VcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBlcnJvci5yZXNvdXJjZS5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c19jb2RlOiBlcnJvci5yZXNvdXJjZS5zdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgICAgICB1cmw6IGVycm9yLnJlc291cmNlLnVybCxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzb3VyY2U6IGVycm9yLnNvdXJjZSxcbiAgICAgICAgICAgIHN0YWNrOiBlcnJvci5zdGFjayxcbiAgICAgICAgICAgIHR5cGU6IGVycm9yLnR5cGUsXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IFJ1bUV2ZW50VHlwZS5FUlJPUixcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHJhd1J1bUV2ZW50OiByYXdSdW1FdmVudCxcbiAgICAgICAgc3RhcnRUaW1lOiBlcnJvci5zdGFydFRpbWUsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yQ29sbGVjdGlvbi5qcy5tYXAiLCJpbXBvcnQgeyBnZXRUaW1lU3RhbXAsIHRvU2VydmVyRHVyYXRpb24gfSBmcm9tICdAZGF0YWRvZy9icm93c2VyLWNvcmUnO1xuaW1wb3J0IHsgUnVtRXZlbnRUeXBlIH0gZnJvbSAnLi4vLi4vLi4vcmF3UnVtRXZlbnQudHlwZXMnO1xuaW1wb3J0IHsgTGlmZUN5Y2xlRXZlbnRUeXBlIH0gZnJvbSAnLi4vLi4vbGlmZUN5Y2xlJztcbmV4cG9ydCBmdW5jdGlvbiBzdGFydExvbmdUYXNrQ29sbGVjdGlvbihsaWZlQ3ljbGUpIHtcbiAgICBsaWZlQ3ljbGUuc3Vic2NyaWJlKExpZmVDeWNsZUV2ZW50VHlwZS5QRVJGT1JNQU5DRV9FTlRSWV9DT0xMRUNURUQsIGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBpZiAoZW50cnkuZW50cnlUeXBlICE9PSAnbG9uZ3Rhc2snKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJhd1J1bUV2ZW50ID0ge1xuICAgICAgICAgICAgZGF0ZTogZ2V0VGltZVN0YW1wKGVudHJ5LnN0YXJ0VGltZSksXG4gICAgICAgICAgICBsb25nX3Rhc2s6IHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogdG9TZXJ2ZXJEdXJhdGlvbihlbnRyeS5kdXJhdGlvbiksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHlwZTogUnVtRXZlbnRUeXBlLkxPTkdfVEFTSyxcbiAgICAgICAgfTtcbiAgICAgICAgbGlmZUN5Y2xlLm5vdGlmeShMaWZlQ3ljbGVFdmVudFR5cGUuUkFXX1JVTV9FVkVOVF9DT0xMRUNURUQsIHtcbiAgICAgICAgICAgIHJhd1J1bUV2ZW50OiByYXdSdW1FdmVudCxcbiAgICAgICAgICAgIHN0YXJ0VGltZTogZW50cnkuc3RhcnRUaW1lLFxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvbmdUYXNrQ29sbGVjdGlvbi5qcy5tYXAiLCJpbXBvcnQgeyB0b1ZhbGlkRW50cnkgfSBmcm9tICcuL3Jlc291cmNlVXRpbHMnO1xuLyoqXG4gKiBMb29rIGZvciBjb3JyZXNwb25kaW5nIHRpbWluZyBpbiByZXNvdXJjZSB0aW1pbmcgYnVmZmVyXG4gKlxuICogT2JzZXJ2YXRpb25zOlxuICogLSBUaW1pbmcgKHN0YXJ0LCBlbmQpIGFyZSBuZXN0ZWQgaW5zaWRlIHRoZSByZXF1ZXN0IChzdGFydCwgZW5kKVxuICogLSBCcm93c2VycyBnZW5lcmF0ZSBhIHRpbWluZyBlbnRyeSBmb3IgT1BUSU9OUyByZXF1ZXN0XG4gKlxuICogU3RyYXRlZ3k6XG4gKiAtIGZyb20gdmFsaWQgbmVzdGVkIGVudHJpZXNcbiAqIC0gaWYgYSBzaW5nbGUgdGltaW5nIG1hdGNoLCByZXR1cm4gdGhlIHRpbWluZ1xuICogLSBpZiB0d28gZm9sbG93aW5nIHRpbWluZ3MgbWF0Y2ggKE9QVElPTlMgcmVxdWVzdCksIHJldHVybiB0aGUgdGltaW5nIGZvciB0aGUgYWN0dWFsIHJlcXVlc3RcbiAqIC0gb3RoZXJ3aXNlIHdlIGNhbid0IGRlY2lkZSwgcmV0dXJuIHVuZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hSZXF1ZXN0VGltaW5nKHJlcXVlc3QpIHtcbiAgICBpZiAoIXBlcmZvcm1hbmNlIHx8ICEoJ2dldEVudHJpZXNCeU5hbWUnIGluIHBlcmZvcm1hbmNlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzYW1lTmFtZUVudHJpZXMgPSBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKHJlcXVlc3QudXJsLCAncmVzb3VyY2UnKTtcbiAgICBpZiAoIXNhbWVOYW1lRW50cmllcy5sZW5ndGggfHwgISgndG9KU09OJyBpbiBzYW1lTmFtZUVudHJpZXNbMF0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNhbmRpZGF0ZXMgPSBzYW1lTmFtZUVudHJpZXNcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5LnRvSlNPTigpOyB9KVxuICAgICAgICAuZmlsdGVyKHRvVmFsaWRFbnRyeSlcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGlzQmV0d2VlbihlbnRyeSwgcmVxdWVzdC5zdGFydFRpbWUsIGVuZFRpbWUocmVxdWVzdCkpOyB9KTtcbiAgICBpZiAoY2FuZGlkYXRlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZXNbMF07XG4gICAgfVxuICAgIGlmIChjYW5kaWRhdGVzLmxlbmd0aCA9PT0gMiAmJiBmaXJzdENhbkJlT3B0aW9uUmVxdWVzdChjYW5kaWRhdGVzKSkge1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlc1sxXTtcbiAgICB9XG4gICAgcmV0dXJuO1xufVxuZnVuY3Rpb24gZmlyc3RDYW5CZU9wdGlvblJlcXVlc3QoY29ycmVzcG9uZGluZ0VudHJpZXMpIHtcbiAgICByZXR1cm4gZW5kVGltZShjb3JyZXNwb25kaW5nRW50cmllc1swXSkgPD0gY29ycmVzcG9uZGluZ0VudHJpZXNbMV0uc3RhcnRUaW1lO1xufVxuZnVuY3Rpb24gZW5kVGltZSh0aW1pbmcpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHNcbiAgICByZXR1cm4gKHRpbWluZy5zdGFydFRpbWUgKyB0aW1pbmcuZHVyYXRpb24pO1xufVxuZnVuY3Rpb24gaXNCZXR3ZWVuKHRpbWluZywgc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiB0aW1pbmcuc3RhcnRUaW1lID49IHN0YXJ0ICYmIGVuZFRpbWUodGltaW5nKSA8PSBlbmQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRjaFJlcXVlc3RUaW1pbmcuanMubWFwIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGNvbWJpbmUsIGdlbmVyYXRlVVVJRCwgZ2V0VGltZVN0YW1wLCBSZXF1ZXN0VHlwZSwgUmVzb3VyY2VUeXBlLCB0b1NlcnZlckR1cmF0aW9uIH0gZnJvbSAnQGRhdGFkb2cvYnJvd3Nlci1jb3JlJztcbmltcG9ydCB7IFJ1bUV2ZW50VHlwZSB9IGZyb20gJy4uLy4uLy4uL3Jhd1J1bUV2ZW50LnR5cGVzJztcbmltcG9ydCB7IExpZmVDeWNsZUV2ZW50VHlwZSB9IGZyb20gJy4uLy4uL2xpZmVDeWNsZSc7XG5pbXBvcnQgeyBtYXRjaFJlcXVlc3RUaW1pbmcgfSBmcm9tICcuL21hdGNoUmVxdWVzdFRpbWluZyc7XG5pbXBvcnQgeyBjb21wdXRlUGVyZm9ybWFuY2VSZXNvdXJjZURldGFpbHMsIGNvbXB1dGVQZXJmb3JtYW5jZVJlc291cmNlRHVyYXRpb24sIGNvbXB1dGVSZXNvdXJjZUtpbmQsIGNvbXB1dGVTaXplLCBpc1JlcXVlc3RLaW5kLCB9IGZyb20gJy4vcmVzb3VyY2VVdGlscyc7XG5leHBvcnQgZnVuY3Rpb24gc3RhcnRSZXNvdXJjZUNvbGxlY3Rpb24obGlmZUN5Y2xlLCBzZXNzaW9uKSB7XG4gICAgbGlmZUN5Y2xlLnN1YnNjcmliZShMaWZlQ3ljbGVFdmVudFR5cGUuUkVRVUVTVF9DT01QTEVURUQsIGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIGlmIChzZXNzaW9uLmlzVHJhY2tlZFdpdGhSZXNvdXJjZSgpKSB7XG4gICAgICAgICAgICBsaWZlQ3ljbGUubm90aWZ5KExpZmVDeWNsZUV2ZW50VHlwZS5SQVdfUlVNX0VWRU5UX0NPTExFQ1RFRCwgcHJvY2Vzc1JlcXVlc3QocmVxdWVzdCkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGlmZUN5Y2xlLnN1YnNjcmliZShMaWZlQ3ljbGVFdmVudFR5cGUuUEVSRk9STUFOQ0VfRU5UUllfQ09MTEVDVEVELCBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgaWYgKHNlc3Npb24uaXNUcmFja2VkV2l0aFJlc291cmNlKCkgJiYgZW50cnkuZW50cnlUeXBlID09PSAncmVzb3VyY2UnICYmICFpc1JlcXVlc3RLaW5kKGVudHJ5KSkge1xuICAgICAgICAgICAgbGlmZUN5Y2xlLm5vdGlmeShMaWZlQ3ljbGVFdmVudFR5cGUuUkFXX1JVTV9FVkVOVF9DT0xMRUNURUQsIHByb2Nlc3NSZXNvdXJjZUVudHJ5KGVudHJ5KSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICB2YXIgdHlwZSA9IHJlcXVlc3QudHlwZSA9PT0gUmVxdWVzdFR5cGUuWEhSID8gUmVzb3VyY2VUeXBlLlhIUiA6IFJlc291cmNlVHlwZS5GRVRDSDtcbiAgICB2YXIgbWF0Y2hpbmdUaW1pbmcgPSBtYXRjaFJlcXVlc3RUaW1pbmcocmVxdWVzdCk7XG4gICAgdmFyIHN0YXJ0VGltZSA9IG1hdGNoaW5nVGltaW5nID8gbWF0Y2hpbmdUaW1pbmcuc3RhcnRUaW1lIDogcmVxdWVzdC5zdGFydFRpbWU7XG4gICAgdmFyIGNvcnJlc3BvbmRpbmdUaW1pbmdPdmVycmlkZXMgPSBtYXRjaGluZ1RpbWluZyA/IGNvbXB1dGVQZXJmb3JtYW5jZUVudHJ5TWV0cmljcyhtYXRjaGluZ1RpbWluZykgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHRyYWNpbmdJbmZvID0gY29tcHV0ZVJlcXVlc3RUcmFjaW5nSW5mbyhyZXF1ZXN0KTtcbiAgICB2YXIgcmVzb3VyY2VFdmVudCA9IGNvbWJpbmUoe1xuICAgICAgICBkYXRlOiBnZXRUaW1lU3RhbXAoc3RhcnRUaW1lKSxcbiAgICAgICAgcmVzb3VyY2U6IHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBkdXJhdGlvbjogdG9TZXJ2ZXJEdXJhdGlvbihyZXF1ZXN0LmR1cmF0aW9uKSxcbiAgICAgICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgICBzdGF0dXNfY29kZTogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgICAgICB1cmw6IHJlcXVlc3QudXJsLFxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiBSdW1FdmVudFR5cGUuUkVTT1VSQ0UsXG4gICAgfSwgdHJhY2luZ0luZm8sIGNvcnJlc3BvbmRpbmdUaW1pbmdPdmVycmlkZXMpO1xuICAgIHJldHVybiB7IHN0YXJ0VGltZTogc3RhcnRUaW1lLCByYXdSdW1FdmVudDogcmVzb3VyY2VFdmVudCB9O1xufVxuZnVuY3Rpb24gcHJvY2Vzc1Jlc291cmNlRW50cnkoZW50cnkpIHtcbiAgICB2YXIgdHlwZSA9IGNvbXB1dGVSZXNvdXJjZUtpbmQoZW50cnkpO1xuICAgIHZhciBlbnRyeU1ldHJpY3MgPSBjb21wdXRlUGVyZm9ybWFuY2VFbnRyeU1ldHJpY3MoZW50cnkpO1xuICAgIHZhciB0cmFjaW5nSW5mbyA9IGNvbXB1dGVFbnRyeVRyYWNpbmdJbmZvKGVudHJ5KTtcbiAgICB2YXIgcmVzb3VyY2VFdmVudCA9IGNvbWJpbmUoe1xuICAgICAgICBkYXRlOiBnZXRUaW1lU3RhbXAoZW50cnkuc3RhcnRUaW1lKSxcbiAgICAgICAgcmVzb3VyY2U6IHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICB1cmw6IGVudHJ5Lm5hbWUsXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IFJ1bUV2ZW50VHlwZS5SRVNPVVJDRSxcbiAgICB9LCB0cmFjaW5nSW5mbywgZW50cnlNZXRyaWNzKTtcbiAgICByZXR1cm4geyBzdGFydFRpbWU6IGVudHJ5LnN0YXJ0VGltZSwgcmF3UnVtRXZlbnQ6IHJlc291cmNlRXZlbnQgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVQZXJmb3JtYW5jZUVudHJ5TWV0cmljcyh0aW1pbmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByZXNvdXJjZTogX19hc3NpZ24oeyBkdXJhdGlvbjogY29tcHV0ZVBlcmZvcm1hbmNlUmVzb3VyY2VEdXJhdGlvbih0aW1pbmcpLCBzaXplOiBjb21wdXRlU2l6ZSh0aW1pbmcpIH0sIGNvbXB1dGVQZXJmb3JtYW5jZVJlc291cmNlRGV0YWlscyh0aW1pbmcpKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZVJlcXVlc3RUcmFjaW5nSW5mbyhyZXF1ZXN0KSB7XG4gICAgdmFyIGhhc0JlZW5UcmFjZWQgPSByZXF1ZXN0LnRyYWNlSWQgJiYgcmVxdWVzdC5zcGFuSWQ7XG4gICAgaWYgKCFoYXNCZWVuVHJhY2VkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIF9kZDoge1xuICAgICAgICAgICAgc3Bhbl9pZDogcmVxdWVzdC5zcGFuSWQudG9EZWNpbWFsU3RyaW5nKCksXG4gICAgICAgICAgICB0cmFjZV9pZDogcmVxdWVzdC50cmFjZUlkLnRvRGVjaW1hbFN0cmluZygpLFxuICAgICAgICB9LFxuICAgICAgICByZXNvdXJjZTogeyBpZDogZ2VuZXJhdGVVVUlEKCkgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUVudHJ5VHJhY2luZ0luZm8oZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkudHJhY2VJZCA/IHsgX2RkOiB7IHRyYWNlX2lkOiBlbnRyeS50cmFjZUlkIH0gfSA6IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc291cmNlQ29sbGVjdGlvbi5qcy5tYXAiLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgYWRkTW9uaXRvcmluZ01lc3NhZ2UsIGVsYXBzZWQsIGdldFBhdGhOYW1lLCBpbmNsdWRlcywgaXNWYWxpZFVybCwgUmVzb3VyY2VUeXBlLCB0b1NlcnZlckR1cmF0aW9uLCB9IGZyb20gJ0BkYXRhZG9nL2Jyb3dzZXItY29yZSc7XG5leHBvcnQgdmFyIEZBS0VfSU5JVElBTF9ET0NVTUVOVCA9ICdpbml0aWFsX2RvY3VtZW50JztcbnZhciBSRVNPVVJDRV9UWVBFUyA9IFtcbiAgICBbUmVzb3VyY2VUeXBlLkRPQ1VNRU5ULCBmdW5jdGlvbiAoaW5pdGlhdG9yVHlwZSkgeyByZXR1cm4gRkFLRV9JTklUSUFMX0RPQ1VNRU5UID09PSBpbml0aWF0b3JUeXBlOyB9XSxcbiAgICBbUmVzb3VyY2VUeXBlLlhIUiwgZnVuY3Rpb24gKGluaXRpYXRvclR5cGUpIHsgcmV0dXJuICd4bWxodHRwcmVxdWVzdCcgPT09IGluaXRpYXRvclR5cGU7IH1dLFxuICAgIFtSZXNvdXJjZVR5cGUuRkVUQ0gsIGZ1bmN0aW9uIChpbml0aWF0b3JUeXBlKSB7IHJldHVybiAnZmV0Y2gnID09PSBpbml0aWF0b3JUeXBlOyB9XSxcbiAgICBbUmVzb3VyY2VUeXBlLkJFQUNPTiwgZnVuY3Rpb24gKGluaXRpYXRvclR5cGUpIHsgcmV0dXJuICdiZWFjb24nID09PSBpbml0aWF0b3JUeXBlOyB9XSxcbiAgICBbUmVzb3VyY2VUeXBlLkNTUywgZnVuY3Rpb24gKF8sIHBhdGgpIHsgcmV0dXJuIC9cXC5jc3MkL2kudGVzdChwYXRoKTsgfV0sXG4gICAgW1Jlc291cmNlVHlwZS5KUywgZnVuY3Rpb24gKF8sIHBhdGgpIHsgcmV0dXJuIC9cXC5qcyQvaS50ZXN0KHBhdGgpOyB9XSxcbiAgICBbXG4gICAgICAgIFJlc291cmNlVHlwZS5JTUFHRSxcbiAgICAgICAgZnVuY3Rpb24gKGluaXRpYXRvclR5cGUsIHBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmNsdWRlcyhbJ2ltYWdlJywgJ2ltZycsICdpY29uJ10sIGluaXRpYXRvclR5cGUpIHx8IC9cXC4oZ2lmfGpwZ3xqcGVnfHRpZmZ8cG5nfHN2Z3xpY28pJC9pLmV4ZWMocGF0aCkgIT09IG51bGw7XG4gICAgICAgIH0sXG4gICAgXSxcbiAgICBbUmVzb3VyY2VUeXBlLkZPTlQsIGZ1bmN0aW9uIChfLCBwYXRoKSB7IHJldHVybiAvXFwuKHdvZmZ8ZW90fHdvZmYyfHR0ZikkL2kuZXhlYyhwYXRoKSAhPT0gbnVsbDsgfV0sXG4gICAgW1xuICAgICAgICBSZXNvdXJjZVR5cGUuTUVESUEsXG4gICAgICAgIGZ1bmN0aW9uIChpbml0aWF0b3JUeXBlLCBwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5jbHVkZXMoWydhdWRpbycsICd2aWRlbyddLCBpbml0aWF0b3JUeXBlKSB8fCAvXFwuKG1wM3xtcDQpJC9pLmV4ZWMocGF0aCkgIT09IG51bGw7XG4gICAgICAgIH0sXG4gICAgXSxcbl07XG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVJlc291cmNlS2luZCh0aW1pbmcpIHtcbiAgICB2YXIgdXJsID0gdGltaW5nLm5hbWU7XG4gICAgaWYgKCFpc1ZhbGlkVXJsKHVybCkpIHtcbiAgICAgICAgYWRkTW9uaXRvcmluZ01lc3NhZ2UoXCJGYWlsZWQgdG8gY29uc3RydWN0IFVSTCBmb3IgXFxcIlwiICsgdGltaW5nLm5hbWUgKyBcIlxcXCJcIik7XG4gICAgICAgIHJldHVybiBSZXNvdXJjZVR5cGUuT1RIRVI7XG4gICAgfVxuICAgIHZhciBwYXRoID0gZ2V0UGF0aE5hbWUodXJsKTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIFJFU09VUkNFX1RZUEVTXzEgPSBSRVNPVVJDRV9UWVBFUzsgX2kgPCBSRVNPVVJDRV9UWVBFU18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX2EgPSBSRVNPVVJDRV9UWVBFU18xW19pXSwgdHlwZSA9IF9hWzBdLCBpc1R5cGUgPSBfYVsxXTtcbiAgICAgICAgaWYgKGlzVHlwZSh0aW1pbmcuaW5pdGlhdG9yVHlwZSwgcGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBSZXNvdXJjZVR5cGUuT1RIRVI7XG59XG5mdW5jdGlvbiBhcmVJbk9yZGVyKCkge1xuICAgIHZhciBudW1iZXJzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgbnVtYmVyc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IG51bWJlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKG51bWJlcnNbaSAtIDFdID4gbnVtYmVyc1tpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVxdWVzdEtpbmQodGltaW5nKSB7XG4gICAgcmV0dXJuIHRpbWluZy5pbml0aWF0b3JUeXBlID09PSAneG1saHR0cHJlcXVlc3QnIHx8IHRpbWluZy5pbml0aWF0b3JUeXBlID09PSAnZmV0Y2gnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVQZXJmb3JtYW5jZVJlc291cmNlRHVyYXRpb24oZW50cnkpIHtcbiAgICB2YXIgZHVyYXRpb24gPSBlbnRyeS5kdXJhdGlvbiwgc3RhcnRUaW1lID0gZW50cnkuc3RhcnRUaW1lLCByZXNwb25zZUVuZCA9IGVudHJ5LnJlc3BvbnNlRW5kO1xuICAgIC8vIFNhZmFyaSBkdXJhdGlvbiBpcyBhbHdheXMgMCBvbiB0aW1pbmdzIGJsb2NrZWQgYnkgY3Jvc3Mgb3JpZ2luIHBvbGljaWVzLlxuICAgIGlmIChkdXJhdGlvbiA9PT0gMCAmJiBzdGFydFRpbWUgPCByZXNwb25zZUVuZCkge1xuICAgICAgICByZXR1cm4gdG9TZXJ2ZXJEdXJhdGlvbihlbGFwc2VkKHN0YXJ0VGltZSwgcmVzcG9uc2VFbmQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvU2VydmVyRHVyYXRpb24oZHVyYXRpb24pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVQZXJmb3JtYW5jZVJlc291cmNlRGV0YWlscyhlbnRyeSkge1xuICAgIHZhciB2YWxpZEVudHJ5ID0gdG9WYWxpZEVudHJ5KGVudHJ5KTtcbiAgICBpZiAoIXZhbGlkRW50cnkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIHN0YXJ0VGltZSA9IHZhbGlkRW50cnkuc3RhcnRUaW1lLCBmZXRjaFN0YXJ0ID0gdmFsaWRFbnRyeS5mZXRjaFN0YXJ0LCByZWRpcmVjdFN0YXJ0ID0gdmFsaWRFbnRyeS5yZWRpcmVjdFN0YXJ0LCByZWRpcmVjdEVuZCA9IHZhbGlkRW50cnkucmVkaXJlY3RFbmQsIGRvbWFpbkxvb2t1cFN0YXJ0ID0gdmFsaWRFbnRyeS5kb21haW5Mb29rdXBTdGFydCwgZG9tYWluTG9va3VwRW5kID0gdmFsaWRFbnRyeS5kb21haW5Mb29rdXBFbmQsIGNvbm5lY3RTdGFydCA9IHZhbGlkRW50cnkuY29ubmVjdFN0YXJ0LCBzZWN1cmVDb25uZWN0aW9uU3RhcnQgPSB2YWxpZEVudHJ5LnNlY3VyZUNvbm5lY3Rpb25TdGFydCwgY29ubmVjdEVuZCA9IHZhbGlkRW50cnkuY29ubmVjdEVuZCwgcmVxdWVzdFN0YXJ0ID0gdmFsaWRFbnRyeS5yZXF1ZXN0U3RhcnQsIHJlc3BvbnNlU3RhcnQgPSB2YWxpZEVudHJ5LnJlc3BvbnNlU3RhcnQsIHJlc3BvbnNlRW5kID0gdmFsaWRFbnRyeS5yZXNwb25zZUVuZDtcbiAgICB2YXIgZGV0YWlscyA9IHtcbiAgICAgICAgZG93bmxvYWQ6IGZvcm1hdFRpbWluZyhzdGFydFRpbWUsIHJlc3BvbnNlU3RhcnQsIHJlc3BvbnNlRW5kKSxcbiAgICAgICAgZmlyc3RfYnl0ZTogZm9ybWF0VGltaW5nKHN0YXJ0VGltZSwgcmVxdWVzdFN0YXJ0LCByZXNwb25zZVN0YXJ0KSxcbiAgICB9O1xuICAgIC8vIE1ha2Ugc3VyZSBhIGNvbm5lY3Rpb24gb2NjdXJyZWRcbiAgICBpZiAoY29ubmVjdEVuZCAhPT0gZmV0Y2hTdGFydCkge1xuICAgICAgICBkZXRhaWxzLmNvbm5lY3QgPSBmb3JtYXRUaW1pbmcoc3RhcnRUaW1lLCBjb25uZWN0U3RhcnQsIGNvbm5lY3RFbmQpO1xuICAgICAgICAvLyBNYWtlIHN1cmUgYSBzZWN1cmUgY29ubmVjdGlvbiBvY2N1cnJlZFxuICAgICAgICBpZiAoYXJlSW5PcmRlcihjb25uZWN0U3RhcnQsIHNlY3VyZUNvbm5lY3Rpb25TdGFydCwgY29ubmVjdEVuZCkpIHtcbiAgICAgICAgICAgIGRldGFpbHMuc3NsID0gZm9ybWF0VGltaW5nKHN0YXJ0VGltZSwgc2VjdXJlQ29ubmVjdGlvblN0YXJ0LCBjb25uZWN0RW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgYSBkb21haW4gbG9va3VwIG9jY3VycmVkXG4gICAgaWYgKGRvbWFpbkxvb2t1cEVuZCAhPT0gZmV0Y2hTdGFydCkge1xuICAgICAgICBkZXRhaWxzLmRucyA9IGZvcm1hdFRpbWluZyhzdGFydFRpbWUsIGRvbWFpbkxvb2t1cFN0YXJ0LCBkb21haW5Mb29rdXBFbmQpO1xuICAgIH1cbiAgICBpZiAoaGFzUmVkaXJlY3Rpb24oZW50cnkpKSB7XG4gICAgICAgIGRldGFpbHMucmVkaXJlY3QgPSBmb3JtYXRUaW1pbmcoc3RhcnRUaW1lLCByZWRpcmVjdFN0YXJ0LCByZWRpcmVjdEVuZCk7XG4gICAgfVxuICAgIHJldHVybiBkZXRhaWxzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvVmFsaWRFbnRyeShlbnRyeSkge1xuICAgIC8vIEVuc3VyZSB0aW1pbmdzIGFyZSBpbiB0aGUgcmlnaHQgb3JkZXIuIE9uIHRvcCBvZiBmaWx0ZXJpbmcgb3V0IHBvdGVudGlhbCBpbnZhbGlkXG4gICAgLy8gUnVtUGVyZm9ybWFuY2VSZXNvdXJjZVRpbWluZywgaXQgd2lsbCBpZ25vcmUgZW50cmllcyBmcm9tIHJlcXVlc3RzIHdoZXJlIHRpbWluZ3MgY2Fubm90IGJlXG4gICAgLy8gY29sbGVjdGVkLCBmb3IgZXhhbXBsZSBjcm9zcyBvcmlnaW4gcmVxdWVzdHMgd2l0aG91dCBhIFwiVGltaW5nLUFsbG93LU9yaWdpblwiIGhlYWRlciBhbGxvd2luZ1xuICAgIC8vIGl0LlxuICAgIGlmICghYXJlSW5PcmRlcihlbnRyeS5zdGFydFRpbWUsIGVudHJ5LmZldGNoU3RhcnQsIGVudHJ5LmRvbWFpbkxvb2t1cFN0YXJ0LCBlbnRyeS5kb21haW5Mb29rdXBFbmQsIGVudHJ5LmNvbm5lY3RTdGFydCwgZW50cnkuY29ubmVjdEVuZCwgZW50cnkucmVxdWVzdFN0YXJ0LCBlbnRyeS5yZXNwb25zZVN0YXJ0LCBlbnRyeS5yZXNwb25zZUVuZCkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCFoYXNSZWRpcmVjdGlvbihlbnRyeSkpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH1cbiAgICB2YXIgcmVkaXJlY3RTdGFydCA9IGVudHJ5LnJlZGlyZWN0U3RhcnQsIHJlZGlyZWN0RW5kID0gZW50cnkucmVkaXJlY3RFbmQ7XG4gICAgLy8gRmlyZWZveCBkb2Vzbid0IHByb3ZpZGUgcmVkaXJlY3QgdGltaW5ncyBvbiBjcm9zcyBvcmlnaW4gcmVxdWVzdHMuXG4gICAgLy8gUHJvdmlkZSBhIGRlZmF1bHQgZm9yIHRob3NlLlxuICAgIGlmIChyZWRpcmVjdFN0YXJ0IDwgZW50cnkuc3RhcnRUaW1lKSB7XG4gICAgICAgIHJlZGlyZWN0U3RhcnQgPSBlbnRyeS5zdGFydFRpbWU7XG4gICAgfVxuICAgIGlmIChyZWRpcmVjdEVuZCA8IGVudHJ5LnN0YXJ0VGltZSkge1xuICAgICAgICByZWRpcmVjdEVuZCA9IGVudHJ5LmZldGNoU3RhcnQ7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSByZWRpcmVjdCB0aW1pbmdzIGFyZSBpbiBvcmRlclxuICAgIGlmICghYXJlSW5PcmRlcihlbnRyeS5zdGFydFRpbWUsIHJlZGlyZWN0U3RhcnQsIHJlZGlyZWN0RW5kLCBlbnRyeS5mZXRjaFN0YXJ0KSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGVudHJ5KSwgeyByZWRpcmVjdEVuZDogcmVkaXJlY3RFbmQsXG4gICAgICAgIHJlZGlyZWN0U3RhcnQ6IHJlZGlyZWN0U3RhcnQgfSk7XG59XG5mdW5jdGlvbiBoYXNSZWRpcmVjdGlvbihlbnRyeSkge1xuICAgIC8vIFRoZSBvbmx5IHRpbWUgZmV0Y2hTdGFydCBpcyBkaWZmZXJlbnQgdGhhbiBzdGFydFRpbWUgaXMgaWYgYSByZWRpcmVjdGlvbiBvY2N1cnJlZC5cbiAgICByZXR1cm4gZW50cnkuZmV0Y2hTdGFydCAhPT0gZW50cnkuc3RhcnRUaW1lO1xufVxuZnVuY3Rpb24gZm9ybWF0VGltaW5nKG9yaWdpbiwgc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGR1cmF0aW9uOiB0b1NlcnZlckR1cmF0aW9uKGVsYXBzZWQoc3RhcnQsIGVuZCkpLFxuICAgICAgICBzdGFydDogdG9TZXJ2ZXJEdXJhdGlvbihlbGFwc2VkKG9yaWdpbiwgc3RhcnQpKSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVTaXplKGVudHJ5KSB7XG4gICAgLy8gTWFrZSBzdXJlIGEgcmVxdWVzdCBhY3R1YWxseSBvY2N1cnJlZFxuICAgIGlmIChlbnRyeS5zdGFydFRpbWUgPCBlbnRyeS5yZXNwb25zZVN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBlbnRyeS5kZWNvZGVkQm9keVNpemU7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBbGxvd2VkUmVxdWVzdFVybChjb25maWd1cmF0aW9uLCB1cmwpIHtcbiAgICByZXR1cm4gdXJsICYmICFjb25maWd1cmF0aW9uLmlzSW50YWtlVXJsKHVybCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvdXJjZVV0aWxzLmpzLm1hcCIsImltcG9ydCB7IGFkZEV2ZW50TGlzdGVuZXIgfSBmcm9tICdAZGF0YWRvZy9icm93c2VyLWNvcmUnO1xudmFyIHRyYWNrRmlyc3RIaWRkZW5TaW5nbGV0b247XG52YXIgc3RvcExpc3RlbmVycztcbmV4cG9ydCBmdW5jdGlvbiB0cmFja0ZpcnN0SGlkZGVuKGVtaXR0ZXIpIHtcbiAgICBpZiAoZW1pdHRlciA9PT0gdm9pZCAwKSB7IGVtaXR0ZXIgPSB3aW5kb3c7IH1cbiAgICBpZiAoIXRyYWNrRmlyc3RIaWRkZW5TaW5nbGV0b24pIHtcbiAgICAgICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgIHRyYWNrRmlyc3RIaWRkZW5TaW5nbGV0b24gPSB7IHRpbWVTdGFtcDogMCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJhY2tGaXJzdEhpZGRlblNpbmdsZXRvbiA9IHtcbiAgICAgICAgICAgICAgICB0aW1lU3RhbXA6IEluZmluaXR5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIChzdG9wTGlzdGVuZXJzID0gYWRkRXZlbnRMaXN0ZW5lcihlbWl0dGVyLCBcInBhZ2VoaWRlXCIgLyogUEFHRV9ISURFICovLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGltZVN0YW1wID0gX2EudGltZVN0YW1wO1xuICAgICAgICAgICAgICAgIHRyYWNrRmlyc3RIaWRkZW5TaW5nbGV0b24udGltZVN0YW1wID0gdGltZVN0YW1wO1xuICAgICAgICAgICAgfSwgeyBjYXB0dXJlOiB0cnVlLCBvbmNlOiB0cnVlIH0pLnN0b3ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cmFja0ZpcnN0SGlkZGVuU2luZ2xldG9uO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0Rmlyc3RIaWRkZW4oKSB7XG4gICAgaWYgKHN0b3BMaXN0ZW5lcnMpIHtcbiAgICAgICAgc3RvcExpc3RlbmVycygpO1xuICAgIH1cbiAgICB0cmFja0ZpcnN0SGlkZGVuU2luZ2xldG9uID0gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhY2tGaXJzdEhpZGRlbi5qcy5tYXAiLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgYWRkRXZlbnRMaXN0ZW5lcnMsIGVsYXBzZWQgfSBmcm9tICdAZGF0YWRvZy9icm93c2VyLWNvcmUnO1xuaW1wb3J0IHsgTGlmZUN5Y2xlRXZlbnRUeXBlIH0gZnJvbSAnLi4vLi4vbGlmZUN5Y2xlJztcbmltcG9ydCB7IHRyYWNrRmlyc3RIaWRkZW4gfSBmcm9tICcuL3RyYWNrRmlyc3RIaWRkZW4nO1xuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrSW5pdGlhbFZpZXdUaW1pbmdzKGxpZmVDeWNsZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgdGltaW5ncztcbiAgICBmdW5jdGlvbiBzZXRUaW1pbmdzKG5ld1RpbWluZ3MpIHtcbiAgICAgICAgdGltaW5ncyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aW1pbmdzKSwgbmV3VGltaW5ncyk7XG4gICAgICAgIGNhbGxiYWNrKHRpbWluZ3MpO1xuICAgIH1cbiAgICB2YXIgc3RvcE5hdmlnYXRpb25UcmFja2luZyA9IHRyYWNrTmF2aWdhdGlvblRpbWluZ3MobGlmZUN5Y2xlLCBzZXRUaW1pbmdzKS5zdG9wO1xuICAgIHZhciBzdG9wRkNQVHJhY2tpbmcgPSB0cmFja0ZpcnN0Q29udGVudGZ1bFBhaW50KGxpZmVDeWNsZSwgZnVuY3Rpb24gKGZpcnN0Q29udGVudGZ1bFBhaW50KSB7XG4gICAgICAgIHJldHVybiBzZXRUaW1pbmdzKHsgZmlyc3RDb250ZW50ZnVsUGFpbnQ6IGZpcnN0Q29udGVudGZ1bFBhaW50IH0pO1xuICAgIH0pLnN0b3A7XG4gICAgdmFyIHN0b3BMQ1BUcmFja2luZyA9IHRyYWNrTGFyZ2VzdENvbnRlbnRmdWxQYWludChsaWZlQ3ljbGUsIHdpbmRvdywgZnVuY3Rpb24gKGxhcmdlc3RDb250ZW50ZnVsUGFpbnQpIHtcbiAgICAgICAgc2V0VGltaW5ncyh7XG4gICAgICAgICAgICBsYXJnZXN0Q29udGVudGZ1bFBhaW50OiBsYXJnZXN0Q29udGVudGZ1bFBhaW50LFxuICAgICAgICB9KTtcbiAgICB9KS5zdG9wO1xuICAgIHZhciBzdG9wRklEVHJhY2tpbmcgPSB0cmFja0ZpcnN0SW5wdXRUaW1pbmdzKGxpZmVDeWNsZSwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBmaXJzdElucHV0RGVsYXkgPSBfYS5maXJzdElucHV0RGVsYXksIGZpcnN0SW5wdXRUaW1lID0gX2EuZmlyc3RJbnB1dFRpbWU7XG4gICAgICAgIHNldFRpbWluZ3Moe1xuICAgICAgICAgICAgZmlyc3RJbnB1dERlbGF5OiBmaXJzdElucHV0RGVsYXksXG4gICAgICAgICAgICBmaXJzdElucHV0VGltZTogZmlyc3RJbnB1dFRpbWUsXG4gICAgICAgIH0pO1xuICAgIH0pLnN0b3A7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3RvcE5hdmlnYXRpb25UcmFja2luZygpO1xuICAgICAgICAgICAgc3RvcEZDUFRyYWNraW5nKCk7XG4gICAgICAgICAgICBzdG9wTENQVHJhY2tpbmcoKTtcbiAgICAgICAgICAgIHN0b3BGSURUcmFja2luZygpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdHJhY2tOYXZpZ2F0aW9uVGltaW5ncyhsaWZlQ3ljbGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHN0b3AgPSBsaWZlQ3ljbGUuc3Vic2NyaWJlKExpZmVDeWNsZUV2ZW50VHlwZS5QRVJGT1JNQU5DRV9FTlRSWV9DT0xMRUNURUQsIGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBpZiAoZW50cnkuZW50cnlUeXBlID09PSAnbmF2aWdhdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICBkb21Db21wbGV0ZTogZW50cnkuZG9tQ29tcGxldGUsXG4gICAgICAgICAgICAgICAgZG9tQ29udGVudExvYWRlZDogZW50cnkuZG9tQ29udGVudExvYWRlZEV2ZW50RW5kLFxuICAgICAgICAgICAgICAgIGRvbUludGVyYWN0aXZlOiBlbnRyeS5kb21JbnRlcmFjdGl2ZSxcbiAgICAgICAgICAgICAgICBsb2FkRXZlbnQ6IGVudHJ5LmxvYWRFdmVudEVuZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSkudW5zdWJzY3JpYmU7XG4gICAgcmV0dXJuIHsgc3RvcDogc3RvcCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrRmlyc3RDb250ZW50ZnVsUGFpbnQobGlmZUN5Y2xlLCBjYWxsYmFjaykge1xuICAgIHZhciBmaXJzdEhpZGRlbiA9IHRyYWNrRmlyc3RIaWRkZW4oKTtcbiAgICB2YXIgc3RvcCA9IGxpZmVDeWNsZS5zdWJzY3JpYmUoTGlmZUN5Y2xlRXZlbnRUeXBlLlBFUkZPUk1BTkNFX0VOVFJZX0NPTExFQ1RFRCwgZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIGlmIChlbnRyeS5lbnRyeVR5cGUgPT09ICdwYWludCcgJiZcbiAgICAgICAgICAgIGVudHJ5Lm5hbWUgPT09ICdmaXJzdC1jb250ZW50ZnVsLXBhaW50JyAmJlxuICAgICAgICAgICAgZW50cnkuc3RhcnRUaW1lIDwgZmlyc3RIaWRkZW4udGltZVN0YW1wKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlbnRyeS5zdGFydFRpbWUpO1xuICAgICAgICB9XG4gICAgfSkudW5zdWJzY3JpYmU7XG4gICAgcmV0dXJuIHsgc3RvcDogc3RvcCB9O1xufVxuLyoqXG4gKiBUcmFjayB0aGUgbGFyZ2VzdCBjb250ZW50ZnVsIHBhaW50IChMQ1ApIG9jY3VycmluZyBkdXJpbmcgdGhlIGluaXRpYWwgVmlldy4gIFRoaXMgY2FuIHlpZWxkXG4gKiBtdWx0aXBsZSB2YWx1ZXMsIG9ubHkgdGhlIG1vc3QgcmVjZW50IG9uZSBzaG91bGQgYmUgdXNlZC5cbiAqIERvY3VtZW50YXRpb246IGh0dHBzOi8vd2ViLmRldi9sY3AvXG4gKiBSZWZlcmVuY2UgaW1wbGVtZW50YXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWUvd2ViLXZpdGFscy9ibG9iL21hc3Rlci9zcmMvZ2V0TENQLnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFja0xhcmdlc3RDb250ZW50ZnVsUGFpbnQobGlmZUN5Y2xlLCBlbWl0dGVyLCBjYWxsYmFjaykge1xuICAgIHZhciBmaXJzdEhpZGRlbiA9IHRyYWNrRmlyc3RIaWRkZW4oKTtcbiAgICAvLyBJZ25vcmUgZW50cmllcyB0aGF0IGNvbWUgYWZ0ZXIgdGhlIGZpcnN0IHVzZXIgaW50ZXJhY3Rpb24uICBBY2NvcmRpbmcgdG8gdGhlIGRvY3VtZW50YXRpb24sIHRoZVxuICAgIC8vIGJyb3dzZXIgc2hvdWxkIG5vdCBzZW5kIGxhcmdlc3QtY29udGVudGZ1bC1wYWludCBlbnRyaWVzIGFmdGVyIGEgdXNlciBpbnRlcmFjdCB3aXRoIHRoZSBwYWdlLFxuICAgIC8vIGJ1dCB0aGUgd2ViLXZpdGFscyByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gdXNlcyB0aGlzIGFzIGEgc2FmZWd1YXJkLlxuICAgIHZhciBmaXJzdEludGVyYWN0aW9uVGltZXN0YW1wID0gSW5maW5pdHk7XG4gICAgdmFyIHN0b3BFdmVudExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcnMoZW1pdHRlciwgW1wicG9pbnRlcmRvd25cIiAvKiBQT0lOVEVSX0RPV04gKi8sIFwia2V5ZG93blwiIC8qIEtFWV9ET1dOICovXSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGZpcnN0SW50ZXJhY3Rpb25UaW1lc3RhbXAgPSBldmVudC50aW1lU3RhbXA7XG4gICAgfSwgeyBjYXB0dXJlOiB0cnVlLCBvbmNlOiB0cnVlIH0pLnN0b3A7XG4gICAgdmFyIHVuc3Vic2NyaWJlTGlmZUN5Y2xlID0gbGlmZUN5Y2xlLnN1YnNjcmliZShMaWZlQ3ljbGVFdmVudFR5cGUuUEVSRk9STUFOQ0VfRU5UUllfQ09MTEVDVEVELCBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgaWYgKGVudHJ5LmVudHJ5VHlwZSA9PT0gJ2xhcmdlc3QtY29udGVudGZ1bC1wYWludCcgJiZcbiAgICAgICAgICAgIGVudHJ5LnN0YXJ0VGltZSA8IGZpcnN0SW50ZXJhY3Rpb25UaW1lc3RhbXAgJiZcbiAgICAgICAgICAgIGVudHJ5LnN0YXJ0VGltZSA8IGZpcnN0SGlkZGVuLnRpbWVTdGFtcCkge1xuICAgICAgICAgICAgY2FsbGJhY2soZW50cnkuc3RhcnRUaW1lKTtcbiAgICAgICAgfVxuICAgIH0pLnVuc3Vic2NyaWJlO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN0b3BFdmVudExpc3RlbmVyKCk7XG4gICAgICAgICAgICB1bnN1YnNjcmliZUxpZmVDeWNsZSgpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIFRyYWNrIHRoZSBmaXJzdCBpbnB1dCBvY2N1cnJpbmcgZHVyaW5nIHRoZSBpbml0aWFsIFZpZXcgdG8gcmV0dXJuOlxuICogLSBGaXJzdCBJbnB1dCBEZWxheVxuICogLSBGaXJzdCBJbnB1dCBUaW1lXG4gKiBDYWxsYmFjayBpcyBjYWxsZWQgYXQgbW9zdCBvbmUgdGltZS5cbiAqIERvY3VtZW50YXRpb246IGh0dHBzOi8vd2ViLmRldi9maWQvXG4gKiBSZWZlcmVuY2UgaW1wbGVtZW50YXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWUvd2ViLXZpdGFscy9ibG9iL21hc3Rlci9zcmMvZ2V0RklELnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFja0ZpcnN0SW5wdXRUaW1pbmdzKGxpZmVDeWNsZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmlyc3RIaWRkZW4gPSB0cmFja0ZpcnN0SGlkZGVuKCk7XG4gICAgdmFyIHN0b3AgPSBsaWZlQ3ljbGUuc3Vic2NyaWJlKExpZmVDeWNsZUV2ZW50VHlwZS5QRVJGT1JNQU5DRV9FTlRSWV9DT0xMRUNURUQsIGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBpZiAoZW50cnkuZW50cnlUeXBlID09PSAnZmlyc3QtaW5wdXQnICYmIGVudHJ5LnN0YXJ0VGltZSA8IGZpcnN0SGlkZGVuLnRpbWVTdGFtcCkge1xuICAgICAgICAgICAgdmFyIGZpcnN0SW5wdXREZWxheSA9IGVsYXBzZWQoZW50cnkuc3RhcnRUaW1lLCBlbnRyeS5wcm9jZXNzaW5nU3RhcnQpO1xuICAgICAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBmaXJzdElucHV0RGVsYXkgdG8gYmUgcG9zaXRpdmUsIHNlZVxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTExODU4MTVcbiAgICAgICAgICAgICAgICBmaXJzdElucHV0RGVsYXk6IGZpcnN0SW5wdXREZWxheSA+PSAwID8gZmlyc3RJbnB1dERlbGF5IDogMCxcbiAgICAgICAgICAgICAgICBmaXJzdElucHV0VGltZTogZW50cnkuc3RhcnRUaW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KS51bnN1YnNjcmliZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdG9wOiBzdG9wLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFja0luaXRpYWxWaWV3VGltaW5ncy5qcy5tYXAiLCJpbXBvcnQgeyBtb25pdG9yLCBhZGRFdmVudExpc3RlbmVyIH0gZnJvbSAnQGRhdGFkb2cvYnJvd3Nlci1jb3JlJztcbmV4cG9ydCBmdW5jdGlvbiB0cmFja0xvY2F0aW9uQ2hhbmdlcyhvbkxvY2F0aW9uQ2hhbmdlKSB7XG4gICAgdmFyIHN0b3BIaXN0b3J5VHJhY2tpbmcgPSB0cmFja0hpc3Rvcnkob25Mb2NhdGlvbkNoYW5nZSkuc3RvcDtcbiAgICB2YXIgc3RvcEhhc2hUcmFja2luZyA9IHRyYWNrSGFzaChvbkxvY2F0aW9uQ2hhbmdlKS5zdG9wO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN0b3BIaXN0b3J5VHJhY2tpbmcoKTtcbiAgICAgICAgICAgIHN0b3BIYXNoVHJhY2tpbmcoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFyZURpZmZlcmVudExvY2F0aW9uKGN1cnJlbnRMb2NhdGlvbiwgb3RoZXJMb2NhdGlvbikge1xuICAgIHJldHVybiAoY3VycmVudExvY2F0aW9uLnBhdGhuYW1lICE9PSBvdGhlckxvY2F0aW9uLnBhdGhuYW1lIHx8XG4gICAgICAgICghaXNIYXNoQW5BbmNob3Iob3RoZXJMb2NhdGlvbi5oYXNoKSAmJlxuICAgICAgICAgICAgZ2V0UGF0aEZyb21IYXNoKG90aGVyTG9jYXRpb24uaGFzaCkgIT09IGdldFBhdGhGcm9tSGFzaChjdXJyZW50TG9jYXRpb24uaGFzaCkpKTtcbn1cbmZ1bmN0aW9uIHRyYWNrSGlzdG9yeShvbkhpc3RvcnlDaGFuZ2UpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgdmFyIG9yaWdpbmFsUHVzaFN0YXRlID0gaGlzdG9yeS5wdXNoU3RhdGU7XG4gICAgaGlzdG9yeS5wdXNoU3RhdGUgPSBtb25pdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb3JpZ2luYWxQdXNoU3RhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgb25IaXN0b3J5Q2hhbmdlKCk7XG4gICAgfSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgIHZhciBvcmlnaW5hbFJlcGxhY2VTdGF0ZSA9IGhpc3RvcnkucmVwbGFjZVN0YXRlO1xuICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlID0gbW9uaXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9yaWdpbmFsUmVwbGFjZVN0YXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIG9uSGlzdG9yeUNoYW5nZSgpO1xuICAgIH0pO1xuICAgIHZhciByZW1vdmVMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXIod2luZG93LCBcInBvcHN0YXRlXCIgLyogUE9QX1NUQVRFICovLCBvbkhpc3RvcnlDaGFuZ2UpLnN0b3A7XG4gICAgdmFyIHN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgIGhpc3RvcnkucHVzaFN0YXRlID0gb3JpZ2luYWxQdXNoU3RhdGU7XG4gICAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlID0gb3JpZ2luYWxSZXBsYWNlU3RhdGU7XG4gICAgfTtcbiAgICByZXR1cm4geyBzdG9wOiBzdG9wIH07XG59XG5mdW5jdGlvbiB0cmFja0hhc2gob25IYXNoQ2hhbmdlKSB7XG4gICAgcmV0dXJuIGFkZEV2ZW50TGlzdGVuZXIod2luZG93LCBcImhhc2hjaGFuZ2VcIiAvKiBIQVNIX0NIQU5HRSAqLywgb25IYXNoQ2hhbmdlKTtcbn1cbmZ1bmN0aW9uIGlzSGFzaEFuQW5jaG9yKGhhc2gpIHtcbiAgICB2YXIgY29ycmVzcG9uZGluZ0lkID0gaGFzaC5zdWJzdHIoMSk7XG4gICAgcmV0dXJuICEhZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29ycmVzcG9uZGluZ0lkKTtcbn1cbmZ1bmN0aW9uIGdldFBhdGhGcm9tSGFzaChoYXNoKSB7XG4gICAgdmFyIGluZGV4ID0gaGFzaC5pbmRleE9mKCc/Jyk7XG4gICAgcmV0dXJuIGluZGV4IDwgMCA/IGhhc2ggOiBoYXNoLnNsaWNlKDAsIGluZGV4KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYWNrTG9jYXRpb25DaGFuZ2VzLmpzLm1hcCIsImltcG9ydCB7IG5vb3AsIHJlbGF0aXZlTm93LCBlbGFwc2VkLCByb3VuZCB9IGZyb20gJ0BkYXRhZG9nL2Jyb3dzZXItY29yZSc7XG5pbXBvcnQgeyB0cmFja0V2ZW50Q291bnRzIH0gZnJvbSAnLi4vLi4vdHJhY2tFdmVudENvdW50cyc7XG5pbXBvcnQgeyBWaWV3TG9hZGluZ1R5cGUgfSBmcm9tICcuLi8uLi8uLi9yYXdSdW1FdmVudC50eXBlcyc7XG5pbXBvcnQgeyB3YWl0SWRsZVBhZ2VBY3Rpdml0eSB9IGZyb20gJy4uLy4uL3RyYWNrUGFnZUFjdGl2aXRpZXMnO1xuaW1wb3J0IHsgc3VwcG9ydFBlcmZvcm1hbmNlVGltaW5nRXZlbnQgfSBmcm9tICcuLi8uLi8uLi9icm93c2VyL3BlcmZvcm1hbmNlQ29sbGVjdGlvbic7XG5pbXBvcnQgeyBMaWZlQ3ljbGVFdmVudFR5cGUgfSBmcm9tICcuLi8uLi9saWZlQ3ljbGUnO1xuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrVmlld01ldHJpY3MobGlmZUN5Y2xlLCBzY2hlZHVsZVZpZXdVcGRhdGUsIGxvYWRpbmdUeXBlKSB7XG4gICAgdmFyIHZpZXdNZXRyaWNzID0ge1xuICAgICAgICBldmVudENvdW50czoge1xuICAgICAgICAgICAgZXJyb3JDb3VudDogMCxcbiAgICAgICAgICAgIGxvbmdUYXNrQ291bnQ6IDAsXG4gICAgICAgICAgICByZXNvdXJjZUNvdW50OiAwLFxuICAgICAgICAgICAgdXNlckFjdGlvbkNvdW50OiAwLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgdmFyIHN0b3BFdmVudENvdW50c1RyYWNraW5nID0gdHJhY2tFdmVudENvdW50cyhsaWZlQ3ljbGUsIGZ1bmN0aW9uIChuZXdFdmVudENvdW50cykge1xuICAgICAgICB2aWV3TWV0cmljcy5ldmVudENvdW50cyA9IG5ld0V2ZW50Q291bnRzO1xuICAgICAgICBzY2hlZHVsZVZpZXdVcGRhdGUoKTtcbiAgICB9KS5zdG9wO1xuICAgIHZhciBfYSA9IHRyYWNrTG9hZGluZ1RpbWUobG9hZGluZ1R5cGUsIGZ1bmN0aW9uIChuZXdMb2FkaW5nVGltZSkge1xuICAgICAgICB2aWV3TWV0cmljcy5sb2FkaW5nVGltZSA9IG5ld0xvYWRpbmdUaW1lO1xuICAgICAgICBzY2hlZHVsZVZpZXdVcGRhdGUoKTtcbiAgICB9KSwgc2V0QWN0aXZpdHlMb2FkaW5nVGltZSA9IF9hLnNldEFjdGl2aXR5TG9hZGluZ1RpbWUsIHNldExvYWRFdmVudCA9IF9hLnNldExvYWRFdmVudDtcbiAgICB2YXIgc3RvcEFjdGl2aXR5TG9hZGluZ1RpbWVUcmFja2luZyA9IHRyYWNrQWN0aXZpdHlMb2FkaW5nVGltZShsaWZlQ3ljbGUsIHNldEFjdGl2aXR5TG9hZGluZ1RpbWUpLnN0b3A7XG4gICAgdmFyIHN0b3BDTFNUcmFja2luZztcbiAgICBpZiAoaXNMYXlvdXRTaGlmdFN1cHBvcnRlZCgpKSB7XG4gICAgICAgIHZpZXdNZXRyaWNzLmN1bXVsYXRpdmVMYXlvdXRTaGlmdCA9IDA7XG4gICAgICAgIChzdG9wQ0xTVHJhY2tpbmcgPSB0cmFja0xheW91dFNoaWZ0KGxpZmVDeWNsZSwgZnVuY3Rpb24gKGxheW91dFNoaWZ0KSB7XG4gICAgICAgICAgICB2aWV3TWV0cmljcy5jdW11bGF0aXZlTGF5b3V0U2hpZnQgPSByb3VuZCh2aWV3TWV0cmljcy5jdW11bGF0aXZlTGF5b3V0U2hpZnQgKyBsYXlvdXRTaGlmdCwgNCk7XG4gICAgICAgICAgICBzY2hlZHVsZVZpZXdVcGRhdGUoKTtcbiAgICAgICAgfSkuc3RvcCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdG9wQ0xTVHJhY2tpbmcgPSBub29wO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdG9wRXZlbnRDb3VudHNUcmFja2luZygpO1xuICAgICAgICAgICAgc3RvcEFjdGl2aXR5TG9hZGluZ1RpbWVUcmFja2luZygpO1xuICAgICAgICAgICAgc3RvcENMU1RyYWNraW5nKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldExvYWRFdmVudDogc2V0TG9hZEV2ZW50LFxuICAgICAgICB2aWV3TWV0cmljczogdmlld01ldHJpY3MsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRyYWNrTG9hZGluZ1RpbWUobG9hZFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGlzV2FpdGluZ0ZvckxvYWRFdmVudCA9IGxvYWRUeXBlID09PSBWaWV3TG9hZGluZ1R5cGUuSU5JVElBTF9MT0FEO1xuICAgIHZhciBpc1dhaXRpbmdGb3JBY3Rpdml0eUxvYWRpbmdUaW1lID0gdHJ1ZTtcbiAgICB2YXIgbG9hZGluZ1RpbWVDYW5kaWRhdGVzID0gW107XG4gICAgZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2tJZkFsbENhbmRpZGF0ZXNBcmVSZWNlaXZlZCgpIHtcbiAgICAgICAgaWYgKCFpc1dhaXRpbmdGb3JBY3Rpdml0eUxvYWRpbmdUaW1lICYmICFpc1dhaXRpbmdGb3JMb2FkRXZlbnQgJiYgbG9hZGluZ1RpbWVDYW5kaWRhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKE1hdGgubWF4LmFwcGx5KE1hdGgsIGxvYWRpbmdUaW1lQ2FuZGlkYXRlcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNldExvYWRFdmVudDogZnVuY3Rpb24gKGxvYWRFdmVudCkge1xuICAgICAgICAgICAgaWYgKGlzV2FpdGluZ0ZvckxvYWRFdmVudCkge1xuICAgICAgICAgICAgICAgIGlzV2FpdGluZ0ZvckxvYWRFdmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxvYWRpbmdUaW1lQ2FuZGlkYXRlcy5wdXNoKGxvYWRFdmVudCk7XG4gICAgICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2tJZkFsbENhbmRpZGF0ZXNBcmVSZWNlaXZlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRBY3Rpdml0eUxvYWRpbmdUaW1lOiBmdW5jdGlvbiAoYWN0aXZpdHlMb2FkaW5nVGltZSkge1xuICAgICAgICAgICAgaWYgKGlzV2FpdGluZ0ZvckFjdGl2aXR5TG9hZGluZ1RpbWUpIHtcbiAgICAgICAgICAgICAgICBpc1dhaXRpbmdGb3JBY3Rpdml0eUxvYWRpbmdUaW1lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2aXR5TG9hZGluZ1RpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nVGltZUNhbmRpZGF0ZXMucHVzaChhY3Rpdml0eUxvYWRpbmdUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2tJZkFsbENhbmRpZGF0ZXNBcmVSZWNlaXZlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiB0cmFja0FjdGl2aXR5TG9hZGluZ1RpbWUobGlmZUN5Y2xlLCBjYWxsYmFjaykge1xuICAgIHZhciBzdGFydFRpbWUgPSByZWxhdGl2ZU5vdygpO1xuICAgIHZhciBzdG9wV2FpdElkbGVQYWdlQWN0aXZpdHkgPSB3YWl0SWRsZVBhZ2VBY3Rpdml0eShsaWZlQ3ljbGUsIGZ1bmN0aW9uIChoYWRBY3Rpdml0eSwgZW5kVGltZSkge1xuICAgICAgICBpZiAoaGFkQWN0aXZpdHkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVsYXBzZWQoc3RhcnRUaW1lLCBlbmRUaW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfSkuc3RvcDtcbiAgICByZXR1cm4geyBzdG9wOiBzdG9wV2FpdElkbGVQYWdlQWN0aXZpdHkgfTtcbn1cbi8qKlxuICogVHJhY2sgbGF5b3V0IHNoaWZ0cyAoTFMpIG9jY3VycmluZyBkdXJpbmcgdGhlIFZpZXdzLiAgVGhpcyB5aWVsZHMgbXVsdGlwbGUgdmFsdWVzIHRoYXQgY2FuIGJlXG4gKiBhZGRlZCB1cCB0byBjb21wdXRlIHRoZSBjdW11bGF0ZWQgbGF5b3V0IHNoaWZ0IChDTFMpLlxuICpcbiAqIFNlZSBpc0xheW91dFNoaWZ0U3VwcG9ydGVkIHRvIGNoZWNrIGZvciBicm93c2VyIHN1cHBvcnQuXG4gKlxuICogRG9jdW1lbnRhdGlvbjogaHR0cHM6Ly93ZWIuZGV2L2Nscy9cbiAqIFJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS93ZWItdml0YWxzL2Jsb2IvbWFzdGVyL3NyYy9nZXRDTFMudHNcbiAqL1xuZnVuY3Rpb24gdHJhY2tMYXlvdXRTaGlmdChsaWZlQ3ljbGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHN0b3AgPSBsaWZlQ3ljbGUuc3Vic2NyaWJlKExpZmVDeWNsZUV2ZW50VHlwZS5QRVJGT1JNQU5DRV9FTlRSWV9DT0xMRUNURUQsIGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBpZiAoZW50cnkuZW50cnlUeXBlID09PSAnbGF5b3V0LXNoaWZ0JyAmJiAhZW50cnkuaGFkUmVjZW50SW5wdXQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVudHJ5LnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pLnVuc3Vic2NyaWJlO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0b3A6IHN0b3AsXG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2sgd2hldGhlciBgbGF5b3V0LXNoaWZ0YCBpcyBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIuXG4gKi9cbmZ1bmN0aW9uIGlzTGF5b3V0U2hpZnRTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRQZXJmb3JtYW5jZVRpbWluZ0V2ZW50KCdsYXlvdXQtc2hpZnQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYWNrVmlld01ldHJpY3MuanMubWFwIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGVsYXBzZWQsIGdlbmVyYXRlVVVJRCwgbW9uaXRvciwgT05FX01JTlVURSwgcmVsYXRpdmVOb3csIHRocm90dGxlLCB9IGZyb20gJ0BkYXRhZG9nL2Jyb3dzZXItY29yZSc7XG5pbXBvcnQgeyBMaWZlQ3ljbGVFdmVudFR5cGUgfSBmcm9tICcuLi8uLi9saWZlQ3ljbGUnO1xuaW1wb3J0IHsgVmlld0xvYWRpbmdUeXBlIH0gZnJvbSAnLi4vLi4vLi4vcmF3UnVtRXZlbnQudHlwZXMnO1xuaW1wb3J0IHsgdHJhY2tJbml0aWFsVmlld1RpbWluZ3MgfSBmcm9tICcuL3RyYWNrSW5pdGlhbFZpZXdUaW1pbmdzJztcbmltcG9ydCB7IHRyYWNrVmlld01ldHJpY3MgfSBmcm9tICcuL3RyYWNrVmlld01ldHJpY3MnO1xuaW1wb3J0IHsgdHJhY2tMb2NhdGlvbkNoYW5nZXMsIGFyZURpZmZlcmVudExvY2F0aW9uIH0gZnJvbSAnLi90cmFja0xvY2F0aW9uQ2hhbmdlcyc7XG5leHBvcnQgdmFyIFRIUk9UVExFX1ZJRVdfVVBEQVRFX1BFUklPRCA9IDMwMDA7XG5leHBvcnQgdmFyIFNFU1NJT05fS0VFUF9BTElWRV9JTlRFUlZBTCA9IDUgKiBPTkVfTUlOVVRFO1xuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrVmlld3MobG9jYXRpb24sIGxpZmVDeWNsZSkge1xuICAgIHZhciBpc1JlY29yZGluZyA9IGZhbHNlO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICB2YXIgX2EgPSB0cmFja0luaXRpYWxWaWV3KCksIHN0b3BJbml0aWFsVmlld1RyYWNraW5nID0gX2Euc3RvcCwgY3VycmVudFZpZXcgPSBfYS5pbml0aWFsVmlldztcbiAgICB2YXIgc3RvcExvY2F0aW9uQ2hhbmdlc1RyYWNraW5nID0gdHJhY2tMb2NhdGlvbkNoYW5nZXMoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoYXJlRGlmZmVyZW50TG9jYXRpb24oY3VycmVudFZpZXcuZ2V0TG9jYXRpb24oKSwgbG9jYXRpb24pKSB7XG4gICAgICAgICAgICAvLyBSZW5ldyB2aWV3IG9uIGxvY2F0aW9uIGNoYW5nZXNcbiAgICAgICAgICAgIGN1cnJlbnRWaWV3LmVuZCgpO1xuICAgICAgICAgICAgY3VycmVudFZpZXcudHJpZ2dlclVwZGF0ZSgpO1xuICAgICAgICAgICAgY3VycmVudFZpZXcgPSB0cmFja1ZpZXdDaGFuZ2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50Vmlldy51cGRhdGVMb2NhdGlvbihsb2NhdGlvbik7XG4gICAgICAgIGN1cnJlbnRWaWV3LnRyaWdnZXJVcGRhdGUoKTtcbiAgICB9KS5zdG9wO1xuICAgIC8vIFJlbmV3IHZpZXcgb24gc2Vzc2lvbiByZW5ld2FsXG4gICAgbGlmZUN5Y2xlLnN1YnNjcmliZShMaWZlQ3ljbGVFdmVudFR5cGUuU0VTU0lPTl9SRU5FV0VELCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGRvIG5vdCB0cmlnZ2VyIHZpZXcgdXBkYXRlIHRvIGF2b2lkIHdyb25nIGRhdGFcbiAgICAgICAgY3VycmVudFZpZXcuZW5kKCk7XG4gICAgICAgIGN1cnJlbnRWaWV3ID0gdHJhY2tWaWV3Q2hhbmdlKCk7XG4gICAgfSk7XG4gICAgLy8gRW5kIHRoZSBjdXJyZW50IHZpZXcgb24gcGFnZSB1bmxvYWRcbiAgICBsaWZlQ3ljbGUuc3Vic2NyaWJlKExpZmVDeWNsZUV2ZW50VHlwZS5CRUZPUkVfVU5MT0FELCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRWaWV3LmVuZCgpO1xuICAgICAgICBjdXJyZW50Vmlldy50cmlnZ2VyVXBkYXRlKCk7XG4gICAgfSk7XG4gICAgbGlmZUN5Y2xlLnN1YnNjcmliZShMaWZlQ3ljbGVFdmVudFR5cGUuUkVDT1JEX1NUQVJURUQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaXNSZWNvcmRpbmcgPSB0cnVlO1xuICAgICAgICBjdXJyZW50Vmlldy51cGRhdGVIYXNSZXBsYXkodHJ1ZSk7XG4gICAgfSk7XG4gICAgbGlmZUN5Y2xlLnN1YnNjcmliZShMaWZlQ3ljbGVFdmVudFR5cGUuUkVDT1JEX1NUT1BQRUQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaXNSZWNvcmRpbmcgPSBmYWxzZTtcbiAgICB9KTtcbiAgICAvLyBTZXNzaW9uIGtlZXAgYWxpdmVcbiAgICB2YXIga2VlcEFsaXZlSW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWwobW9uaXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRWaWV3LnRyaWdnZXJVcGRhdGUoKTtcbiAgICB9KSwgU0VTU0lPTl9LRUVQX0FMSVZFX0lOVEVSVkFMKTtcbiAgICBmdW5jdGlvbiB0cmFja0luaXRpYWxWaWV3KCkge1xuICAgICAgICB2YXIgc3RhcnRPcmlnaW4gPSAwO1xuICAgICAgICB2YXIgaW5pdGlhbFZpZXcgPSBuZXdWaWV3KGxpZmVDeWNsZSwgbG9jYXRpb24sIGlzUmVjb3JkaW5nLCBWaWV3TG9hZGluZ1R5cGUuSU5JVElBTF9MT0FELCBkb2N1bWVudC5yZWZlcnJlciwgc3RhcnRPcmlnaW4pO1xuICAgICAgICB2YXIgc3RvcCA9IHRyYWNrSW5pdGlhbFZpZXdUaW1pbmdzKGxpZmVDeWNsZSwgZnVuY3Rpb24gKHRpbWluZ3MpIHtcbiAgICAgICAgICAgIGluaXRpYWxWaWV3LnVwZGF0ZVRpbWluZ3ModGltaW5ncyk7XG4gICAgICAgICAgICBpbml0aWFsVmlldy5zY2hlZHVsZVVwZGF0ZSgpO1xuICAgICAgICB9KS5zdG9wO1xuICAgICAgICByZXR1cm4geyBpbml0aWFsVmlldzogaW5pdGlhbFZpZXcsIHN0b3A6IHN0b3AgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2tWaWV3Q2hhbmdlKCkge1xuICAgICAgICByZXR1cm4gbmV3VmlldyhsaWZlQ3ljbGUsIGxvY2F0aW9uLCBpc1JlY29yZGluZywgVmlld0xvYWRpbmdUeXBlLlJPVVRFX0NIQU5HRSwgY3VycmVudFZpZXcudXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkVGltaW5nOiBmdW5jdGlvbiAobmFtZSwgdGltZSkge1xuICAgICAgICAgICAgaWYgKHRpbWUgPT09IHZvaWQgMCkgeyB0aW1lID0gcmVsYXRpdmVOb3coKTsgfVxuICAgICAgICAgICAgY3VycmVudFZpZXcuYWRkVGltaW5nKG5hbWUsIHRpbWUpO1xuICAgICAgICAgICAgY3VycmVudFZpZXcudHJpZ2dlclVwZGF0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdG9wSW5pdGlhbFZpZXdUcmFja2luZygpO1xuICAgICAgICAgICAgc3RvcExvY2F0aW9uQ2hhbmdlc1RyYWNraW5nKCk7XG4gICAgICAgICAgICBjdXJyZW50Vmlldy5lbmQoKTtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoa2VlcEFsaXZlSW50ZXJ2YWwpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBuZXdWaWV3KGxpZmVDeWNsZSwgaW5pdGlhbExvY2F0aW9uLCBpbml0aWFsSGFzUmVwbGF5LCBsb2FkaW5nVHlwZSwgcmVmZXJyZXIsIHN0YXJ0VGltZSwgbmFtZSkge1xuICAgIGlmIChzdGFydFRpbWUgPT09IHZvaWQgMCkgeyBzdGFydFRpbWUgPSByZWxhdGl2ZU5vdygpOyB9XG4gICAgLy8gU2V0dXAgaW5pdGlhbCB2YWx1ZXNcbiAgICB2YXIgaWQgPSBnZW5lcmF0ZVVVSUQoKTtcbiAgICB2YXIgdGltaW5ncyA9IHt9O1xuICAgIHZhciBjdXN0b21UaW1pbmdzID0ge307XG4gICAgdmFyIGRvY3VtZW50VmVyc2lvbiA9IDA7XG4gICAgdmFyIGVuZFRpbWU7XG4gICAgdmFyIGxvY2F0aW9uID0gX19hc3NpZ24oe30sIGluaXRpYWxMb2NhdGlvbik7XG4gICAgdmFyIGhhc1JlcGxheSA9IGluaXRpYWxIYXNSZXBsYXk7XG4gICAgbGlmZUN5Y2xlLm5vdGlmeShMaWZlQ3ljbGVFdmVudFR5cGUuVklFV19DUkVBVEVELCB7IGlkOiBpZCwgc3RhcnRUaW1lOiBzdGFydFRpbWUsIGxvY2F0aW9uOiBsb2NhdGlvbiwgcmVmZXJyZXI6IHJlZmVycmVyIH0pO1xuICAgIC8vIFVwZGF0ZSB0aGUgdmlldyBldmVyeSB0aW1lIHRoZSBtZWFzdXJlcyBhcmUgY2hhbmdpbmdcbiAgICB2YXIgX2EgPSB0aHJvdHRsZShtb25pdG9yKHRyaWdnZXJWaWV3VXBkYXRlKSwgVEhST1RUTEVfVklFV19VUERBVEVfUEVSSU9ELCB7XG4gICAgICAgIGxlYWRpbmc6IGZhbHNlLFxuICAgIH0pLCBzY2hlZHVsZVZpZXdVcGRhdGUgPSBfYS50aHJvdHRsZWQsIGNhbmNlbFNjaGVkdWxlVmlld1VwZGF0ZSA9IF9hLmNhbmNlbDtcbiAgICB2YXIgX2IgPSB0cmFja1ZpZXdNZXRyaWNzKGxpZmVDeWNsZSwgc2NoZWR1bGVWaWV3VXBkYXRlLCBsb2FkaW5nVHlwZSksIHNldExvYWRFdmVudCA9IF9iLnNldExvYWRFdmVudCwgc3RvcFZpZXdNZXRyaWNzVHJhY2tpbmcgPSBfYi5zdG9wLCB2aWV3TWV0cmljcyA9IF9iLnZpZXdNZXRyaWNzO1xuICAgIC8vIEluaXRpYWwgdmlldyB1cGRhdGVcbiAgICB0cmlnZ2VyVmlld1VwZGF0ZSgpO1xuICAgIGZ1bmN0aW9uIHRyaWdnZXJWaWV3VXBkYXRlKCkge1xuICAgICAgICBkb2N1bWVudFZlcnNpb24gKz0gMTtcbiAgICAgICAgbGlmZUN5Y2xlLm5vdGlmeShMaWZlQ3ljbGVFdmVudFR5cGUuVklFV19VUERBVEVELCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdmlld01ldHJpY3MpLCB7IGN1c3RvbVRpbWluZ3M6IGN1c3RvbVRpbWluZ3MsXG4gICAgICAgICAgICBkb2N1bWVudFZlcnNpb246IGRvY3VtZW50VmVyc2lvbixcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBsb2FkaW5nVHlwZTogbG9hZGluZ1R5cGUsXG4gICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgICBoYXNSZXBsYXk6IGhhc1JlcGxheSxcbiAgICAgICAgICAgIHJlZmVycmVyOiByZWZlcnJlcixcbiAgICAgICAgICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lLFxuICAgICAgICAgICAgdGltaW5nczogdGltaW5ncywgZHVyYXRpb246IGVsYXBzZWQoc3RhcnRUaW1lLCBlbmRUaW1lID09PSB1bmRlZmluZWQgPyByZWxhdGl2ZU5vdygpIDogZW5kVGltZSksIGlzQWN0aXZlOiBlbmRUaW1lID09PSB1bmRlZmluZWQgfSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzY2hlZHVsZVVwZGF0ZTogc2NoZWR1bGVWaWV3VXBkYXRlLFxuICAgICAgICBlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVuZFRpbWUgPSByZWxhdGl2ZU5vdygpO1xuICAgICAgICAgICAgc3RvcFZpZXdNZXRyaWNzVHJhY2tpbmcoKTtcbiAgICAgICAgICAgIGxpZmVDeWNsZS5ub3RpZnkoTGlmZUN5Y2xlRXZlbnRUeXBlLlZJRVdfRU5ERUQpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRMb2NhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgICAgICB9LFxuICAgICAgICB0cmlnZ2VyVXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBjYW5jZWwgYW55IHBlbmRpbmcgdmlldyB1cGRhdGVzIGV4ZWN1dGlvblxuICAgICAgICAgICAgY2FuY2VsU2NoZWR1bGVWaWV3VXBkYXRlKCk7XG4gICAgICAgICAgICB0cmlnZ2VyVmlld1VwZGF0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVUaW1pbmdzOiBmdW5jdGlvbiAobmV3VGltaW5ncykge1xuICAgICAgICAgICAgdGltaW5ncyA9IG5ld1RpbWluZ3M7XG4gICAgICAgICAgICBpZiAobmV3VGltaW5ncy5sb2FkRXZlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNldExvYWRFdmVudChuZXdUaW1pbmdzLmxvYWRFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFkZFRpbWluZzogZnVuY3Rpb24gKG5hbWUsIGVuZFRpbWUpIHtcbiAgICAgICAgICAgIGN1c3RvbVRpbWluZ3Nbc2FuaXRpemVUaW1pbmcobmFtZSldID0gZWxhcHNlZChzdGFydFRpbWUsIGVuZFRpbWUpO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVMb2NhdGlvbjogZnVuY3Rpb24gKG5ld0xvY2F0aW9uKSB7XG4gICAgICAgICAgICBsb2NhdGlvbiA9IF9fYXNzaWduKHt9LCBuZXdMb2NhdGlvbik7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZUhhc1JlcGxheTogZnVuY3Rpb24gKG5ld0hhc1JlcGxheSkge1xuICAgICAgICAgICAgaGFzUmVwbGF5ID0gbmV3SGFzUmVwbGF5O1xuICAgICAgICB9LFxuICAgICAgICBnZXQgdXJsKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2F0aW9uLmhyZWY7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogVGltaW5nIG5hbWUgaXMgdXNlZCBhcyBmYWNldCBwYXRoIHRoYXQgbXVzdCBjb250YWluIG9ubHkgbGV0dGVycywgZGlnaXRzLCBvciB0aGUgY2hhcmFjdGVycyAtIF8gLiBAICRcbiAqL1xuZnVuY3Rpb24gc2FuaXRpemVUaW1pbmcobmFtZSkge1xuICAgIHZhciBzYW5pdGl6ZWQgPSBuYW1lLnJlcGxhY2UoL1teYS16QS1aMC05LV8uQCRdL2csICdfJyk7XG4gICAgaWYgKHNhbml0aXplZCAhPT0gbmFtZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHRpbWluZyBuYW1lOiBcIiArIG5hbWUgKyBcIiwgc2FuaXRpemVkIHRvOiBcIiArIHNhbml0aXplZCk7XG4gICAgfVxuICAgIHJldHVybiBzYW5pdGl6ZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFja1ZpZXdzLmpzLm1hcCIsImltcG9ydCB7IGdldFRpbWVTdGFtcCwgaXNFbXB0eU9iamVjdCwgbWFwVmFsdWVzLCB0b1NlcnZlckR1cmF0aW9uLCB9IGZyb20gJ0BkYXRhZG9nL2Jyb3dzZXItY29yZSc7XG5pbXBvcnQgeyBSdW1FdmVudFR5cGUgfSBmcm9tICcuLi8uLi8uLi9yYXdSdW1FdmVudC50eXBlcyc7XG5pbXBvcnQgeyBMaWZlQ3ljbGVFdmVudFR5cGUgfSBmcm9tICcuLi8uLi9saWZlQ3ljbGUnO1xuaW1wb3J0IHsgdHJhY2tWaWV3cyB9IGZyb20gJy4vdHJhY2tWaWV3cyc7XG5leHBvcnQgZnVuY3Rpb24gc3RhcnRWaWV3Q29sbGVjdGlvbihsaWZlQ3ljbGUsIGxvY2F0aW9uKSB7XG4gICAgbGlmZUN5Y2xlLnN1YnNjcmliZShMaWZlQ3ljbGVFdmVudFR5cGUuVklFV19VUERBVEVELCBmdW5jdGlvbiAodmlldykge1xuICAgICAgICByZXR1cm4gbGlmZUN5Y2xlLm5vdGlmeShMaWZlQ3ljbGVFdmVudFR5cGUuUkFXX1JVTV9FVkVOVF9DT0xMRUNURUQsIHByb2Nlc3NWaWV3VXBkYXRlKHZpZXcpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJhY2tWaWV3cyhsb2NhdGlvbiwgbGlmZUN5Y2xlKTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NWaWV3VXBkYXRlKHZpZXcpIHtcbiAgICB2YXIgdmlld0V2ZW50ID0ge1xuICAgICAgICBfZGQ6IHtcbiAgICAgICAgICAgIGRvY3VtZW50X3ZlcnNpb246IHZpZXcuZG9jdW1lbnRWZXJzaW9uLFxuICAgICAgICB9LFxuICAgICAgICBkYXRlOiBnZXRUaW1lU3RhbXAodmlldy5zdGFydFRpbWUpLFxuICAgICAgICB0eXBlOiBSdW1FdmVudFR5cGUuVklFVyxcbiAgICAgICAgdmlldzoge1xuICAgICAgICAgICAgYWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgY291bnQ6IHZpZXcuZXZlbnRDb3VudHMudXNlckFjdGlvbkNvdW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGN1bXVsYXRpdmVfbGF5b3V0X3NoaWZ0OiB2aWV3LmN1bXVsYXRpdmVMYXlvdXRTaGlmdCxcbiAgICAgICAgICAgIGRvbV9jb21wbGV0ZTogdG9TZXJ2ZXJEdXJhdGlvbih2aWV3LnRpbWluZ3MuZG9tQ29tcGxldGUpLFxuICAgICAgICAgICAgZG9tX2NvbnRlbnRfbG9hZGVkOiB0b1NlcnZlckR1cmF0aW9uKHZpZXcudGltaW5ncy5kb21Db250ZW50TG9hZGVkKSxcbiAgICAgICAgICAgIGRvbV9pbnRlcmFjdGl2ZTogdG9TZXJ2ZXJEdXJhdGlvbih2aWV3LnRpbWluZ3MuZG9tSW50ZXJhY3RpdmUpLFxuICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICBjb3VudDogdmlldy5ldmVudENvdW50cy5lcnJvckNvdW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpcnN0X2NvbnRlbnRmdWxfcGFpbnQ6IHRvU2VydmVyRHVyYXRpb24odmlldy50aW1pbmdzLmZpcnN0Q29udGVudGZ1bFBhaW50KSxcbiAgICAgICAgICAgIGZpcnN0X2lucHV0X2RlbGF5OiB0b1NlcnZlckR1cmF0aW9uKHZpZXcudGltaW5ncy5maXJzdElucHV0RGVsYXkpLFxuICAgICAgICAgICAgZmlyc3RfaW5wdXRfdGltZTogdG9TZXJ2ZXJEdXJhdGlvbih2aWV3LnRpbWluZ3MuZmlyc3RJbnB1dFRpbWUpLFxuICAgICAgICAgICAgaXNfYWN0aXZlOiB2aWV3LmlzQWN0aXZlLFxuICAgICAgICAgICAgbmFtZTogdmlldy5uYW1lLFxuICAgICAgICAgICAgbGFyZ2VzdF9jb250ZW50ZnVsX3BhaW50OiB0b1NlcnZlckR1cmF0aW9uKHZpZXcudGltaW5ncy5sYXJnZXN0Q29udGVudGZ1bFBhaW50KSxcbiAgICAgICAgICAgIGxvYWRfZXZlbnQ6IHRvU2VydmVyRHVyYXRpb24odmlldy50aW1pbmdzLmxvYWRFdmVudCksXG4gICAgICAgICAgICBsb2FkaW5nX3RpbWU6IHRvU2VydmVyRHVyYXRpb24odmlldy5sb2FkaW5nVGltZSksXG4gICAgICAgICAgICBsb2FkaW5nX3R5cGU6IHZpZXcubG9hZGluZ1R5cGUsXG4gICAgICAgICAgICBsb25nX3Rhc2s6IHtcbiAgICAgICAgICAgICAgICBjb3VudDogdmlldy5ldmVudENvdW50cy5sb25nVGFza0NvdW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc291cmNlOiB7XG4gICAgICAgICAgICAgICAgY291bnQ6IHZpZXcuZXZlbnRDb3VudHMucmVzb3VyY2VDb3VudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aW1lX3NwZW50OiB0b1NlcnZlckR1cmF0aW9uKHZpZXcuZHVyYXRpb24pLFxuICAgICAgICB9LFxuICAgICAgICBzZXNzaW9uOiB7XG4gICAgICAgICAgICBoYXNfcmVwbGF5OiB2aWV3Lmhhc1JlcGxheSB8fCB1bmRlZmluZWQsXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBpZiAoIWlzRW1wdHlPYmplY3Qodmlldy5jdXN0b21UaW1pbmdzKSkge1xuICAgICAgICB2aWV3RXZlbnQudmlldy5jdXN0b21fdGltaW5ncyA9IG1hcFZhbHVlcyh2aWV3LmN1c3RvbVRpbWluZ3MsIHRvU2VydmVyRHVyYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByYXdSdW1FdmVudDogdmlld0V2ZW50LFxuICAgICAgICBzdGFydFRpbWU6IHZpZXcuc3RhcnRUaW1lLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12aWV3Q29sbGVjdGlvbi5qcy5tYXAiLCJpbXBvcnQgeyBwZXJmb3JtRHJhdywgc3RhcnRTZXNzaW9uTWFuYWdlbWVudCB9IGZyb20gJ0BkYXRhZG9nL2Jyb3dzZXItY29yZSc7XG5pbXBvcnQgeyBMaWZlQ3ljbGVFdmVudFR5cGUgfSBmcm9tICcuL2xpZmVDeWNsZSc7XG5leHBvcnQgdmFyIFJVTV9TRVNTSU9OX0tFWSA9ICdydW0nO1xuZXhwb3J0IHZhciBSdW1UcmFja2luZ1R5cGU7XG4oZnVuY3Rpb24gKFJ1bVRyYWNraW5nVHlwZSkge1xuICAgIFJ1bVRyYWNraW5nVHlwZVtcIk5PVF9UUkFDS0VEXCJdID0gXCIwXCI7XG4gICAgUnVtVHJhY2tpbmdUeXBlW1wiVFJBQ0tFRF9XSVRIX1JFU09VUkNFU1wiXSA9IFwiMVwiO1xuICAgIFJ1bVRyYWNraW5nVHlwZVtcIlRSQUNLRURfV0lUSE9VVF9SRVNPVVJDRVNcIl0gPSBcIjJcIjtcbn0pKFJ1bVRyYWNraW5nVHlwZSB8fCAoUnVtVHJhY2tpbmdUeXBlID0ge30pKTtcbmV4cG9ydCBmdW5jdGlvbiBzdGFydFJ1bVNlc3Npb24oY29uZmlndXJhdGlvbiwgbGlmZUN5Y2xlKSB7XG4gICAgdmFyIHNlc3Npb24gPSBzdGFydFNlc3Npb25NYW5hZ2VtZW50KGNvbmZpZ3VyYXRpb24uY29va2llT3B0aW9ucywgUlVNX1NFU1NJT05fS0VZLCBmdW5jdGlvbiAocmF3VHJhY2tpbmdUeXBlKSB7XG4gICAgICAgIHJldHVybiBjb21wdXRlU2Vzc2lvblN0YXRlKGNvbmZpZ3VyYXRpb24sIHJhd1RyYWNraW5nVHlwZSk7XG4gICAgfSk7XG4gICAgc2Vzc2lvbi5yZW5ld09ic2VydmFibGUuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGlmZUN5Y2xlLm5vdGlmeShMaWZlQ3ljbGVFdmVudFR5cGUuU0VTU0lPTl9SRU5FV0VEKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXRJZDogc2Vzc2lvbi5nZXRJZCxcbiAgICAgICAgaXNUcmFja2VkOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXNzaW9uLmdldElkKCkgIT09IHVuZGVmaW5lZCAmJiBpc1RyYWNrZWQoc2Vzc2lvbi5nZXRUcmFja2luZ1R5cGUoKSk7IH0sXG4gICAgICAgIGlzVHJhY2tlZFdpdGhSZXNvdXJjZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlc3Npb24uZ2V0SWQoKSAhPT0gdW5kZWZpbmVkICYmIHNlc3Npb24uZ2V0VHJhY2tpbmdUeXBlKCkgPT09IFJ1bVRyYWNraW5nVHlwZS5UUkFDS0VEX1dJVEhfUkVTT1VSQ0VTO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBjb21wdXRlU2Vzc2lvblN0YXRlKGNvbmZpZ3VyYXRpb24sIHJhd1RyYWNraW5nVHlwZSkge1xuICAgIHZhciB0cmFja2luZ1R5cGU7XG4gICAgaWYgKGhhc1ZhbGlkUnVtU2Vzc2lvbihyYXdUcmFja2luZ1R5cGUpKSB7XG4gICAgICAgIHRyYWNraW5nVHlwZSA9IHJhd1RyYWNraW5nVHlwZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXBlcmZvcm1EcmF3KGNvbmZpZ3VyYXRpb24uc2FtcGxlUmF0ZSkpIHtcbiAgICAgICAgdHJhY2tpbmdUeXBlID0gUnVtVHJhY2tpbmdUeXBlLk5PVF9UUkFDS0VEO1xuICAgIH1cbiAgICBlbHNlIGlmICghcGVyZm9ybURyYXcoY29uZmlndXJhdGlvbi5yZXNvdXJjZVNhbXBsZVJhdGUpKSB7XG4gICAgICAgIHRyYWNraW5nVHlwZSA9IFJ1bVRyYWNraW5nVHlwZS5UUkFDS0VEX1dJVEhPVVRfUkVTT1VSQ0VTO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdHJhY2tpbmdUeXBlID0gUnVtVHJhY2tpbmdUeXBlLlRSQUNLRURfV0lUSF9SRVNPVVJDRVM7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHRyYWNraW5nVHlwZTogdHJhY2tpbmdUeXBlLFxuICAgICAgICBpc1RyYWNrZWQ6IGlzVHJhY2tlZCh0cmFja2luZ1R5cGUpLFxuICAgIH07XG59XG5mdW5jdGlvbiBoYXNWYWxpZFJ1bVNlc3Npb24odHJhY2tpbmdUeXBlKSB7XG4gICAgcmV0dXJuICh0cmFja2luZ1R5cGUgPT09IFJ1bVRyYWNraW5nVHlwZS5OT1RfVFJBQ0tFRCB8fFxuICAgICAgICB0cmFja2luZ1R5cGUgPT09IFJ1bVRyYWNraW5nVHlwZS5UUkFDS0VEX1dJVEhfUkVTT1VSQ0VTIHx8XG4gICAgICAgIHRyYWNraW5nVHlwZSA9PT0gUnVtVHJhY2tpbmdUeXBlLlRSQUNLRURfV0lUSE9VVF9SRVNPVVJDRVMpO1xufVxuZnVuY3Rpb24gaXNUcmFja2VkKHJ1bVNlc3Npb25UeXBlKSB7XG4gICAgcmV0dXJuIChydW1TZXNzaW9uVHlwZSA9PT0gUnVtVHJhY2tpbmdUeXBlLlRSQUNLRURfV0lUSF9SRVNPVVJDRVMgfHxcbiAgICAgICAgcnVtU2Vzc2lvblR5cGUgPT09IFJ1bVRyYWNraW5nVHlwZS5UUkFDS0VEX1dJVEhPVVRfUkVTT1VSQ0VTKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ1bVNlc3Npb24uanMubWFwIiwiaW1wb3J0IHsgZmluZENvbW1hU2VwYXJhdGVkVmFsdWUsIE9ORV9NSU5VVEUgfSBmcm9tICdAZGF0YWRvZy9icm93c2VyLWNvcmUnO1xuZXhwb3J0IHZhciBJTklUSUFMX0RPQ1VNRU5UX09VVERBVEVEX1RSQUNFX0lEX1RIUkVTSE9MRCA9IDIgKiBPTkVfTUlOVVRFO1xuZXhwb3J0IGZ1bmN0aW9uIGdldERvY3VtZW50VHJhY2VJZChkb2N1bWVudCkge1xuICAgIHZhciBkYXRhID0gZ2V0RG9jdW1lbnRUcmFjZURhdGFGcm9tTWV0YShkb2N1bWVudCkgfHwgZ2V0RG9jdW1lbnRUcmFjZURhdGFGcm9tQ29tbWVudChkb2N1bWVudCk7XG4gICAgaWYgKCFkYXRhIHx8IGRhdGEudHJhY2VUaW1lIDw9IERhdGUubm93KCkgLSBJTklUSUFMX0RPQ1VNRU5UX09VVERBVEVEX1RSQUNFX0lEX1RIUkVTSE9MRCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YS50cmFjZUlkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldERvY3VtZW50VHJhY2VEYXRhRnJvbU1ldGEoZG9jdW1lbnQpIHtcbiAgICB2YXIgdHJhY2VJZE1ldGEgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9ZGQtdHJhY2UtaWRdJyk7XG4gICAgdmFyIHRyYWNlVGltZU1ldGEgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9ZGQtdHJhY2UtdGltZV0nKTtcbiAgICByZXR1cm4gY3JlYXRlRG9jdW1lbnRUcmFjZURhdGEodHJhY2VJZE1ldGEgJiYgdHJhY2VJZE1ldGEuY29udGVudCwgdHJhY2VUaW1lTWV0YSAmJiB0cmFjZVRpbWVNZXRhLmNvbnRlbnQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldERvY3VtZW50VHJhY2VEYXRhRnJvbUNvbW1lbnQoZG9jdW1lbnQpIHtcbiAgICB2YXIgY29tbWVudCA9IGZpbmRUcmFjZUNvbW1lbnQoZG9jdW1lbnQpO1xuICAgIGlmICghY29tbWVudCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRG9jdW1lbnRUcmFjZURhdGEoZmluZENvbW1hU2VwYXJhdGVkVmFsdWUoY29tbWVudCwgJ3RyYWNlLWlkJyksIGZpbmRDb21tYVNlcGFyYXRlZFZhbHVlKGNvbW1lbnQsICd0cmFjZS10aW1lJykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50VHJhY2VEYXRhKHRyYWNlSWQsIHJhd1RyYWNlVGltZSkge1xuICAgIHZhciB0cmFjZVRpbWUgPSByYXdUcmFjZVRpbWUgJiYgTnVtYmVyKHJhd1RyYWNlVGltZSk7XG4gICAgaWYgKCF0cmFjZUlkIHx8ICF0cmFjZVRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHJhY2VJZDogdHJhY2VJZCxcbiAgICAgICAgdHJhY2VUaW1lOiB0cmFjZVRpbWUsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaW5kVHJhY2VDb21tZW50KGRvY3VtZW50KSB7XG4gICAgLy8gMS4gVHJ5IHRvIGZpbmQgdGhlIGNvbW1lbnQgYXMgYSBkaXJlY3QgY2hpbGQgb2YgdGhlIGRvY3VtZW50XG4gICAgLy8gTm90ZTogVFNMaW50IGFkdmlzZXMgdG8gdXNlIGEgJ2ZvciBvZicsIGJ1dCBUUyBkb2Vzbid0IGFsbG93IHRvIHVzZSAnZm9yIG9mJyBpZiB0aGUgaXRlcmF0ZWRcbiAgICAvLyB2YWx1ZSBpcyBub3QgYW4gYXJyYXkgb3Igc3RyaW5nIChoZXJlLCBhIE5vZGVMaXN0KS5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1mb3Itb2ZcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvY3VtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNvbW1lbnQgPSBnZXRUcmFjZUNvbW1lbnRGcm9tTm9kZShkb2N1bWVudC5jaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21tZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIDIuIElmIHRoZSBjb21tZW50IGlzIHBsYWNlZCBhZnRlciB0aGUgPC9odG1sPiB0YWcsIGJ1dCBoYXZlIHNvbWUgc3BhY2Ugb3IgbmV3IGxpbmVzIGJlZm9yZSBvclxuICAgIC8vIGFmdGVyLCB0aGUgRE9NIHBhcnNlciB3aWxsIGxpZnQgaXQgKGFuZCB0aGUgc3Vycm91bmRpbmcgdGV4dCkgYXQgdGhlIGVuZCBvZiB0aGUgPGJvZHk+IHRhZy5cbiAgICAvLyBUcnkgdG8gbG9vayBmb3IgdGhlIGNvbW1lbnQgYXQgdGhlIGVuZCBvZiB0aGUgPGJvZHk+IGJ5IGJ5IGl0ZXJhdGluZyBvdmVyIGl0cyBjaGlsZCBub2RlcyBpblxuICAgIC8vIHJldmVyc2Ugb3JkZXIsIHN0b3BwaW5nIGlmIHdlIGNvbWUgYWNyb3NzIGEgbm9uLXRleHQgbm9kZS5cbiAgICBpZiAoZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBmb3IgKHZhciBpID0gZG9jdW1lbnQuYm9keS5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmJvZHkuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICAgIHZhciBjb21tZW50ID0gZ2V0VHJhY2VDb21tZW50RnJvbU5vZGUobm9kZSk7XG4gICAgICAgICAgICBpZiAoY29tbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRUcmFjZUNvbW1lbnRGcm9tTm9kZShub2RlKSB7XG4gICAgaWYgKG5vZGUgJiYgaXNDb21tZW50Tm9kZShub2RlKSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSAvXlxccypEQVRBRE9HOyguKj8pXFxzKiQvLmV4ZWMobm9kZS5kYXRhKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hbMV07XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc0NvbW1lbnROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlTmFtZSA9PT0gJyNjb21tZW50Jztcbn1cbmZ1bmN0aW9uIGlzVGV4dE5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVOYW1lID09PSAnI3RleHQnO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0RG9jdW1lbnRUcmFjZUlkLmpzLm1hcCIsImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBnZXRPcmlnaW4sIG9iamVjdEVudHJpZXMgfSBmcm9tICdAZGF0YWRvZy9icm93c2VyLWNvcmUnO1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyVHJhY2luZ0lmQ2FuY2VsbGVkKGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dC5zdGF0dXMgPT09IDApIHtcbiAgICAgICAgY29udGV4dC50cmFjZUlkID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250ZXh0LnNwYW5JZCA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gc3RhcnRUcmFjZXIoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNsZWFyVHJhY2luZ0lmQ2FuY2VsbGVkOiBjbGVhclRyYWNpbmdJZkNhbmNlbGxlZCxcbiAgICAgICAgdHJhY2VGZXRjaDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmplY3RIZWFkZXJzSWZUcmFjaW5nQWxsb3dlZChjb25maWd1cmF0aW9uLCBjb250ZXh0LCBmdW5jdGlvbiAodHJhY2luZ0hlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0ICYmICEoKF9hID0gY29udGV4dC5pbml0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5pbnB1dCA9IG5ldyBSZXF1ZXN0KGNvbnRleHQuaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0cmFjaW5nSGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmlucHV0LmhlYWRlcnMuYXBwZW5kKGtleSwgdHJhY2luZ0hlYWRlcnNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5pbml0ID0gX19hc3NpZ24oe30sIGNvbnRleHQuaW5pdCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXJzXzEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuaW5pdC5oZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5pbml0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNfMS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbnRleHQuaW5pdC5oZWFkZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5pbml0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc18xLnB1c2goaGVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRleHQuaW5pdC5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhjb250ZXh0LmluaXQuaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc18xLnB1c2goW2tleSwgY29udGV4dC5pbml0LmhlYWRlcnNba2V5XV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5pbml0LmhlYWRlcnMgPSBoZWFkZXJzXzEuY29uY2F0KG9iamVjdEVudHJpZXModHJhY2luZ0hlYWRlcnMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhY2VYaHI6IGZ1bmN0aW9uIChjb250ZXh0LCB4aHIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmplY3RIZWFkZXJzSWZUcmFjaW5nQWxsb3dlZChjb25maWd1cmF0aW9uLCBjb250ZXh0LCBmdW5jdGlvbiAodHJhY2luZ0hlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0cmFjaW5nSGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB0cmFjaW5nSGVhZGVyc1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gaW5qZWN0SGVhZGVyc0lmVHJhY2luZ0FsbG93ZWQoY29uZmlndXJhdGlvbiwgY29udGV4dCwgaW5qZWN0KSB7XG4gICAgaWYgKCFpc1RyYWNpbmdTdXBwb3J0ZWQoKSB8fCAhaXNBbGxvd2VkVXJsKGNvbmZpZ3VyYXRpb24sIGNvbnRleHQudXJsKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQudHJhY2VJZCA9IG5ldyBUcmFjZUlkZW50aWZpZXIoKTtcbiAgICBjb250ZXh0LnNwYW5JZCA9IG5ldyBUcmFjZUlkZW50aWZpZXIoKTtcbiAgICBpbmplY3QobWFrZVRyYWNpbmdIZWFkZXJzKGNvbnRleHQudHJhY2VJZCwgY29udGV4dC5zcGFuSWQpKTtcbn1cbmZ1bmN0aW9uIGlzQWxsb3dlZFVybChjb25maWd1cmF0aW9uLCByZXF1ZXN0VXJsKSB7XG4gICAgdmFyIHJlcXVlc3RPcmlnaW4gPSBnZXRPcmlnaW4ocmVxdWVzdFVybCk7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGNvbmZpZ3VyYXRpb24uYWxsb3dlZFRyYWNpbmdPcmlnaW5zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgYWxsb3dlZE9yaWdpbiA9IF9hW19pXTtcbiAgICAgICAgaWYgKHJlcXVlc3RPcmlnaW4gPT09IGFsbG93ZWRPcmlnaW4gfHwgKGFsbG93ZWRPcmlnaW4gaW5zdGFuY2VvZiBSZWdFeHAgJiYgYWxsb3dlZE9yaWdpbi50ZXN0KHJlcXVlc3RPcmlnaW4pKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzVHJhY2luZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gZ2V0Q3J5cHRvKCkgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldENyeXB0bygpIHtcbiAgICByZXR1cm4gd2luZG93LmNyeXB0byB8fCB3aW5kb3cubXNDcnlwdG87XG59XG5mdW5jdGlvbiBtYWtlVHJhY2luZ0hlYWRlcnModHJhY2VJZCwgc3BhbklkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgJ3gtZGF0YWRvZy1vcmlnaW4nOiAncnVtJyxcbiAgICAgICAgJ3gtZGF0YWRvZy1wYXJlbnQtaWQnOiBzcGFuSWQudG9EZWNpbWFsU3RyaW5nKCksXG4gICAgICAgICd4LWRhdGFkb2ctc2FtcGxlZCc6ICcxJyxcbiAgICAgICAgJ3gtZGF0YWRvZy1zYW1wbGluZy1wcmlvcml0eSc6ICcxJyxcbiAgICAgICAgJ3gtZGF0YWRvZy10cmFjZS1pZCc6IHRyYWNlSWQudG9EZWNpbWFsU3RyaW5nKCksXG4gICAgfTtcbn1cbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbnZhciBUcmFjZUlkZW50aWZpZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJhY2VJZGVudGlmaWVyKCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgICAgICBnZXRDcnlwdG8oKS5nZXRSYW5kb21WYWx1ZXModGhpcy5idWZmZXIpO1xuICAgICAgICB0aGlzLmJ1ZmZlclswXSA9IHRoaXMuYnVmZmVyWzBdICYgMHg3ZjsgLy8gZm9yY2UgNjMtYml0XG4gICAgfVxuICAgIFRyYWNlSWRlbnRpZmllci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAocmFkaXgpIHtcbiAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLnJlYWRJbnQzMigwKTtcbiAgICAgICAgdmFyIGxvdyA9IHRoaXMucmVhZEludDMyKDQpO1xuICAgICAgICB2YXIgc3RyID0gJyc7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICB2YXIgbW9kID0gKGhpZ2ggJSByYWRpeCkgKiA0Mjk0OTY3Mjk2ICsgbG93O1xuICAgICAgICAgICAgaGlnaCA9IE1hdGguZmxvb3IoaGlnaCAvIHJhZGl4KTtcbiAgICAgICAgICAgIGxvdyA9IE1hdGguZmxvb3IobW9kIC8gcmFkaXgpO1xuICAgICAgICAgICAgc3RyID0gKG1vZCAlIHJhZGl4KS50b1N0cmluZyhyYWRpeCkgKyBzdHI7XG4gICAgICAgICAgICBpZiAoIWhpZ2ggJiYgIWxvdykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb3JtYXQgdXNlZCBldmVyeXdoZXJlIGV4Y2VwdCB0aGUgdHJhY2UgaW50YWtlXG4gICAgICovXG4gICAgVHJhY2VJZGVudGlmaWVyLnByb3RvdHlwZS50b0RlY2ltYWxTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKDEwKTtcbiAgICB9O1xuICAgIFRyYWNlSWRlbnRpZmllci5wcm90b3R5cGUucmVhZEludDMyID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYnVmZmVyW29mZnNldF0gKiAxNjc3NzIxNiArXG4gICAgICAgICAgICAodGhpcy5idWZmZXJbb2Zmc2V0ICsgMV0gPDwgMTYpICtcbiAgICAgICAgICAgICh0aGlzLmJ1ZmZlcltvZmZzZXQgKyAyXSA8PCA4KSArXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltvZmZzZXQgKyAzXSk7XG4gICAgfTtcbiAgICByZXR1cm4gVHJhY2VJZGVudGlmaWVyO1xufSgpKTtcbmV4cG9ydCB7IFRyYWNlSWRlbnRpZmllciB9O1xuLyogZXNsaW50LWVuYWJsZSBuby1iaXR3aXNlICovXG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFjZXIuanMubWFwIiwiaW1wb3J0IHsgbm9vcCB9IGZyb20gJ0BkYXRhZG9nL2Jyb3dzZXItY29yZSc7XG5pbXBvcnQgeyBSdW1FdmVudFR5cGUgfSBmcm9tICcuLi9yYXdSdW1FdmVudC50eXBlcyc7XG5pbXBvcnQgeyBMaWZlQ3ljbGVFdmVudFR5cGUgfSBmcm9tICcuL2xpZmVDeWNsZSc7XG5leHBvcnQgZnVuY3Rpb24gdHJhY2tFdmVudENvdW50cyhsaWZlQ3ljbGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGNhbGxiYWNrID09PSB2b2lkIDApIHsgY2FsbGJhY2sgPSBub29wOyB9XG4gICAgdmFyIGV2ZW50Q291bnRzID0ge1xuICAgICAgICBlcnJvckNvdW50OiAwLFxuICAgICAgICBsb25nVGFza0NvdW50OiAwLFxuICAgICAgICByZXNvdXJjZUNvdW50OiAwLFxuICAgICAgICB1c2VyQWN0aW9uQ291bnQ6IDAsXG4gICAgfTtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gbGlmZUN5Y2xlLnN1YnNjcmliZShMaWZlQ3ljbGVFdmVudFR5cGUuUlVNX0VWRU5UX0NPTExFQ1RFRCwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB0eXBlID0gX2EudHlwZTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFJ1bUV2ZW50VHlwZS5FUlJPUjpcbiAgICAgICAgICAgICAgICBldmVudENvdW50cy5lcnJvckNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXZlbnRDb3VudHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBSdW1FdmVudFR5cGUuQUNUSU9OOlxuICAgICAgICAgICAgICAgIGV2ZW50Q291bnRzLnVzZXJBY3Rpb25Db3VudCArPSAxO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGV2ZW50Q291bnRzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUnVtRXZlbnRUeXBlLkxPTkdfVEFTSzpcbiAgICAgICAgICAgICAgICBldmVudENvdW50cy5sb25nVGFza0NvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXZlbnRDb3VudHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBSdW1FdmVudFR5cGUuUkVTT1VSQ0U6XG4gICAgICAgICAgICAgICAgZXZlbnRDb3VudHMucmVzb3VyY2VDb3VudCArPSAxO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGV2ZW50Q291bnRzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9LFxuICAgICAgICBldmVudENvdW50czogZXZlbnRDb3VudHMsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYWNrRXZlbnRDb3VudHMuanMubWFwIiwiaW1wb3J0IHsgbW9uaXRvciwgT2JzZXJ2YWJsZSwgcmVsYXRpdmVOb3cgfSBmcm9tICdAZGF0YWRvZy9icm93c2VyLWNvcmUnO1xuaW1wb3J0IHsgTGlmZUN5Y2xlRXZlbnRUeXBlIH0gZnJvbSAnLi9saWZlQ3ljbGUnO1xuLy8gRGVsYXkgdG8gd2FpdCBmb3IgYSBwYWdlIGFjdGl2aXR5IHRvIHZhbGlkYXRlIHRoZSB0cmFja2luZyBwcm9jZXNzXG5leHBvcnQgdmFyIFBBR0VfQUNUSVZJVFlfVkFMSURBVElPTl9ERUxBWSA9IDEwMDtcbi8vIERlbGF5IHRvIHdhaXQgYWZ0ZXIgYSBwYWdlIGFjdGl2aXR5IHRvIGVuZCB0aGUgdHJhY2tpbmcgcHJvY2Vzc1xuZXhwb3J0IHZhciBQQUdFX0FDVElWSVRZX0VORF9ERUxBWSA9IDEwMDtcbi8vIE1heGltdW0gZHVyYXRpb24gb2YgdGhlIHRyYWNraW5nIHByb2Nlc3NcbmV4cG9ydCB2YXIgUEFHRV9BQ1RJVklUWV9NQVhfRFVSQVRJT04gPSAxMDAwMDtcbmV4cG9ydCBmdW5jdGlvbiB3YWl0SWRsZVBhZ2VBY3Rpdml0eShsaWZlQ3ljbGUsIGNvbXBsZXRpb25DYWxsYmFjaykge1xuICAgIHZhciBfYSA9IHRyYWNrUGFnZUFjdGl2aXRpZXMobGlmZUN5Y2xlKSwgcGFnZUFjdGl2aXRpZXNPYnNlcnZhYmxlID0gX2Eub2JzZXJ2YWJsZSwgc3RvcFBhZ2VBY3Rpdml0aWVzVHJhY2tpbmcgPSBfYS5zdG9wO1xuICAgIHZhciBzdG9wV2FpdFBhZ2VBY3Rpdml0aWVzQ29tcGxldGlvbiA9IHdhaXRQYWdlQWN0aXZpdGllc0NvbXBsZXRpb24ocGFnZUFjdGl2aXRpZXNPYnNlcnZhYmxlLCBzdG9wUGFnZUFjdGl2aXRpZXNUcmFja2luZywgY29tcGxldGlvbkNhbGxiYWNrKS5zdG9wO1xuICAgIHZhciBzdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzdG9wV2FpdFBhZ2VBY3Rpdml0aWVzQ29tcGxldGlvbigpO1xuICAgICAgICBzdG9wUGFnZUFjdGl2aXRpZXNUcmFja2luZygpO1xuICAgIH07XG4gICAgcmV0dXJuIHsgc3RvcDogc3RvcCB9O1xufVxuLy8gQXV0b21hdGljIGFjdGlvbiBjb2xsZWN0aW9uIGxpZmVjeWNsZSBvdmVydmlldzpcbi8vICAgICAgICAgICAgICAgICAgICAgIChTdGFydCBuZXcgdHJhY2tQYWdlQWN0aXZpdGllcylcbi8vICAgICAgICAgICAgICAuLS0tLS0tLS0tLS0tLS0tLS0tLSctLS0tLS0tLS0tLS0tLS0tLS0tLS5cbi8vICAgICAgICAgICAgICB2ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZcbi8vICAgICBbV2FpdCBmb3IgYSBwYWdlIGFjdGl2aXR5IF0gICAgICAgICAgW1dhaXQgZm9yIGEgbWF4aW11bSBkdXJhdGlvbl1cbi8vICAgICBbdGltZW91dDogVkFMSURBVElPTl9ERUxBWV0gICAgICAgICAgWyAgdGltZW91dDogTUFYX0RVUkFUSU9OICAgIF1cbi8vICAgICAgICAgIC8gICAgICAgICAgICAgICAgICBcXCAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbi8vICAgICAgICAgdiAgICAgICAgICAgICAgICAgICAgdiAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuLy8gIFtObyBwYWdlIGFjdGl2aXR5XSAgIFtQYWdlIGFjdGl2aXR5XSAgICAgICAgICAgICAgICAgICB8XG4vLyAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgfCwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLiAgIHxcbi8vICAgICAgICAgdiAgICAgICAgICAgICAgICAgICB2ICAgICAgICAgICAgICAgICAgICAgICB8ICAgfFxuLy8gICAgIChEaXNjYXJkKSAgICAgW1dhaXQgZm9yIGEgcGFnZSBhY3Rpdml0eV0gICAgICAgIHwgICB8XG4vLyAgICAgICAgICAgICAgICAgICBbICAgdGltZW91dDogRU5EX0RFTEFZICAgXSAgICAgICAgfCAgIHxcbi8vICAgICAgICAgICAgICAgICAgICAgICAvICAgICAgICAgICAgICAgIFxcICAgICAgICAgICAgfCAgIHxcbi8vICAgICAgICAgICAgICAgICAgICAgIHYgICAgICAgICAgICAgICAgICB2ICAgICAgICAgICB8ICAgfFxuLy8gICAgICAgICAgICAgW05vIHBhZ2UgYWN0aXZpdHldICAgIFtQYWdlIGFjdGl2aXR5XSAgIHwgICB8XG4vLyAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgfCAgIHxcbi8vICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICctLS0tLS0tLS0tLS0nICAgfFxuLy8gICAgICAgICAgICAgICAgICAgICAgJy0tLS0tLS0tLS0tLiAsLS0tLS0tLS0tLS0tLS0tLS0tLS0nXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoRW5kKVxuLy9cbi8vIE5vdGU6IGJlY2F1c2UgTUFYX0RVUkFUSU9OID4gVkFMSURBVElPTl9ERUxBWSwgd2UgYXJlIHN1cmUgdGhhdCBpZiB0aGUgcHJvY2VzcyBpcyBzdGlsbCBhbGl2ZVxuLy8gYWZ0ZXIgTUFYX0RVUkFUSU9OLCBpdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG5leHBvcnQgZnVuY3Rpb24gdHJhY2tQYWdlQWN0aXZpdGllcyhsaWZlQ3ljbGUpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XG4gICAgdmFyIHN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICB2YXIgZmlyc3RSZXF1ZXN0SW5kZXg7XG4gICAgdmFyIHBlbmRpbmdSZXF1ZXN0c0NvdW50ID0gMDtcbiAgICBzdWJzY3JpcHRpb25zLnB1c2gobGlmZUN5Y2xlLnN1YnNjcmliZShMaWZlQ3ljbGVFdmVudFR5cGUuRE9NX01VVEFURUQsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5vdGlmeVBhZ2VBY3Rpdml0eSgpOyB9KSk7XG4gICAgc3Vic2NyaXB0aW9ucy5wdXNoKGxpZmVDeWNsZS5zdWJzY3JpYmUoTGlmZUN5Y2xlRXZlbnRUeXBlLlBFUkZPUk1BTkNFX0VOVFJZX0NPTExFQ1RFRCwgZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIGlmIChlbnRyeS5lbnRyeVR5cGUgIT09ICdyZXNvdXJjZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub3RpZnlQYWdlQWN0aXZpdHkoKTtcbiAgICB9KSk7XG4gICAgc3Vic2NyaXB0aW9ucy5wdXNoKGxpZmVDeWNsZS5zdWJzY3JpYmUoTGlmZUN5Y2xlRXZlbnRUeXBlLlJFUVVFU1RfU1RBUlRFRCwgZnVuY3Rpb24gKHN0YXJ0RXZlbnQpIHtcbiAgICAgICAgaWYgKGZpcnN0UmVxdWVzdEluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZpcnN0UmVxdWVzdEluZGV4ID0gc3RhcnRFdmVudC5yZXF1ZXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcGVuZGluZ1JlcXVlc3RzQ291bnQgKz0gMTtcbiAgICAgICAgbm90aWZ5UGFnZUFjdGl2aXR5KCk7XG4gICAgfSkpO1xuICAgIHN1YnNjcmlwdGlvbnMucHVzaChsaWZlQ3ljbGUuc3Vic2NyaWJlKExpZmVDeWNsZUV2ZW50VHlwZS5SRVFVRVNUX0NPTVBMRVRFRCwgZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3Qgc3RhcnRlZCBiZWZvcmUgdGhlIHRyYWNraW5nIHN0YXJ0LCBpZ25vcmUgaXRcbiAgICAgICAgaWYgKGZpcnN0UmVxdWVzdEluZGV4ID09PSB1bmRlZmluZWQgfHwgcmVxdWVzdC5yZXF1ZXN0SW5kZXggPCBmaXJzdFJlcXVlc3RJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0c0NvdW50IC09IDE7XG4gICAgICAgIG5vdGlmeVBhZ2VBY3Rpdml0eSgpO1xuICAgIH0pKTtcbiAgICBmdW5jdGlvbiBub3RpZnlQYWdlQWN0aXZpdHkoKSB7XG4gICAgICAgIG9ic2VydmFibGUubm90aWZ5KHsgaXNCdXN5OiBwZW5kaW5nUmVxdWVzdHNDb3VudCA+IDAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG9ic2VydmFibGU6IG9ic2VydmFibGUsXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocykgeyByZXR1cm4gcy51bnN1YnNjcmliZSgpOyB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdhaXRQYWdlQWN0aXZpdGllc0NvbXBsZXRpb24ocGFnZUFjdGl2aXRpZXNPYnNlcnZhYmxlLCBzdG9wUGFnZUFjdGl2aXRpZXNUcmFja2luZywgY29tcGxldGlvbkNhbGxiYWNrKSB7XG4gICAgdmFyIGlkbGVUaW1lb3V0SWQ7XG4gICAgdmFyIGhhc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgIHZhciB2YWxpZGF0aW9uVGltZW91dElkID0gc2V0VGltZW91dChtb25pdG9yKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBsZXRlKGZhbHNlLCAwKTsgfSksIFBBR0VfQUNUSVZJVFlfVkFMSURBVElPTl9ERUxBWSk7XG4gICAgdmFyIG1heER1cmF0aW9uVGltZW91dElkID0gc2V0VGltZW91dChtb25pdG9yKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBsZXRlKHRydWUsIHJlbGF0aXZlTm93KCkpOyB9KSwgUEFHRV9BQ1RJVklUWV9NQVhfRFVSQVRJT04pO1xuICAgIHBhZ2VBY3Rpdml0aWVzT2JzZXJ2YWJsZS5zdWJzY3JpYmUoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBpc0J1c3kgPSBfYS5pc0J1c3k7XG4gICAgICAgIGNsZWFyVGltZW91dCh2YWxpZGF0aW9uVGltZW91dElkKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGlkbGVUaW1lb3V0SWQpO1xuICAgICAgICB2YXIgbGFzdENoYW5nZVRpbWUgPSByZWxhdGl2ZU5vdygpO1xuICAgICAgICBpZiAoIWlzQnVzeSkge1xuICAgICAgICAgICAgaWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQobW9uaXRvcihmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wbGV0ZSh0cnVlLCBsYXN0Q2hhbmdlVGltZSk7IH0pLCBQQUdFX0FDVElWSVRZX0VORF9ERUxBWSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHZhbGlkYXRpb25UaW1lb3V0SWQpO1xuICAgICAgICBjbGVhclRpbWVvdXQoaWRsZVRpbWVvdXRJZCk7XG4gICAgICAgIGNsZWFyVGltZW91dChtYXhEdXJhdGlvblRpbWVvdXRJZCk7XG4gICAgICAgIHN0b3BQYWdlQWN0aXZpdGllc1RyYWNraW5nKCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjb21wbGV0ZShoYWRBY3Rpdml0eSwgZW5kVGltZSkge1xuICAgICAgICBpZiAoaGFzQ29tcGxldGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RvcCgpO1xuICAgICAgICBjb21wbGV0aW9uQ2FsbGJhY2soaGFkQWN0aXZpdHksIGVuZFRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4geyBzdG9wOiBzdG9wIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFja1BhZ2VBY3Rpdml0aWVzLmpzLm1hcCIsImV4cG9ydCB7IG1ha2VSdW1QdWJsaWNBcGkgfSBmcm9tICcuL2Jvb3QvcnVtUHVibGljQXBpJztcbmV4cG9ydCB7IHN0YXJ0UnVtIH0gZnJvbSAnLi9ib290L3J1bSc7XG5leHBvcnQgeyBMaWZlQ3ljbGUsIExpZmVDeWNsZUV2ZW50VHlwZSB9IGZyb20gJy4vZG9tYWluL2xpZmVDeWNsZSc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgdmFyIFJ1bUV2ZW50VHlwZTtcbihmdW5jdGlvbiAoUnVtRXZlbnRUeXBlKSB7XG4gICAgUnVtRXZlbnRUeXBlW1wiQUNUSU9OXCJdID0gXCJhY3Rpb25cIjtcbiAgICBSdW1FdmVudFR5cGVbXCJFUlJPUlwiXSA9IFwiZXJyb3JcIjtcbiAgICBSdW1FdmVudFR5cGVbXCJMT05HX1RBU0tcIl0gPSBcImxvbmdfdGFza1wiO1xuICAgIFJ1bUV2ZW50VHlwZVtcIlZJRVdcIl0gPSBcInZpZXdcIjtcbiAgICBSdW1FdmVudFR5cGVbXCJSRVNPVVJDRVwiXSA9IFwicmVzb3VyY2VcIjtcbn0pKFJ1bUV2ZW50VHlwZSB8fCAoUnVtRXZlbnRUeXBlID0ge30pKTtcbmV4cG9ydCB2YXIgVmlld0xvYWRpbmdUeXBlO1xuKGZ1bmN0aW9uIChWaWV3TG9hZGluZ1R5cGUpIHtcbiAgICBWaWV3TG9hZGluZ1R5cGVbXCJJTklUSUFMX0xPQURcIl0gPSBcImluaXRpYWxfbG9hZFwiO1xuICAgIFZpZXdMb2FkaW5nVHlwZVtcIlJPVVRFX0NIQU5HRVwiXSA9IFwicm91dGVfY2hhbmdlXCI7XG59KShWaWV3TG9hZGluZ1R5cGUgfHwgKFZpZXdMb2FkaW5nVHlwZSA9IHt9KSk7XG5leHBvcnQgdmFyIEFjdGlvblR5cGU7XG4oZnVuY3Rpb24gKEFjdGlvblR5cGUpIHtcbiAgICBBY3Rpb25UeXBlW1wiQ0xJQ0tcIl0gPSBcImNsaWNrXCI7XG4gICAgQWN0aW9uVHlwZVtcIkNVU1RPTVwiXSA9IFwiY3VzdG9tXCI7XG59KShBY3Rpb25UeXBlIHx8IChBY3Rpb25UeXBlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhd1J1bUV2ZW50LnR5cGVzLmpzLm1hcCIsImltcG9ydCB7IEJhdGNoLCBjb21iaW5lLCBIdHRwUmVxdWVzdCB9IGZyb20gJ0BkYXRhZG9nL2Jyb3dzZXItY29yZSc7XG5pbXBvcnQgeyBMaWZlQ3ljbGVFdmVudFR5cGUgfSBmcm9tICcuLi9kb21haW4vbGlmZUN5Y2xlJztcbmltcG9ydCB7IFJ1bUV2ZW50VHlwZSB9IGZyb20gJy4uL3Jhd1J1bUV2ZW50LnR5cGVzJztcbmV4cG9ydCBmdW5jdGlvbiBzdGFydFJ1bUJhdGNoKGNvbmZpZ3VyYXRpb24sIGxpZmVDeWNsZSkge1xuICAgIHZhciBiYXRjaCA9IG1ha2VSdW1CYXRjaChjb25maWd1cmF0aW9uLCBsaWZlQ3ljbGUpO1xuICAgIGxpZmVDeWNsZS5zdWJzY3JpYmUoTGlmZUN5Y2xlRXZlbnRUeXBlLlJVTV9FVkVOVF9DT0xMRUNURUQsIGZ1bmN0aW9uIChzZXJ2ZXJSdW1FdmVudCkge1xuICAgICAgICBpZiAoc2VydmVyUnVtRXZlbnQudHlwZSA9PT0gUnVtRXZlbnRUeXBlLlZJRVcpIHtcbiAgICAgICAgICAgIGJhdGNoLnVwc2VydChzZXJ2ZXJSdW1FdmVudCwgc2VydmVyUnVtRXZlbnQudmlldy5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBiYXRjaC5hZGQoc2VydmVyUnVtRXZlbnQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYmF0Y2guc3RvcCgpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBtYWtlUnVtQmF0Y2goY29uZmlndXJhdGlvbiwgbGlmZUN5Y2xlKSB7XG4gICAgdmFyIHByaW1hcnlCYXRjaCA9IGNyZWF0ZVJ1bUJhdGNoKGNvbmZpZ3VyYXRpb24ucnVtRW5kcG9pbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxpZmVDeWNsZS5ub3RpZnkoTGlmZUN5Y2xlRXZlbnRUeXBlLkJFRk9SRV9VTkxPQUQpO1xuICAgIH0pO1xuICAgIHZhciByZXBsaWNhQmF0Y2g7XG4gICAgdmFyIHJlcGxpY2EgPSBjb25maWd1cmF0aW9uLnJlcGxpY2E7XG4gICAgaWYgKHJlcGxpY2EgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXBsaWNhQmF0Y2ggPSBjcmVhdGVSdW1CYXRjaChyZXBsaWNhLnJ1bUVuZHBvaW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUnVtQmF0Y2goZW5kcG9pbnRVcmwsIHVubG9hZENhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmF0Y2gobmV3IEh0dHBSZXF1ZXN0KGVuZHBvaW50VXJsLCBjb25maWd1cmF0aW9uLmJhdGNoQnl0ZXNMaW1pdCwgdHJ1ZSksIGNvbmZpZ3VyYXRpb24ubWF4QmF0Y2hTaXplLCBjb25maWd1cmF0aW9uLmJhdGNoQnl0ZXNMaW1pdCwgY29uZmlndXJhdGlvbi5tYXhNZXNzYWdlU2l6ZSwgY29uZmlndXJhdGlvbi5mbHVzaFRpbWVvdXQsIHVubG9hZENhbGxiYWNrKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2l0aFJlcGxpY2FBcHBsaWNhdGlvbklkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmUobWVzc2FnZSwgeyBhcHBsaWNhdGlvbjogeyBpZDogcmVwbGljYS5hcHBsaWNhdGlvbklkIH0gfSk7XG4gICAgfVxuICAgIHZhciBzdG9wcGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkOiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmltYXJ5QmF0Y2guYWRkKG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKHJlcGxpY2FCYXRjaCkge1xuICAgICAgICAgICAgICAgIHJlcGxpY2FCYXRjaC5hZGQod2l0aFJlcGxpY2FBcHBsaWNhdGlvbklkKG1lc3NhZ2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHVwc2VydDogZnVuY3Rpb24gKG1lc3NhZ2UsIGtleSkge1xuICAgICAgICAgICAgaWYgKHN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmltYXJ5QmF0Y2gudXBzZXJ0KG1lc3NhZ2UsIGtleSk7XG4gICAgICAgICAgICBpZiAocmVwbGljYUJhdGNoKSB7XG4gICAgICAgICAgICAgICAgcmVwbGljYUJhdGNoLnVwc2VydCh3aXRoUmVwbGljYUFwcGxpY2F0aW9uSWQobWVzc2FnZSksIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhdGNoLmpzLm1hcCIsImltcG9ydCB7IGRlZmluZUdsb2JhbCwgZ2V0R2xvYmFsT2JqZWN0IH0gZnJvbSAnQGRhdGFkb2cvYnJvd3Nlci1jb3JlJztcbmltcG9ydCB7IG1ha2VSdW1QdWJsaWNBcGksIHN0YXJ0UnVtIH0gZnJvbSAnQGRhdGFkb2cvYnJvd3Nlci1ydW0tY29yZSc7XG5leHBvcnQgdmFyIGRhdGFkb2dSdW0gPSBtYWtlUnVtUHVibGljQXBpKHN0YXJ0UnVtKTtcbmRlZmluZUdsb2JhbChnZXRHbG9iYWxPYmplY3QoKSwgJ0REX1JVTScsIGRhdGFkb2dSdW0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnVtLmVudHJ5LmpzLm1hcCIsIi8vIEtlZXAgdGhlIGZvbGxvd2luZyBpbiBzeW5jIHdpdGggcGFja2FnZXMvcnVtLXJlY29yZGVyL3NyYy9pbmRleC50c1xuZXhwb3J0IHsgZGF0YWRvZ1J1bSB9IGZyb20gJy4vYm9vdC9ydW0uZW50cnknO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7IC8vIFRPRE86IFdlIGRvbid0IHVzZSBBc3luY01vZGUgb3IgQ29uY3VycmVudE1vZGUgYW55bW9yZS4gVGhleSB3ZXJlIHRlbXBvcmFyeVxuLy8gKHVuc3RhYmxlKSBBUElzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQuIENhbiB3ZSByZW1vdmUgdGhlIHN5bWJvbHM/XG5cbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb25jdXJyZW50X21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSA6IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKSA6IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0JykgOiAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubWVtbycpIDogMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKSA6IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYmxvY2snKSA6IDB4ZWFkOTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnVuZGFtZW50YWwnKSA6IDB4ZWFkNTtcbnZhciBSRUFDVF9SRVNQT05ERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnJlc3BvbmRlcicpIDogMHhlYWQ2O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zY29wZScpIDogMHhlYWQ3O1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9SRVNQT05ERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9TQ09QRV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUpO1xufVxuXG5mdW5jdGlvbiB0eXBlT2Yob2JqZWN0KSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICB2YXIgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG5cbiAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgdmFyIHR5cGUgPSBvYmplY3QudHlwZTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0FTWU5DX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciAkJHR5cGVvZlR5cGUgPSB0eXBlICYmIHR5cGUuJCR0eXBlb2Y7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn0gLy8gQXN5bmNNb2RlIGlzIGRlcHJlY2F0ZWQgYWxvbmcgd2l0aCBpc0FzeW5jTW9kZVxuXG52YXIgQXN5bmNNb2RlID0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xudmFyIENvbmN1cnJlbnRNb2RlID0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG52YXIgQ29udGV4dENvbnN1bWVyID0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xudmFyIENvbnRleHRQcm92aWRlciA9IFJFQUNUX1BST1ZJREVSX1RZUEU7XG52YXIgRWxlbWVudCA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBGcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG52YXIgTGF6eSA9IFJFQUNUX0xBWllfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xudmFyIFBvcnRhbCA9IFJFQUNUX1BPUlRBTF9UWVBFO1xudmFyIFByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbnZhciBTdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbnZhciBTdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSBmYWxzZTsgLy8gQXN5bmNNb2RlIHNob3VsZCBiZSBkZXByZWNhdGVkXG5cbmZ1bmN0aW9uIGlzQXN5bmNNb2RlKG9iamVjdCkge1xuICB7XG4gICAgaWYgKCFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSkge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSB0cnVlOyAvLyBVc2luZyBjb25zb2xlWyd3YXJuJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuXG4gICAgICBjb25zb2xlWyd3YXJuJ10oJ1RoZSBSZWFjdElzLmlzQXN5bmNNb2RlKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE3Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgJyArICdSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBpbnN0ZWFkLiBJdCBoYXMgdGhlIGV4YWN0IHNhbWUgQVBJLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkgfHwgdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05URVhUX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9WSURFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNGb3J3YXJkUmVmKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZyYWdtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0xhenkob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTEFaWV9UWVBFO1xufVxuZnVuY3Rpb24gaXNNZW1vKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX01FTU9fVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFsKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BPUlRBTF9UWVBFO1xufVxuZnVuY3Rpb24gaXNQcm9maWxlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N1c3BlbnNlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG59XG5cbmV4cG9ydHMuQXN5bmNNb2RlID0gQXN5bmNNb2RlO1xuZXhwb3J0cy5Db25jdXJyZW50TW9kZSA9IENvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLkNvbnRleHRQcm92aWRlciA9IENvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbmV4cG9ydHMuTWVtbyA9IE1lbW87XG5leHBvcnRzLlBvcnRhbCA9IFBvcnRhbDtcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XG5leHBvcnRzLlN1c3BlbnNlID0gU3VzcGVuc2U7XG5leHBvcnRzLmlzQXN5bmNNb2RlID0gaXNBc3luY01vZGU7XG5leHBvcnRzLmlzQ29uY3VycmVudE1vZGUgPSBpc0NvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lciA9IGlzQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlciA9IGlzQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRm9yd2FyZFJlZiA9IGlzRm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNGcmFnbWVudCA9IGlzRnJhZ21lbnQ7XG5leHBvcnRzLmlzTGF6eSA9IGlzTGF6eTtcbmV4cG9ydHMuaXNNZW1vID0gaXNNZW1vO1xuZXhwb3J0cy5pc1BvcnRhbCA9IGlzUG9ydGFsO1xuZXhwb3J0cy5pc1Byb2ZpbGVyID0gaXNQcm9maWxlcjtcbmV4cG9ydHMuaXNTdHJpY3RNb2RlID0gaXNTdHJpY3RNb2RlO1xuZXhwb3J0cy5pc1N1c3BlbnNlID0gaXNTdXNwZW5zZTtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlO1xuZXhwb3J0cy50eXBlT2YgPSB0eXBlT2Y7XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4xXG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSAweGVhY2E7XG5leHBvcnRzLkZyYWdtZW50ID0gMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IDB4ZWFjZTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IDB4ZWFkOTtcbnZhciBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IDB4ZWFkYTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gMHhlYWQ1O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSAweGVhZDc7XG52YXIgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSAweGVhZTA7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSAweGVhZTE7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAweGVhZTI7XG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gMHhlYWUzO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnBvcnRhbCcpO1xuICBleHBvcnRzLkZyYWdtZW50ID0gc3ltYm9sRm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xuICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm9maWxlcicpO1xuICBSRUFDVF9QUk9WSURFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm92aWRlcicpO1xuICBSRUFDVF9DT05URVhUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmNvbnRleHQnKTtcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2UnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG4gIFJFQUNUX01FTU9fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubWVtbycpO1xuICBSRUFDVF9MQVpZX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxhenknKTtcbiAgUkVBQ1RfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuYmxvY2snKTtcbiAgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNlcnZlci5ibG9jaycpO1xuICBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpO1xuICBSRUFDVF9TQ09QRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zY29wZScpO1xuICBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub3BhcXVlLmlkJyk7XG4gIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG4gIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG59XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9XG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIEZpbHRlciBjZXJ0YWluIERPTSBhdHRyaWJ1dGVzIChlLmcuIHNyYywgaHJlZikgaWYgdGhlaXIgdmFsdWVzIGFyZSBlbXB0eSBzdHJpbmdzLlxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50IHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSB8fCB0eXBlWzBdID09PSBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBleHBvcnRzLkZyYWdtZW50OlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IHNlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JmY3MvcHVsbC8xMDdcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cblxuZnVuY3Rpb24ganN4REVWKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICB2YXIga2V5ID0gbnVsbDtcbiAgICB2YXIgcmVmID0gbnVsbDsgLy8gQ3VycmVudGx5LCBrZXkgY2FuIGJlIHNwcmVhZCBpbiBhcyBhIHByb3AuIFRoaXMgY2F1c2VzIGEgcG90ZW50aWFsXG4gICAgLy8gaXNzdWUgaWYga2V5IGlzIGFsc28gZXhwbGljaXRseSBkZWNsYXJlZCAoaWUuIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+XG4gICAgLy8gb3IgPGRpdiBrZXk9XCJIaVwiIHsuLi5wcm9wc30gLz4gKS4gV2Ugd2FudCB0byBkZXByZWNhdGUga2V5IHNwcmVhZCxcbiAgICAvLyBidXQgYXMgYW4gaW50ZXJtZWRpYXJ5IHN0ZXAsIHdlIHdpbGwgdXNlIGpzeERFViBmb3IgZXZlcnl0aGluZyBleGNlcHRcbiAgICAvLyA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPiwgYmVjYXVzZSB3ZSBhcmVuJ3QgY3VycmVudGx5IGFibGUgdG8gdGVsbCBpZlxuICAgIC8vIGtleSBpcyBleHBsaWNpdGx5IGRlY2xhcmVkIHRvIGJlIHVuZGVmaW5lZCBvciBub3QuXG5cbiAgICBpZiAobWF5YmVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5ID0gJycgKyBtYXliZUtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB7XG4gICAgaWYgKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpO1xuXG4gICAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZVN0cmluZztcblxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgc291cmNlLCBzZWxmKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2ldLCB0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCdSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiAnICsgJ1lvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gJyArICdVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCkge1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcblxudmFyIGpzeERFViQxID0gIGpzeFdpdGhWYWxpZGF0aW9uIDtcblxuZXhwb3J0cy5qc3hERVYgPSBqc3hERVYkMTtcbiAgfSkoKTtcbn1cbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4xXG4gKiByZWFjdC5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTcuMC4xJztcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IDB4ZWFjYTtcbmV4cG9ydHMuRnJhZ21lbnQgPSAweGVhY2I7XG5leHBvcnRzLlN0cmljdE1vZGUgPSAweGVhY2M7XG5leHBvcnRzLlByb2ZpbGVyID0gMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gMHhlYWNlO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSAweGVhZDA7XG5leHBvcnRzLlN1c3BlbnNlID0gMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSAweGVhZDk7XG52YXIgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSAweGVhZGE7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IDB4ZWFkNTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gMHhlYWQ3O1xudmFyIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gMHhlYWUwO1xudmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gMHhlYWUxO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gMHhlYWUyO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IDB4ZWFlMztcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5lbGVtZW50Jyk7XG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wb3J0YWwnKTtcbiAgZXhwb3J0cy5GcmFnbWVudCA9IHN5bWJvbEZvcigncmVhY3QuZnJhZ21lbnQnKTtcbiAgZXhwb3J0cy5TdHJpY3RNb2RlID0gc3ltYm9sRm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xuICBleHBvcnRzLlByb2ZpbGVyID0gc3ltYm9sRm9yKCdyZWFjdC5wcm9maWxlcicpO1xuICBSRUFDVF9QUk9WSURFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm92aWRlcicpO1xuICBSRUFDVF9DT05URVhUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmNvbnRleHQnKTtcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbiAgZXhwb3J0cy5TdXNwZW5zZSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2UnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG4gIFJFQUNUX01FTU9fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubWVtbycpO1xuICBSRUFDVF9MQVpZX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxhenknKTtcbiAgUkVBQ1RfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuYmxvY2snKTtcbiAgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNlcnZlci5ibG9jaycpO1xuICBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpO1xuICBSRUFDVF9TQ09QRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zY29wZScpO1xuICBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub3BhcXVlLmlkJyk7XG4gIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG4gIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG59XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGRpc3BhdGNoZXIuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgYmF0Y2gncyBjb25maWd1cmF0aW9uIHN1Y2ggYXMgaG93IGxvbmcgYW4gdXBkYXRlXG4gKiBzaG91bGQgc3VzcGVuZCBmb3IgaWYgaXQgbmVlZHMgdG8uXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyA9IHtcbiAgdHJhbnNpdGlvbjogMFxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IHt9O1xudmFyIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBudWxsO1xuZnVuY3Rpb24gc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKSB7XG4gIHtcbiAgICBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gc3RhY2s7XG4gIH1cbn1cblxue1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZSA9IGZ1bmN0aW9uIChzdGFjaykge1xuICAgIHtcbiAgICAgIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBzdGFjaztcbiAgICB9XG4gIH07IC8vIFN0YWNrIGltcGxlbWVudGF0aW9uIGluamVjdGVkIGJ5IHRoZSBjdXJyZW50IHJlbmRlcmVyLlxuXG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhY2sgPSAnJzsgLy8gQWRkIGFuIGV4dHJhIHRvcCBmcmFtZSB3aGlsZSBhbiBlbGVtZW50IGlzIGJlaW5nIHZhbGlkYXRlZFxuXG4gICAgaWYgKGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUpIHtcbiAgICAgIHN0YWNrICs9IGN1cnJlbnRFeHRyYVN0YWNrRnJhbWU7XG4gICAgfSAvLyBEZWxlZ2F0ZSB0byB0aGUgaW5qZWN0ZWQgcmVuZGVyZXItc3BlY2lmaWMgaW1wbGVtZW50YXRpb25cblxuXG4gICAgdmFyIGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcblxuICAgIGlmIChpbXBsKSB7XG4gICAgICBzdGFjayArPSBpbXBsKCkgfHwgJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xufVxuXG4vKipcbiAqIFVzZWQgYnkgYWN0KCkgdG8gdHJhY2sgd2hldGhlciB5b3UncmUgaW5zaWRlIGFuIGFjdCgpIHNjb3BlLlxuICovXG52YXIgSXNTb21lUmVuZGVyZXJBY3RpbmcgPSB7XG4gIGN1cnJlbnQ6IGZhbHNlXG59O1xuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSB7XG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXI6IFJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnOiBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxcbiAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICBJc1NvbWVSZW5kZXJlckFjdGluZzogSXNTb21lUmVuZGVyZXJBY3RpbmcsXG4gIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gIGFzc2lnbjogX2Fzc2lnblxufTtcblxue1xuICBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbn1cblxuLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbi8vXG4vLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9XG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9jb25zdHJ1Y3RvciAmJiAoX2NvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IF9jb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgXCIuXCIgKyBjYWxsZXJOYW1lO1xuXG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVycm9yKFwiQ2FuJ3QgY2FsbCAlcyBvbiBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCB5ZXQgbW91bnRlZC4gXCIgKyAnVGhpcyBpcyBhIG5vLW9wLCBidXQgaXQgbWlnaHQgaW5kaWNhdGUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi4gJyArICdJbnN0ZWFkLCBhc3NpZ24gdG8gYHRoaXMuc3RhdGVgIGRpcmVjdGx5IG9yIGRlZmluZSBhIGBzdGF0ZSA9IHt9O2AgJyArICdjbGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNpcmVkIHN0YXRlIGluIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0gPSB0cnVlO1xuICB9XG59XG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG5cblxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0OyAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cblxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICBpZiAoISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcInNldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbn07XG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG59O1xuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cblxuXG57XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcblxuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cblxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbi8qKlxuICogQ29udmVuaWVuY2UgY29tcG9uZW50IHdpdGggZGVmYXVsdCBzaGFsbG93IGVxdWFsaXR5IGNoZWNrIGZvciBzQ1UuXG4gKi9cblxuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDsgLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5cbl9hc3NpZ24ocHVyZUNvbXBvbmVudFByb3RvdHlwZSwgQ29tcG9uZW50LnByb3RvdHlwZSk7XG5cbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG4vLyBhbiBpbW11dGFibGUgb2JqZWN0IHdpdGggYSBzaW5nbGUgbXV0YWJsZSB2YWx1ZVxuZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuICB2YXIgcmVmT2JqZWN0ID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcblxuICB7XG4gICAgT2JqZWN0LnNlYWwocmVmT2JqZWN0KTtcbiAgfVxuXG4gIHJldHVybiByZWZPYmplY3Q7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIGV4cG9ydHMuUHJvZmlsZXI6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgZXhwb3J0cy5TdHJpY3RNb2RlOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgZXhwb3J0cy5TdXNwZW5zZTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biwgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24sIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZykge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIGNvbmZpZy5fX3NlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IGNvbmZpZy5fX3NlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgY29tcG9uZW50TmFtZSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcblxuICAgICAge1xuICAgICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbn1cbmZ1bmN0aW9uIGNsb25lQW5kUmVwbGFjZUtleShvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG4vKipcbiAqIENsb25lIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IHVzaW5nIGVsZW1lbnQgYXMgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjbG9uZWVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICBpZiAoISEoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB1bmRlZmluZWQpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3QuY2xvbmVFbGVtZW50KC4uLik6IFRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgXCIgKyBlbGVtZW50ICsgXCIuXCIgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvcE5hbWU7IC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcblxuICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG5cbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7IC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmOyAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cblxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlOyAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcblxuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcblxuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9IGtleS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0LnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGVsZW1lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gZWxlbWVudCBBIGVsZW1lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRLZXkoZWxlbWVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgZWxlbWVudCAhPT0gbnVsbCAmJiBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIGVzY2FwZSgnJyArIGVsZW1lbnQua2V5KTtcbiAgfSAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuXG5cbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gbWFwSW50b0FycmF5KGNoaWxkcmVuLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmFtZVNvRmFyLCBjYWxsYmFjaykge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGludm9rZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICB2YXIgX2NoaWxkID0gY2hpbGRyZW47XG4gICAgdmFyIG1hcHBlZENoaWxkID0gY2FsbGJhY2soX2NoaWxkKTsgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzOlxuXG4gICAgdmFyIGNoaWxkS2V5ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldEVsZW1lbnRLZXkoX2NoaWxkLCAwKSA6IG5hbWVTb0ZhcjtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgICAgdmFyIGVzY2FwZWRDaGlsZEtleSA9ICcnO1xuXG4gICAgICBpZiAoY2hpbGRLZXkgIT0gbnVsbCkge1xuICAgICAgICBlc2NhcGVkQ2hpbGRLZXkgPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoY2hpbGRLZXkpICsgJy8nO1xuICAgICAgfVxuXG4gICAgICBtYXBJbnRvQXJyYXkobWFwcGVkQ2hpbGQsIGFycmF5LCBlc2NhcGVkQ2hpbGRLZXksICcnLCBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgICBtYXBwZWRDaGlsZCA9IGNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCwgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICAgIGVzY2FwZWRQcmVmaXggKyAoIC8vICRGbG93Rml4TWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgUmVhY3QuUG9ydGFsIGRvZXNuJ3QgaGF2ZSBhIGtleVxuICAgICAgICBtYXBwZWRDaGlsZC5rZXkgJiYgKCFfY2hpbGQgfHwgX2NoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSA/IC8vICRGbG93Rml4TWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgZXhpc3RpbmcgZWxlbWVudCdzIGtleSBjYW4gYmUgYSBudW1iZXJcbiAgICAgICAgZXNjYXBlVXNlclByb3ZpZGVkS2V5KCcnICsgbWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICAgIH1cblxuICAgICAgYXJyYXkucHVzaChtYXBwZWRDaGlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IG1hcEludG9BcnJheShjaGlsZCwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5leHROYW1lLCBjYWxsYmFjayk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBpdGVyYWJsZUNoaWxkcmVuID0gY2hpbGRyZW47XG5cbiAgICAgIHtcbiAgICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICAgIGlmIChpdGVyYXRvckZuID09PSBpdGVyYWJsZUNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dE1hcHMpIHtcbiAgICAgICAgICAgIHdhcm4oJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gJyArICdVc2UgYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChpdGVyYWJsZUNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGlpID0gMDtcblxuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IG1hcEludG9BcnJheShjaGlsZCwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5leHROYW1lLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gJycgKyBjaGlsZHJlbjtcblxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcpICsgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgY291bnQgPSAwO1xuICBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIHJlc3VsdCwgJycsICcnLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBjb3VudCsrKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5jb3VudFxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5cblxuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgbiA9IDA7XG4gIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgbisrOyAvLyBEb24ndCByZXR1cm4gYW55dGhpbmdcbiAgfSk7XG4gIHJldHVybiBuO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmZvcmVhY2hcbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yRWFjaEZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gRG9uJ3QgcmV0dXJuIGFueXRoaW5nLlxuICB9LCBmb3JFYWNoQ29udGV4dCk7XG59XG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbnRvYXJyYXlcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH0pIHx8IFtdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICBpZiAoIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSwgY2FsY3VsYXRlQ2hhbmdlZEJpdHMpIHtcbiAgaWYgKGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSB1bmRlZmluZWQpIHtcbiAgICBjYWxjdWxhdGVDaGFuZ2VkQml0cyA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgaWYgKGNhbGN1bGF0ZUNoYW5nZWRCaXRzICE9PSBudWxsICYmIHR5cGVvZiBjYWxjdWxhdGVDaGFuZ2VkQml0cyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvcignY3JlYXRlQ29udGV4dDogRXhwZWN0ZWQgdGhlIG9wdGlvbmFsIHNlY29uZCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzJywgY2FsY3VsYXRlQ2hhbmdlZEJpdHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBjb250ZXh0ID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgX2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBjYWxjdWxhdGVDaGFuZ2VkQml0cyxcbiAgICAvLyBBcyBhIHdvcmthcm91bmQgdG8gc3VwcG9ydCBtdWx0aXBsZSBjb25jdXJyZW50IHJlbmRlcmVycywgd2UgY2F0ZWdvcml6ZVxuICAgIC8vIHNvbWUgcmVuZGVyZXJzIGFzIHByaW1hcnkgYW5kIG90aGVycyBhcyBzZWNvbmRhcnkuIFdlIG9ubHkgZXhwZWN0XG4gICAgLy8gdGhlcmUgdG8gYmUgdHdvIGNvbmN1cnJlbnQgcmVuZGVyZXJzIGF0IG1vc3Q6IFJlYWN0IE5hdGl2ZSAocHJpbWFyeSkgYW5kXG4gICAgLy8gRmFicmljIChzZWNvbmRhcnkpOyBSZWFjdCBET00gKHByaW1hcnkpIGFuZCBSZWFjdCBBUlQgKHNlY29uZGFyeSkuXG4gICAgLy8gU2Vjb25kYXJ5IHJlbmRlcmVycyBzdG9yZSB0aGVpciBjb250ZXh0IHZhbHVlcyBvbiBzZXBhcmF0ZSBmaWVsZHMuXG4gICAgX2N1cnJlbnRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgIF9jdXJyZW50VmFsdWUyOiBkZWZhdWx0VmFsdWUsXG4gICAgLy8gVXNlZCB0byB0cmFjayBob3cgbWFueSBjb25jdXJyZW50IHJlbmRlcmVycyB0aGlzIGNvbnRleHQgY3VycmVudGx5XG4gICAgLy8gc3VwcG9ydHMgd2l0aGluIGluIGEgc2luZ2xlIHJlbmRlcmVyLiBTdWNoIGFzIHBhcmFsbGVsIHNlcnZlciByZW5kZXJpbmcuXG4gICAgX3RocmVhZENvdW50OiAwLFxuICAgIC8vIFRoZXNlIGFyZSBjaXJjdWxhclxuICAgIFByb3ZpZGVyOiBudWxsLFxuICAgIENvbnN1bWVyOiBudWxsXG4gIH07XG4gIGNvbnRleHQuUHJvdmlkZXIgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BST1ZJREVSX1RZUEUsXG4gICAgX2NvbnRleHQ6IGNvbnRleHRcbiAgfTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gZmFsc2U7XG4gIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IGZhbHNlO1xuICB2YXIgaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIgPSBmYWxzZTtcblxuICB7XG4gICAgLy8gQSBzZXBhcmF0ZSBvYmplY3QsIGJ1dCBwcm94aWVzIGJhY2sgdG8gdGhlIG9yaWdpbmFsIGNvbnRleHQgb2JqZWN0IGZvclxuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBJdCBoYXMgYSBkaWZmZXJlbnQgJCR0eXBlb2YsIHNvIHdlIGNhbiBwcm9wZXJseVxuICAgIC8vIHdhcm4gZm9yIHRoZSBpbmNvcnJlY3QgdXNhZ2Ugb2YgQ29udGV4dCBhcyBhIENvbnN1bWVyLlxuICAgIHZhciBDb25zdW1lciA9IHtcbiAgICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgICBfY29udGV4dDogY29udGV4dCxcbiAgICAgIF9jYWxjdWxhdGVDaGFuZ2VkQml0czogY29udGV4dC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHNcbiAgICB9OyAvLyAkRmxvd0ZpeE1lOiBGbG93IGNvbXBsYWlucyBhYm91dCBub3Qgc2V0dGluZyBhIHZhbHVlLCB3aGljaCBpcyBpbnRlbnRpb25hbCBoZXJlXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb25zdW1lciwge1xuICAgICAgUHJvdmlkZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlcikge1xuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIgPSB0cnVlO1xuXG4gICAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0LkNvbnN1bWVyLlByb3ZpZGVyPiBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LlByb3ZpZGVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb250ZXh0LlByb3ZpZGVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfUHJvdmlkZXIpIHtcbiAgICAgICAgICBjb250ZXh0LlByb3ZpZGVyID0gX1Byb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2N1cnJlbnRWYWx1ZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jdXJyZW50VmFsdWUyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfY3VycmVudFZhbHVlMikge1xuICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBfY3VycmVudFZhbHVlMjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF90aHJlYWRDb3VudDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fdGhyZWFkQ291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF90aHJlYWRDb3VudCkge1xuICAgICAgICAgIGNvbnRleHQuX3RocmVhZENvdW50ID0gX3RocmVhZENvdW50O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgQ29uc3VtZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycykge1xuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSB0cnVlO1xuXG4gICAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0LkNvbnN1bWVyLkNvbnN1bWVyPiBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LkNvbnN1bWVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb250ZXh0LkNvbnN1bWVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGlzcGxheU5hbWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuZGlzcGxheU5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lcikge1xuICAgICAgICAgICAgd2FybignU2V0dGluZyBgZGlzcGxheU5hbWVgIG9uIENvbnRleHQuQ29uc3VtZXIgaGFzIG5vIGVmZmVjdC4gJyArIFwiWW91IHNob3VsZCBzZXQgaXQgZGlyZWN0bHkgb24gdGhlIGNvbnRleHQgd2l0aCBDb250ZXh0LmRpc3BsYXlOYW1lID0gJyVzJy5cIiwgZGlzcGxheU5hbWUpO1xuXG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG1pc3NpbmcgcHJvcGVydGllcyBiZWNhdXNlIGl0IGRvZXNuJ3QgdW5kZXJzdGFuZCBkZWZpbmVQcm9wZXJ0eVxuXG4gICAgY29udGV4dC5Db25zdW1lciA9IENvbnN1bWVyO1xuICB9XG5cbiAge1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IG51bGw7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxudmFyIFVuaW5pdGlhbGl6ZWQgPSAtMTtcbnZhciBQZW5kaW5nID0gMDtcbnZhciBSZXNvbHZlZCA9IDE7XG52YXIgUmVqZWN0ZWQgPSAyO1xuXG5mdW5jdGlvbiBsYXp5SW5pdGlhbGl6ZXIocGF5bG9hZCkge1xuICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBVbmluaXRpYWxpemVkKSB7XG4gICAgdmFyIGN0b3IgPSBwYXlsb2FkLl9yZXN1bHQ7XG4gICAgdmFyIHRoZW5hYmxlID0gY3RvcigpOyAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuXG4gICAgdmFyIHBlbmRpbmcgPSBwYXlsb2FkO1xuICAgIHBlbmRpbmcuX3N0YXR1cyA9IFBlbmRpbmc7XG4gICAgcGVuZGluZy5fcmVzdWx0ID0gdGhlbmFibGU7XG4gICAgdGhlbmFibGUudGhlbihmdW5jdGlvbiAobW9kdWxlT2JqZWN0KSB7XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nKSB7XG4gICAgICAgIHZhciBkZWZhdWx0RXhwb3J0ID0gbW9kdWxlT2JqZWN0LmRlZmF1bHQ7XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmIChkZWZhdWx0RXhwb3J0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVycm9yKCdsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXBvcnQoKSBjYWxsLiAnICsgJ0luc3RlYWQgcmVjZWl2ZWQ6ICVzXFxuXFxuWW91ciBjb2RlIHNob3VsZCBsb29rIGxpa2U6IFxcbiAgJyArIC8vIEJyZWFrIHVwIGltcG9ydHMgdG8gYXZvaWQgYWNjaWRlbnRhbGx5IHBhcnNpbmcgdGhlbSBhcyBkZXBlbmRlbmNpZXMuXG4gICAgICAgICAgICAnY29uc3QgTXlDb21wb25lbnQgPSBsYXp5KCgpID0+IGltcCcgKyBcIm9ydCgnLi9NeUNvbXBvbmVudCcpKVwiLCBtb2R1bGVPYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuXG5cbiAgICAgICAgdmFyIHJlc29sdmVkID0gcGF5bG9hZDtcbiAgICAgICAgcmVzb2x2ZWQuX3N0YXR1cyA9IFJlc29sdmVkO1xuICAgICAgICByZXNvbHZlZC5fcmVzdWx0ID0gZGVmYXVsdEV4cG9ydDtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFBlbmRpbmcpIHtcbiAgICAgICAgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICAgICAgdmFyIHJlamVjdGVkID0gcGF5bG9hZDtcbiAgICAgICAgcmVqZWN0ZWQuX3N0YXR1cyA9IFJlamVjdGVkO1xuICAgICAgICByZWplY3RlZC5fcmVzdWx0ID0gZXJyb3I7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBSZXNvbHZlZCkge1xuICAgIHJldHVybiBwYXlsb2FkLl9yZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgcGF5bG9hZC5fcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGxhenkoY3Rvcikge1xuICB2YXIgcGF5bG9hZCA9IHtcbiAgICAvLyBXZSB1c2UgdGhlc2UgZmllbGRzIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gICAgX3N0YXR1czogLTEsXG4gICAgX3Jlc3VsdDogY3RvclxuICB9O1xuICB2YXIgbGF6eVR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0xBWllfVFlQRSxcbiAgICBfcGF5bG9hZDogcGF5bG9hZCxcbiAgICBfaW5pdDogbGF6eUluaXRpYWxpemVyXG4gIH07XG5cbiAge1xuICAgIC8vIEluIHByb2R1Y3Rpb24sIHRoaXMgd291bGQganVzdCBzZXQgaXQgb24gdGhlIG9iamVjdC5cbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuICAgIHZhciBwcm9wVHlwZXM7IC8vICRGbG93Rml4TWVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxhenlUeXBlLCB7XG4gICAgICBkZWZhdWx0UHJvcHM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFByb3BzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdEZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgZGVmYXVsdFByb3BzYCB0byAnICsgJ2EgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgJyArICdpcyBkZWZpbmVkLCBvciBjcmVhdGUgYSB3cmFwcGluZyBjb21wb25lbnQgYXJvdW5kIGl0LicpO1xuXG4gICAgICAgICAgZGVmYXVsdFByb3BzID0gbmV3RGVmYXVsdFByb3BzOyAvLyBNYXRjaCBwcm9kdWN0aW9uIGJlaGF2aW9yIG1vcmUgY2xvc2VseTpcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGF6eVR5cGUsICdkZWZhdWx0UHJvcHMnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFR5cGVzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdQcm9wVHlwZXMpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgcHJvcFR5cGVzYCB0byAnICsgJ2EgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgJyArICdpcyBkZWZpbmVkLCBvciBjcmVhdGUgYSB3cmFwcGluZyBjb21wb25lbnQgYXJvdW5kIGl0LicpO1xuXG4gICAgICAgICAgcHJvcFR5cGVzID0gbmV3UHJvcFR5cGVzOyAvLyBNYXRjaCBwcm9kdWN0aW9uIGJlaGF2aW9yIG1vcmUgY2xvc2VseTpcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGF6eVR5cGUsICdwcm9wVHlwZXMnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBsYXp5VHlwZTtcbn1cblxuZnVuY3Rpb24gZm9yd2FyZFJlZihyZW5kZXIpIHtcbiAge1xuICAgIGlmIChyZW5kZXIgIT0gbnVsbCAmJiByZW5kZXIuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHJlY2VpdmVkIGEgYG1lbW9gICcgKyAnY29tcG9uZW50LiBJbnN0ZWFkIG9mIGZvcndhcmRSZWYobWVtbyguLi4pKSwgdXNlICcgKyAnbWVtbyhmb3J3YXJkUmVmKC4uLikpLicpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlbmRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHdhcyBnaXZlbiAlcy4nLCByZW5kZXIgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgcmVuZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlbmRlci5sZW5ndGggIT09IDAgJiYgcmVuZGVyLmxlbmd0aCAhPT0gMikge1xuICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGFjY2VwdCBleGFjdGx5IHR3byBwYXJhbWV0ZXJzOiBwcm9wcyBhbmQgcmVmLiAlcycsIHJlbmRlci5sZW5ndGggPT09IDEgPyAnRGlkIHlvdSBmb3JnZXQgdG8gdXNlIHRoZSByZWYgcGFyYW1ldGVyPycgOiAnQW55IGFkZGl0aW9uYWwgcGFyYW1ldGVyIHdpbGwgYmUgdW5kZWZpbmVkLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZW5kZXIgIT0gbnVsbCkge1xuICAgICAgaWYgKHJlbmRlci5kZWZhdWx0UHJvcHMgIT0gbnVsbCB8fCByZW5kZXIucHJvcFR5cGVzICE9IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBkbyBub3Qgc3VwcG9ydCBwcm9wVHlwZXMgb3IgZGVmYXVsdFByb3BzLiAnICsgJ0RpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgYSBSZWFjdCBjb21wb25lbnQ/Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnRUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLFxuICAgIHJlbmRlcjogcmVuZGVyXG4gIH07XG5cbiAge1xuICAgIHZhciBvd25OYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50VHlwZSwgJ2Rpc3BsYXlOYW1lJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBvd25OYW1lID0gbmFtZTtcblxuICAgICAgICBpZiAocmVuZGVyLmRpc3BsYXlOYW1lID09IG51bGwpIHtcbiAgICAgICAgICByZW5kZXIuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFR5cGU7XG59XG5cbi8vIEZpbHRlciBjZXJ0YWluIERPTSBhdHRyaWJ1dGVzIChlLmcuIHNyYywgaHJlZikgaWYgdGhlaXIgdmFsdWVzIGFyZSBlbXB0eSBzdHJpbmdzLlxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50IHx8IHR5cGUgPT09IGV4cG9ydHMuUHJvZmlsZXIgfHwgdHlwZSA9PT0gUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgfHwgdHlwZSA9PT0gZXhwb3J0cy5TdHJpY3RNb2RlIHx8IHR5cGUgPT09IGV4cG9ydHMuU3VzcGVuc2UgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFIHx8IHR5cGVbMF0gPT09IFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG1lbW8odHlwZSwgY29tcGFyZSkge1xuICB7XG4gICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkpIHtcbiAgICAgIGVycm9yKCdtZW1vOiBUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIGNvbXBvbmVudC4gSW5zdGVhZCAnICsgJ3JlY2VpdmVkOiAlcycsIHR5cGUgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnRUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9NRU1PX1RZUEUsXG4gICAgdHlwZTogdHlwZSxcbiAgICBjb21wYXJlOiBjb21wYXJlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29tcGFyZVxuICB9O1xuXG4gIHtcbiAgICB2YXIgb3duTmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsICdkaXNwbGF5TmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgb3duTmFtZSA9IG5hbWU7XG5cbiAgICAgICAgaWYgKHR5cGUuZGlzcGxheU5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgIHR5cGUuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFR5cGU7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEaXNwYXRjaGVyKCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDtcblxuICBpZiAoIShkaXNwYXRjaGVyICE9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4xLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4yLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcblNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3BhdGNoZXI7XG59XG5cbmZ1bmN0aW9uIHVzZUNvbnRleHQoQ29udGV4dCwgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcblxuICB7XG4gICAgaWYgKHVuc3RhYmxlX29ic2VydmVkQml0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvcigndXNlQ29udGV4dCgpIHNlY29uZCBhcmd1bWVudCBpcyByZXNlcnZlZCBmb3IgZnV0dXJlICcgKyAndXNlIGluIFJlYWN0LiBQYXNzaW5nIGl0IGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnWW91IHBhc3NlZDogJXMuJXMnLCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMsIHR5cGVvZiB1bnN0YWJsZV9vYnNlcnZlZEJpdHMgPT09ICdudW1iZXInICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzJdKSA/ICdcXG5cXG5EaWQgeW91IGNhbGwgYXJyYXkubWFwKHVzZUNvbnRleHQpPyAnICsgJ0NhbGxpbmcgSG9va3MgaW5zaWRlIGEgbG9vcCBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0xlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3J1bGVzLW9mLWhvb2tzJyA6ICcnKTtcbiAgICB9IC8vIFRPRE86IGFkZCBhIG1vcmUgZ2VuZXJpYyB3YXJuaW5nIGZvciBpbnZhbGlkIHZhbHVlcy5cblxuXG4gICAgaWYgKENvbnRleHQuX2NvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJlYWxDb250ZXh0ID0gQ29udGV4dC5fY29udGV4dDsgLy8gRG9uJ3QgZGVkdXBsaWNhdGUgYmVjYXVzZSB0aGlzIGxlZ2l0aW1hdGVseSBjYXVzZXMgYnVnc1xuICAgICAgLy8gYW5kIG5vYm9keSBzaG91bGQgYmUgdXNpbmcgdGhpcyBpbiBleGlzdGluZyBjb2RlLlxuXG4gICAgICBpZiAocmVhbENvbnRleHQuQ29uc3VtZXIgPT09IENvbnRleHQpIHtcbiAgICAgICAgZXJyb3IoJ0NhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LkNvbnN1bWVyKSBpcyBub3Qgc3VwcG9ydGVkLCBtYXkgY2F1c2UgYnVncywgYW5kIHdpbGwgYmUgJyArICdyZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD8nKTtcbiAgICAgIH0gZWxzZSBpZiAocmVhbENvbnRleHQuUHJvdmlkZXIgPT09IENvbnRleHQpIHtcbiAgICAgICAgZXJyb3IoJ0NhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LlByb3ZpZGVyKSBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzcGF0Y2hlci51c2VDb250ZXh0KENvbnRleHQsIHVuc3RhYmxlX29ic2VydmVkQml0cyk7XG59XG5mdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VTdGF0ZShpbml0aWFsU3RhdGUpO1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbn1cbmZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWYoaW5pdGlhbFZhbHVlKTtcbn1cbmZ1bmN0aW9uIHVzZUVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlTWVtbyhjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VNZW1vKGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKTtcbiAgfVxufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuU3VzcGVuc2U6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhlbGVtZW50UHJvcHMpIHtcbiAgaWYgKGVsZW1lbnRQcm9wcyAhPT0gbnVsbCAmJiBlbGVtZW50UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShlbGVtZW50UHJvcHMuX19zb3VyY2UpO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5mbztcbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgfVxuXG4gIHtcbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICBpZiAoIXZhbGlkVHlwZSkge1xuICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMocHJvcHMpO1xuXG4gICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZVN0cmluZztcblxuICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgfVxuXG4gICAge1xuICAgICAgZXJyb3IoJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gIGlmICh2YWxpZFR5cGUpIHtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCkge1xuICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxudmFyIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5ID0gZmFsc2U7XG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24odHlwZSkge1xuICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbi5iaW5kKG51bGwsIHR5cGUpO1xuICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gIHtcbiAgICBpZiAoIWRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5KSB7XG4gICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IHRydWU7XG5cbiAgICAgIHdhcm4oJ1JlYWN0LmNyZWF0ZUZhY3RvcnkoKSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBDb25zaWRlciB1c2luZyBKU1ggJyArICdvciB1c2UgUmVhY3QuY3JlYXRlRWxlbWVudCgpIGRpcmVjdGx5IGluc3RlYWQuJyk7XG4gICAgfSAvLyBMZWdhY3kgaG9vazogcmVtb3ZlIGl0XG5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG59XG5mdW5jdGlvbiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbihlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgfVxuXG4gIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxue1xuXG4gIHRyeSB7XG4gICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL1xuXG4gICAgbmV3IE1hcChbW2Zyb3plbk9iamVjdCwgbnVsbF1dKTtcbiAgICBuZXcgU2V0KFtmcm96ZW5PYmplY3RdKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldyAqL1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cblxudmFyIGNyZWF0ZUVsZW1lbnQkMSA9ICBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24gO1xudmFyIGNsb25lRWxlbWVudCQxID0gIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uIDtcbnZhciBjcmVhdGVGYWN0b3J5ID0gIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbiA7XG52YXIgQ2hpbGRyZW4gPSB7XG4gIG1hcDogbWFwQ2hpbGRyZW4sXG4gIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gIHRvQXJyYXk6IHRvQXJyYXksXG4gIG9ubHk6IG9ubHlDaGlsZFxufTtcblxuZXhwb3J0cy5DaGlsZHJlbiA9IENoaWxkcmVuO1xuZXhwb3J0cy5Db21wb25lbnQgPSBDb21wb25lbnQ7XG5leHBvcnRzLlB1cmVDb21wb25lbnQgPSBQdXJlQ29tcG9uZW50O1xuZXhwb3J0cy5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzO1xuZXhwb3J0cy5jbG9uZUVsZW1lbnQgPSBjbG9uZUVsZW1lbnQkMTtcbmV4cG9ydHMuY3JlYXRlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ7XG5leHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50JDE7XG5leHBvcnRzLmNyZWF0ZUZhY3RvcnkgPSBjcmVhdGVGYWN0b3J5O1xuZXhwb3J0cy5jcmVhdGVSZWYgPSBjcmVhdGVSZWY7XG5leHBvcnRzLmZvcndhcmRSZWYgPSBmb3J3YXJkUmVmO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudCA9IGlzVmFsaWRFbGVtZW50O1xuZXhwb3J0cy5sYXp5ID0gbGF6eTtcbmV4cG9ydHMubWVtbyA9IG1lbW87XG5leHBvcnRzLnVzZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s7XG5leHBvcnRzLnVzZUNvbnRleHQgPSB1c2VDb250ZXh0O1xuZXhwb3J0cy51c2VEZWJ1Z1ZhbHVlID0gdXNlRGVidWdWYWx1ZTtcbmV4cG9ydHMudXNlRWZmZWN0ID0gdXNlRWZmZWN0O1xuZXhwb3J0cy51c2VJbXBlcmF0aXZlSGFuZGxlID0gdXNlSW1wZXJhdGl2ZUhhbmRsZTtcbmV4cG9ydHMudXNlTGF5b3V0RWZmZWN0ID0gdXNlTGF5b3V0RWZmZWN0O1xuZXhwb3J0cy51c2VNZW1vID0gdXNlTWVtbztcbmV4cG9ydHMudXNlUmVkdWNlciA9IHVzZVJlZHVjZXI7XG5leHBvcnRzLnVzZVJlZiA9IHVzZVJlZjtcbmV4cG9ydHMudXNlU3RhdGUgPSB1c2VTdGF0ZTtcbmV4cG9ydHMudmVyc2lvbiA9IFJlYWN0VmVyc2lvbjtcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBJRSA4IGhhcyBhIGJyb2tlbiBPYmplY3QuZGVmaW5lUHJvcGVydHkgdGhhdCBvbmx5IHdvcmtzIG9uIERPTSBvYmplY3RzLlxuICAgIGRlZmluZSh7fSwgXCJcIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlZmluZSA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKFxuICAgIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLFxuICAgIHRvU3RyaW5nVGFnU3ltYm9sLFxuICAgIFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICApO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxuICAgICAgUHJvbWlzZUltcGxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICByZXR1cm4gZXhwb3J0cztcblxufShcbiAgLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiID8gbW9kdWxlLmV4cG9ydHMgOiB7fVxuKSk7XG5cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcbiAgLy8gaW4gY2FzZSBydW50aW1lLmpzIGFjY2lkZW50YWxseSBydW5zIGluIHN0cmljdCBtb2RlLCB3ZSBjYW4gZXNjYXBlXG4gIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxuICAvLyBpZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGZvcmJpZHMgdXNpbmcgRnVuY3Rpb24sIGJ1dCBpbiB0aGF0IGNhc2VcbiAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcbiAgLy8gQ1NQIHRvIGZvcmJpZCBGdW5jdGlvbiwgYW5kIHlvdSdyZSBub3Qgd2lsbGluZyB0byBmaXggZWl0aGVyIG9mIHRob3NlXG4gIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xufVxuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY3JlYXRlQmluZGluZyhvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHQuZGVmYXVsdCA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgcHJpdmF0ZU1hcCkge1xyXG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcml2YXRlTWFwLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xyXG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgIH1cclxuICAgIHByaXZhdGVNYXAuc2V0KHJlY2VpdmVyLCB2YWx1ZSk7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcblxyXG5jb25zdCBBcHBDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcclxuXHJcbmV4cG9ydCBjb25zdCBBcHBXcmFwcGVyID0gKHtjaGlsZHJlbn0pID0+IHtcclxuICAgIGNvbnN0IFtzZWxlY3RlZFRhZywgc2V0U2VsZWN0ZWRUYWddID0gdXNlU3RhdGUobnVsbCk7XHJcblxyXG4gICAgY29uc3QgdGhlbWUgPSB7XHJcbiAgICAgICAgeWVsbG93OiAnI0ZERkZCNicsXHJcbiAgICAgICAgYmx1ZTogJyM5QkY2RkYnLFxyXG4gICAgICAgIHBpbms6ICcjRkZBREFEJyxcclxuICAgICAgICBncmVlbjogJyNDQUZGQkYnLFxyXG4gICAgICAgIGdyYXk6ICcjQURCNUJEJyxcclxuICAgICAgICBibGFjazogJyMyMTI1MjknLFxyXG4gICAgICAgIHdoaXRlOiAnI0ZGRkZGQycsXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IHNoYXJlZFN0YXRlID0ge1xyXG4gICAgICAgIHNlbGVjdGVkVGFnLFxyXG4gICAgICAgIHNldFNlbGVjdGVkVGFnLFxyXG4gICAgICAgIHRoZW1lLFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxBcHBDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtzaGFyZWRTdGF0ZX0+XHJcbiAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgPC9BcHBDb250ZXh0LlByb3ZpZGVyPlxyXG4gICAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBVc2VBcHBDb250ZXh0ID0gKCkgPT4ge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXHJcbiAgICByZXR1cm4gdXNlQ29udGV4dChBcHBDb250ZXh0KTtcclxufTtcclxuIiwidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vLnlhcm4vX192aXJ0dWFsX18vc3R5bGUtbG9hZGVyLXZpcnR1YWwtNTAxZTgyOTY4ZC8wL2NhY2hlL3N0eWxlLWxvYWRlci1ucG0tMS4yLjEtZDJlMjk4YWRkYy1jZDMwNDg0NjY1LnppcC9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy55YXJuL19fdmlydHVhbF9fL2Nzcy1sb2FkZXItdmlydHVhbC1jOTE0ZjcwNjUxLzAvY2FjaGUvY3NzLWxvYWRlci1ucG0tNC4zLjAtMzM0NjQxOTdjOS02OTdhODgzOGYwLnppcC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LW9uZU9mLTYtMSEuLi8uLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtMzVkNTg5NzM1Ny8wL2NhY2hlL25leHQtbnBtLTEwLjAuMy02NDJjZDQ1YzA5LTQ3YjFiM2U0N2EuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtNi0yIS4vc3R5bGVzLmNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpey8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxudmFyIGFuY2hvckVsZW1lbnQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO3ZhciBwYXJlbnROb2RlPWFuY2hvckVsZW1lbnQucGFyZW50Tm9kZTsvLyBOb3JtYWxseSA8aGVhZD5cbi8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCxhbmNob3JFbGVtZW50KTt9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiKSB7XG4gIGlmICghYSAmJiBiIHx8IGEgJiYgIWIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcDtcblxuICBmb3IgKHAgaW4gYSkge1xuICAgIGlmIChhW3BdICE9PSBiW3BdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZm9yIChwIGluIGIpIHtcbiAgICBpZiAoIWFbcF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vLnlhcm4vX192aXJ0dWFsX18vY3NzLWxvYWRlci12aXJ0dWFsLWM5MTRmNzA2NTEvMC9jYWNoZS9jc3MtbG9hZGVyLW5wbS00LjMuMC0zMzQ2NDE5N2M5LTY5N2E4ODM4ZjAuemlwL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTUtb25lT2YtNi0xIS4uLy4uLy55YXJuL19fdmlydHVhbF9fL25leHQtdmlydHVhbC0zNWQ1ODk3MzU3LzAvY2FjaGUvbmV4dC1ucG0tMTAuMC4zLTY0MmNkNDVjMDktNDdiMWIzZTQ3YS56aXAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi02LTIhLi9zdHlsZXMuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8ueWFybi9fX3ZpcnR1YWxfXy9jc3MtbG9hZGVyLXZpcnR1YWwtYzkxNGY3MDY1MS8wL2NhY2hlL2Nzcy1sb2FkZXItbnBtLTQuMy4wLTMzNDY0MTk3YzktNjk3YTg4MzhmMC56aXAvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tNS1vbmVPZi02LTEhLi4vLi4vLnlhcm4vX192aXJ0dWFsX18vbmV4dC12aXJ0dWFsLTM1ZDU4OTczNTcvMC9jYWNoZS9uZXh0LW5wbS0xMC4wLjMtNjQyY2Q0NWMwOS00N2IxYjNlNDdhLnppcC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTYtMiEuL3N0eWxlcy5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwiaW1wb3J0ICcuLi9saWIvc3R5bGVzL3N0eWxlcy5jc3MnO1xuaW1wb3J0IHsgQXBwV3JhcHBlciB9IGZyb20gJy4uL2xpYi9jb250ZXh0JztcbmltcG9ydCB7IGRhdGFkb2dSdW0gfSBmcm9tICdAZGF0YWRvZy9icm93c2VyLXJ1bSc7XG5cbmRhdGFkb2dSdW0uaW5pdCh7XG4gICAgYXBwbGljYXRpb25JZDogJzcwZTNlY2MyLWYzN2YtNGY2MC1hYjI0LTM0Y2FlYzZiZTEzZCcsXG4gICAgY2xpZW50VG9rZW46ICdwdWI3MzA3Y2ZhYTYwMmQ2ZTk1YjEzNzY1MDBjZThkZTJmYicsXG4gICAgc2l0ZTogJ2RhdGFkb2docS5ldScsXG4gICAgc2VydmljZTonbmV0bGlmeS1pbnRlcm5ldC1ibG9nJyxcbiAgICAvLyBTcGVjaWZ5IGEgdmVyc2lvbiBudW1iZXIgdG8gaWRlbnRpZnkgdGhlIGRlcGxveWVkIHZlcnNpb24gb2YgeW91ciBhcHBsaWNhdGlvbiBpbiBEYXRhZG9nIFxuICAgIC8vIHZlcnNpb246ICcxLjAuMCcsXG4gICAgc2FtcGxlUmF0ZTogMTAwLFxuICAgIHRyYWNrSW50ZXJhY3Rpb25zOiB0cnVlXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTXlBcHAoeyBDb21wb25lbnQsIHBhZ2VQcm9wcyB9KSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPEFwcFdyYXBwZXI+XG4gICAgICAgICAgICA8Q29tcG9uZW50IHsgLi4ucGFnZVByb3BzIH0gLz5cbiAgICAgICAgPC9BcHBXcmFwcGVyPlxuICAgICk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9